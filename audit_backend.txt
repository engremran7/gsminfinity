============================================
ENTERPRISE AUDIT DUMP (Backend (.py))
Generated: 2025-11-28 16:13:44
Root: D:\GsmInfinity
Total Files: 137
============================================

--------------------------------------------
### FILE: apps\__init__.py
### SIZE: 22 bytes
### HASH: D081173FB16841717481041259B8FA09A1628AB385FBB1BBA8668CB53833526C

# apps package marker


--------------------------------------------
### FILE: apps\ads\__init__.py
### SIZE: 47 bytes
### HASH: A11B864944CA227E93442A5DBCE447B3DC5AAACC005BA57F19AB0140C7B4A8F0

default_app_config = "apps.ads.apps.AdsConfig"


--------------------------------------------
### FILE: apps\ads\admin.py
### SIZE: 2266 bytes
### HASH: 7510F060C26CA8C213CCC981EBE3E7255CF5D2A8D4E6147B22E12516AEF82B3E

from django.contrib import admin

from .models import (
    AdPlacement,
    AdCreative,
    Campaign,
    PlacementAssignment,
    AffiliateSource,
    AffiliateLink,
    AdEvent,
)


@admin.register(AdPlacement)
class AdPlacementAdmin(admin.ModelAdmin):
    list_display = ("name", "code", "context", "is_active", "locked", "updated_at")
    list_filter = ("is_active", "locked", "context")
    search_fields = ("name", "slug", "code", "context", "page_context")


@admin.register(Campaign)
class CampaignAdmin(admin.ModelAdmin):
    list_display = ("name", "type", "is_active", "priority", "weight", "start_at", "end_at")
    list_filter = ("type", "is_active", "ad_network")
    search_fields = ("name",)


@admin.register(AdCreative)
class AdCreativeAdmin(admin.ModelAdmin):
    list_display = ("name", "campaign", "creative_type", "is_active", "locked", "weight")
    list_filter = ("creative_type", "is_active", "locked", "campaign")
    search_fields = ("name", "campaign__name")


@admin.register(PlacementAssignment)
class PlacementAssignmentAdmin(admin.ModelAdmin):
    list_display = ("placement", "creative", "weight", "is_active", "locked")
    list_filter = ("placement", "creative", "is_active", "locked")


@admin.register(AffiliateSource)
class AffiliateSourceAdmin(admin.ModelAdmin):
    list_display = ("name", "network", "base_url", "is_enabled", "locked", "updated_at")
    list_filter = ("network", "is_enabled", "locked")
    search_fields = ("name", "network", "base_url")


@admin.register(AffiliateLink)
class AffiliateLinkAdmin(admin.ModelAdmin):
    list_display = ("name", "source", "affiliate_url", "is_active", "locked", "usage_count")
    list_filter = ("source", "is_active", "locked")
    search_fields = ("name", "affiliate_url", "target_url", "source__name")


@admin.register(AdEvent)
class AdEventAdmin(admin.ModelAdmin):
    list_display = ("event_type", "campaign", "placement", "creative", "page_url", "created_at")
    list_filter = ("event_type", "campaign")
    readonly_fields = (
        "event_type",
        "campaign",
        "placement",
        "creative",
        "user",
        "request_meta",
        "page_url",
        "referrer_url",
        "user_agent",
        "session_id",
        "created_at",
    )


--------------------------------------------
### FILE: apps\ads\apps.py
### SIZE: 292 bytes
### HASH: 065092B5C6C75815F7A768925DEE93583CA9133836ED2AE5833A995CE8AD8F1C

from django.apps import AppConfig


class AdsConfig(AppConfig):
    name = "apps.ads"
    verbose_name = "Ads & Monetization"

    def ready(self):
        # Import signals if present
        try:
            import apps.ads.signals  # noqa: F401
        except Exception:
            return


--------------------------------------------
### FILE: apps\ads\management\commands\scan_ad_placements.py
### SIZE: 3007 bytes
### HASH: 53D5C3DA03123E737AC7E6DFF92C4A53BCFC5B4E586A2EA69A21444AFFC255BC

from __future__ import annotations

import re
from pathlib import Path

from django.core.management.base import BaseCommand
from django.template.defaultfilters import slugify

from apps.ads.models import AdPlacement


class Command(BaseCommand):
    help = "Scan templates for ad placeholders and ensure AdPlacement records exist."

    def add_arguments(self, parser):
        parser.add_argument(
            "--templates-dir",
            default="templates",
            help="Root templates directory to scan",
        )

    def handle(self, *args, **options):
        root = Path(options["templates_dir"]).resolve()
        pattern = re.compile(
            r"(ads:slot|<!--\s*ad-slot:)(?P<name>[\w\-\s]+)(?:\s+sizes=(?P<sizes>[\w,x]+))?(?:\s+types=(?P<types>[\w,]+))?",
            re.IGNORECASE,
        )
        created = 0
        updated = 0
        if not root.exists():
            self.stdout.write(self.style.WARNING(f"Templates dir not found: {root}"))
            return
        for path in root.rglob("*.html"):
            try:
                text = path.read_text(encoding="utf-8", errors="ignore")
            except Exception:
                continue
            for match in pattern.finditer(text):
                raw_name = match.group("name").strip()
                if not raw_name:
                    continue
                slug = slugify(raw_name)
                allowed_sizes = (match.group("sizes") or "").replace(" ", "")
                allowed_types = (match.group("types") or "").replace(" ", "") or "banner,native,html"
                obj, created_flag = AdPlacement.objects.get_or_create(
                    slug=slug,
                    defaults={
                        "code": slug or raw_name.lower().replace(" ", "-"),
                        "name": raw_name,
                        "allowed_types": allowed_types,
                        "allowed_sizes": allowed_sizes,
                        "context": "auto",
                    },
                )
                if created_flag:
                    created += 1
                    continue

                changed = False
                if obj.name != raw_name:
                    obj.name = raw_name
                    changed = True
                if not obj.code:
                    obj.code = slug or raw_name.lower().replace(" ", "-")
                    changed = True
                if allowed_sizes and obj.allowed_sizes != allowed_sizes:
                    obj.allowed_sizes = allowed_sizes
                    changed = True
                if allowed_types and obj.allowed_types != allowed_types:
                    obj.allowed_types = allowed_types
                    changed = True
                if changed:
                    obj.save()
                    updated += 1
        self.stdout.write(
            self.style.SUCCESS(
                f"Scan complete. Created: {created}, Updated: {updated}, Total: {AdPlacement.objects.count()}"
            )
        )


--------------------------------------------
### FILE: apps\ads\models.py
### SIZE: 7632 bytes
### HASH: 20BFFAD6258E39620EE7B657A812881422FF21ACAC71D1BAE44BE2D78B5C6F65

from __future__ import annotations

from django.conf import settings
from django.db import models
from django.utils import timezone

from apps.core.models import TimestampedModel, SoftDeleteModel, AuditFieldsModel


class AdPlacement(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    """
    Represents a slot in the UI. Auto-created by scan_ad_placements.
    """

    name = models.CharField(max_length=150, unique=True)
    code = models.CharField(
        max_length=120,
        unique=True,
        help_text="Stable placement code used in templates and auto-discovery.",
    )
    slug = models.SlugField(max_length=180, unique=True)
    description = models.TextField(blank=True, default="")
    allowed_types = models.CharField(
        max_length=100,
        blank=True,
        default="banner,native,html",
        help_text="Comma separated types",
    )
    allowed_sizes = models.CharField(
        max_length=100, blank=True, default="", help_text="e.g. 300x250,728x90"
    )
    context = models.CharField(
        max_length=100,
        blank=True,
        default="",
        help_text="Page context e.g. blog_detail, blog_list, homepage",
    )
    page_context = models.CharField(max_length=100, blank=True, default="")
    template_reference = models.CharField(max_length=255, blank=True, default="")
    is_enabled = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    locked = models.BooleanField(default=False, help_text="Lock to prevent auto changes")

    class Meta:
        ordering = ["name"]

    def __str__(self) -> str:
        return self.name


class Campaign(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    name = models.CharField(max_length=150, unique=True)
    is_active = models.BooleanField(default=True)
    type = models.CharField(
        max_length=20,
        choices=[
            ("direct", "Direct"),
            ("affiliate", "Affiliate"),
            ("network", "Network"),
            ("house", "House"),
        ],
        default="direct",
    )
    ad_network = models.CharField(max_length=100, blank=True, default="")
    budget = models.DecimalField(max_digits=12, decimal_places=2, default=0)
    daily_cap = models.PositiveIntegerField(default=0, help_text="0 = unlimited")
    total_cap = models.PositiveIntegerField(default=0, help_text="0 = unlimited")
    priority = models.IntegerField(default=0, help_text="Higher wins ties")
    weight = models.PositiveIntegerField(default=1)
    start_at = models.DateTimeField(null=True, blank=True)
    end_at = models.DateTimeField(null=True, blank=True)
    targeting_rules = models.JSONField(default=dict, blank=True)
    locked = models.BooleanField(default=False)

    class Meta:
        ordering = ["name"]

    def __str__(self) -> str:
        return self.name

    def is_live(self) -> bool:
        if not self.is_active:
            return False
        now = timezone.now()
        if self.start_at and self.start_at > now:
            return False
        if self.end_at and self.end_at < now:
            return False
        return True


class AdCreative(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    CREATIVE_TYPES = [
        ("banner", "Banner"),
        ("native", "Native"),
        ("html", "HTML/JS"),
        ("script", "Script"),
    ]
    campaign = models.ForeignKey(
        Campaign, on_delete=models.CASCADE, related_name="creatives"
    )
    name = models.CharField(max_length=150)
    creative_type = models.CharField(max_length=20, choices=CREATIVE_TYPES)
    html = models.TextField(blank=True, default="")
    html_code = models.TextField(blank=True, default="")
    script_code = models.TextField(blank=True, default="")
    image_url = models.URLField(blank=True, default="")
    click_url = models.URLField(blank=True, default="")
    tracking_params = models.JSONField(default=dict, blank=True)
    weight = models.PositiveIntegerField(default=1)
    is_enabled = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    locked = models.BooleanField(default=False)

    class Meta:
        ordering = ["campaign", "name"]

    def __str__(self):
        return f"{self.campaign}: {self.name}"


class PlacementAssignment(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    placement = models.ForeignKey(
        AdPlacement, on_delete=models.CASCADE, related_name="assignments"
    )
    creative = models.ForeignKey(
        AdCreative, on_delete=models.CASCADE, related_name="assignments"
    )
    weight = models.PositiveIntegerField(default=1)
    is_enabled = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    locked = models.BooleanField(default=False)

    class Meta:
        unique_together = ("placement", "creative")

    def __str__(self):
        return f"{self.placement} -> {self.creative}"


class AffiliateSource(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    name = models.CharField(max_length=100, unique=True)
    network = models.CharField(max_length=100, blank=True, default="")
    base_url = models.URLField(blank=True, default="")
    is_enabled = models.BooleanField(default=True)
    locked = models.BooleanField(default=False)
    tracking_parameters = models.JSONField(default=dict, blank=True)
    metadata = models.JSONField(default=dict, blank=True)

    def __str__(self):
        return self.name


class AffiliateLink(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    source = models.ForeignKey(
        AffiliateSource, on_delete=models.CASCADE, related_name="links"
    )
    name = models.CharField(max_length=150)
    target_url = models.URLField(blank=True, default="")
    affiliate_url = models.URLField(blank=True, default="")
    slug = models.SlugField(max_length=180, blank=True, db_index=True)
    tags = models.ManyToManyField("tags.Tag", blank=True, related_name="affiliate_links")
    usage_count = models.PositiveIntegerField(default=0)
    last_used_at = models.DateTimeField(null=True, blank=True)
    url = models.URLField()
    is_enabled = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    locked = models.BooleanField(default=False)

    class Meta:
        unique_together = ("source", "name")

    def __str__(self):
        return f"{self.source} - {self.name}"


class AdEvent(TimestampedModel):
    EVENT_TYPES = [
        ("impression", "Impression"),
        ("click", "Click"),
    ]
    event_type = models.CharField(max_length=20, choices=EVENT_TYPES)
    placement = models.ForeignKey(
        AdPlacement, on_delete=models.SET_NULL, null=True, blank=True
    )
    creative = models.ForeignKey(
        AdCreative, on_delete=models.SET_NULL, null=True, blank=True
    )
    campaign = models.ForeignKey(
        Campaign, on_delete=models.SET_NULL, null=True, blank=True
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True
    )
    request_meta = models.JSONField(default=dict, blank=True)
    page_url = models.URLField(blank=True, default="")
    referrer_url = models.URLField(blank=True, default="")
    user_agent = models.TextField(blank=True, default="")
    session_id = models.CharField(max_length=128, blank=True, default="")
    site_domain = models.CharField(max_length=100, blank=True, default="")

    class Meta:
        indexes = [
            models.Index(fields=["event_type", "created_at"]),
            models.Index(fields=["campaign"]),
        ]

    def __str__(self):
        return f"{self.event_type} @ {self.created_at}"


--------------------------------------------
### FILE: apps\ads\services\__init__.py
### SIZE: 74 bytes
### HASH: 15FAEB9C40053F42BE6443EB795ECD82D06DA29E8E4D4A6332948A4B12103153

# Namespace for ads services (targeting, rotation, analytics, affiliates)


--------------------------------------------
### FILE: apps\ads\services\affiliates\resolver.py
### SIZE: 733 bytes
### HASH: 24B8F7A98BB2869716CC9F4F2834CEB8A64CEAF17FBB54672D7311DF974FEFD5

from __future__ import annotations

from typing import Optional

from apps.ads.models import AffiliateLink, AffiliateSource
from apps.site_settings.models import SiteSettings


def affiliate_enabled() -> bool:
    try:
        ss = SiteSettings.get_solo()
        return bool(getattr(ss, "affiliate_enabled", False))
    except Exception:
        return False


def resolve_link(name: str, source_name: str) -> Optional[str]:
    if not affiliate_enabled():
        return None
    source = AffiliateSource.objects.filter(name=source_name, is_enabled=True).first()
    if not source:
        return None
    link = AffiliateLink.objects.filter(source=source, name=name, is_enabled=True).first()
    return link.url if link else None


--------------------------------------------
### FILE: apps\ads\services\analytics\tracker.py
### SIZE: 1602 bytes
### HASH: 34CA772EFB6E93B508F32F57FA1250CC77C8E4E948FA65395C3A6F04E876CFB9

from __future__ import annotations

import logging
from typing import Optional, Dict, Any

from apps.ads.models import AdEvent, AdPlacement, AdCreative, Campaign
from apps.core.utils import feature_flags
from apps.core.utils.logging import log_event

logger = logging.getLogger(__name__)


def record_event(
    event_type: str,
    placement: Optional[AdPlacement] = None,
    creative: Optional[AdCreative] = None,
    campaign: Optional[Campaign] = None,
    user=None,
    request_meta: Optional[Dict[str, Any]] = None,
):
    if not feature_flags.ads_enabled():
        return

    try:
        payload = {
            "event_type": event_type,
            "placement": placement,
            "creative": creative,
            "campaign": campaign,
            "user": user,
            "request_meta": request_meta or {},
            "page_url": (request_meta or {}).get("page_url", ""),
            "referrer_url": (request_meta or {}).get("referrer", ""),
            "user_agent": (request_meta or {}).get("user_agent", ""),
            "session_id": (request_meta or {}).get("session_id", ""),
            "site_domain": (request_meta or {}).get("site", ""),
        }
        AdEvent.objects.create(**payload)
        log_event(
            logger,
            "info",
            "ads.event.recorded",
            event_type=event_type,
            placement=getattr(placement, "slug", None),
            creative=getattr(creative, "id", None),
            campaign=getattr(campaign, "id", None),
        )
    except Exception:
        logger.warning("record_event failed", exc_info=True)


--------------------------------------------
### FILE: apps\ads\services\rotation\engine.py
### SIZE: 1806 bytes
### HASH: C1EC56A3F558C8A08A895D72812568F96D29E14C548A996BBA2ADC5F43FFB855

from __future__ import annotations

import random
from typing import Iterable, Optional

from apps.ads.models import PlacementAssignment, AdCreative, AdPlacement
from apps.site_settings.models import SiteSettings
from apps.core.utils import feature_flags
from apps.core.utils.logging import log_event
import logging

logger = logging.getLogger(__name__)


def _aggressiveness_multiplier() -> int:
    try:
        level = SiteSettings.get_solo().ad_aggressiveness_level
    except Exception:
        level = "balanced"
    if level == "minimal":
        return 1
    if level == "aggressive":
        return 3
    return 2


def choose_creative(placement: AdPlacement) -> Optional[AdCreative]:
    """
    Weighted random selection among enabled assignments for a placement.
    Aggressiveness controls how heavily weights are emphasized.
    """
    if not feature_flags.ads_enabled():
        return None
    qs: Iterable[PlacementAssignment] = placement.assignments.filter(
        is_enabled=True, is_active=True, creative__is_enabled=True, creative__is_active=True
    ).select_related("creative", "creative__campaign")
    pool = []
    mult = _aggressiveness_multiplier()
    for a in qs:
        creative = a.creative
        if creative.campaign and not creative.campaign.is_live() and not creative.campaign.locked:
            continue
        weight = max(1, a.weight * mult)
        pool.extend([creative] * weight)
    if not pool:
        log_event(logger, "warning", "ads.rotation.no_pool", placement=placement.slug)
        return None
    choice = random.choice(pool)
    log_event(
        logger,
        "info",
        "ads.rotation.selected",
        placement=placement.slug,
        creative=choice.id,
        campaign=getattr(choice.campaign, "id", None),
    )
    return choice


--------------------------------------------
### FILE: apps\ads\services\targeting\engine.py
### SIZE: 1042 bytes
### HASH: CD620A48AE521965DA8756AE039F206EDF265A4251FE6F39B85EB842B04F8E6A

from __future__ import annotations

from typing import Dict, Any

from apps.ads.models import AdPlacement, Campaign
from apps.core.utils import feature_flags
from apps.site_settings.models import SiteSettings


def is_ads_enabled() -> bool:
    return feature_flags.ads_enabled()


def campaign_allowed(campaign: Campaign, context: Dict[str, Any]) -> bool:
    if not campaign.is_live():
        return False
    if not feature_flags.ads_enabled():
        return False
    rules = campaign.targeting_rules or {}
    page_context = context.get("page_context")
    tags = set(context.get("tags") or [])
    allowed_pages = set(rules.get("page_types") or [])
    if allowed_pages and page_context and page_context not in allowed_pages:
        return False
    allowed_tags = set(rules.get("tags") or [])
    if allowed_tags and tags and not (allowed_tags & tags):
        return False
    return True


def placement_allowed(placement: AdPlacement) -> bool:
    return placement.is_enabled and placement.is_active and not placement.is_deleted


--------------------------------------------
### FILE: apps\ads\signals.py
### SIZE: 117 bytes
### HASH: 81C1A0DE5A1144A49BD34C17C00E5DB965E68C1AEA2BD0369CC2B2EED1BB2463

from __future__ import annotations

# Placeholder for future signal-based hooks (e.g., record events, enforce locks)


--------------------------------------------
### FILE: apps\ads\templatetags\ads_tags.py
### SIZE: 1998 bytes
### HASH: BB16F5E45DB9A0163C983EF88890E609343266AA8560BFA5F9A0A534B2D82F2E

from __future__ import annotations

from django import template
from django.utils.safestring import mark_safe
from django.template.loader import render_to_string

from apps.ads.models import AdPlacement
from apps.core.cache import cache
from apps.core.utils import feature_flags
from apps.site_settings.models import SiteSettings

register = template.Library()


def _ads_enabled() -> bool:
    try:
        ss = SiteSettings.get_solo()
        return bool(getattr(ss, "ads_enabled", False))
    except Exception:
        return False


@register.simple_tag(takes_context=True)
def render_ad_slot(context, slug: str, allowed_types: str = "", allowed_sizes: str = ""):
    """
    Render an ad slot placeholder. Uses placement config when ads are enabled.
    Respects site feature flags and consent (if present on request).
    """
    if not _ads_enabled() or not feature_flags.ads_enabled():
        return ""

    request = context.get("request")
    consent_flags = getattr(request, "consent_flags", None)
    if consent_flags is not None:
        try:
            if not getattr(consent_flags, "allow_ads", True):
                return ""
        except Exception:
            pass

    cache_key = f"ads_slot_{slug}"
    cached = cache.get(cache_key)
    if cached:
        return cached

    placement = AdPlacement.objects.filter(slug=slug, is_active=True, is_enabled=True, is_deleted=False).first()
    html = render_to_string(
        "ads/components/slot.html",
        {
            "placement": placement,
            "fallback_slug": slug,
            "allowed_types": allowed_types or getattr(placement, "allowed_types", ""),
            "allowed_sizes": allowed_sizes or getattr(placement, "allowed_sizes", ""),
        },
        request=context.get("request"),
    )
    safe_html = mark_safe(html)
    cache.set(cache_key, safe_html, 120)
    return safe_html


@register.filter
def get_item(d, key):
    try:
        return d.get(key)
    except Exception:
        return None


--------------------------------------------
### FILE: apps\ads\tests.py
### SIZE: 2466 bytes
### HASH: 2E729414499D65D0A3FEF85D0702D990F21957B3B4F563D4FBB6C92AFFAFF3A7

from __future__ import annotations

import os
import django
from django.test import Client, TestCase, override_settings
from django.urls import reverse

from apps.ads.models import AdPlacement, AdCreative, Campaign, PlacementAssignment
from apps.site_settings.models import SiteSettings

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "gsminfinity.settings")
os.environ.setdefault("DJANGO_SECRET_KEY", "test-secret")
django.setup()


@override_settings(ALLOWED_HOSTS=["testserver", "localhost"], ROOT_URLCONF="gsminfinity.urls", SECURE_SSL_REDIRECT=False)
class AdsApiTests(TestCase):
    def setUp(self) -> None:
        ss = SiteSettings.get_solo()
        ss.ads_enabled = True
        ss.save()
        self.client = Client()

    def test_fill_ad_disabled_returns_403(self):
        ss = SiteSettings.get_solo()
        ss.ads_enabled = False
        ss.save()
        url = reverse("ads:fill_ad")
        res = self.client.get(url, {"placement": "missing"})
        self.assertEqual(res.status_code, 403)

    def test_fill_ad_returns_creative(self):
        campaign = Campaign.objects.create(name="C1")
        placement = AdPlacement.objects.create(
            name="Top",
            slug="top",
            code="top",
            allowed_types="banner",
            allowed_sizes="300x250",
            page_context="blog_detail",
        )
        creative = AdCreative.objects.create(
            campaign=campaign,
            name="Banner",
            creative_type="banner",
            image_url="https://example.com/banner.png",
            click_url="https://example.com",
        )
        PlacementAssignment.objects.create(placement=placement, creative=creative)
        url = reverse("ads:fill_ad")
        res = self.client.get(url, {"placement": placement.slug})
        self.assertEqual(res.status_code, 200)
        payload = res.json()
        self.assertTrue(payload["ok"])
        self.assertEqual(payload["creative"]["creative"], creative.id)

    def test_click_requires_consent(self):
        placement = AdPlacement.objects.create(
            name="Top",
            slug="top",
            code="top",
            allowed_types="banner",
            allowed_sizes="300x250",
            page_context="blog_detail",
        )
        url = reverse("ads:record_click")
        res = self.client.post(url, {"placement": placement.slug})
        self.assertEqual(res.status_code, 200)
        self.assertIn("skipped", res.json())


--------------------------------------------
### FILE: apps\ads\urls.py
### SIZE: 485 bytes
### HASH: CBA799884C392175E48427F611F06C01875A744C041CDBE4F989A0BC3A244EC7

from django.urls import path
from . import views

app_name = "ads"

urlpatterns = [
    path("api/placements/", views.list_placements, name="list_placements"),
    path("api/events/", views.record_event, name="record_event"),
    path("api/fill/", views.fill_ad, name="fill_ad"),
    path("api/click/", views.record_click, name="record_click"),
    path("dashboard/", views.dashboard, name="dashboard"),
    path("dashboard/toggles/", views.toggle_settings, name="toggle_settings"),
]


--------------------------------------------
### FILE: apps\ads\views.py
### SIZE: 12728 bytes
### HASH: 7ACFA27158ACC71C933584299D8659D2A0B8BDCACE7D57C663675C771C5AF06B

from __future__ import annotations

import logging
from collections import defaultdict

from django.http import JsonResponse, HttpRequest, HttpResponse
from django.shortcuts import render, redirect
from django.views.decorators.http import require_GET, require_POST
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.decorators import user_passes_test

from apps.site_settings.models import SiteSettings
from apps.core.utils import feature_flags
from .models import AdPlacement, AdEvent, Campaign, AdCreative, PlacementAssignment
from apps.ads.services.rotation.engine import choose_creative
from apps.ads.services.analytics.tracker import record_event

logger = logging.getLogger(__name__)


def _ads_enabled() -> bool:
    return feature_flags.ads_enabled()


def _has_ads_consent(request: HttpRequest) -> bool:
    """
    Honor consent categories; track events only when ads consent granted.
    """
    try:
        cookie_ns = getattr(request, "cookie_consent", None)
        has_category = bool(getattr(cookie_ns, "ads", False)) if cookie_ns else False
        has_overall = bool(getattr(request, "has_cookie_consent", False))
        if not (has_category and has_overall):
            return False
        consent_flags = getattr(request, "consent_flags", None)
        if consent_flags is not None:
            return bool(getattr(consent_flags, "allow_ads", False))
        return True
    except Exception:
        return False


def _log(request: HttpRequest, message: str, **extra):
    cid = getattr(request, "correlation_id", None)
    payload = {"correlation_id": cid, **extra}
    logger.info(message, extra=payload)


@require_GET
def list_placements(request: HttpRequest) -> JsonResponse:
    if not _ads_enabled():
        return JsonResponse({"items": []})
    placements = AdPlacement.objects.filter(is_enabled=True, is_active=True, is_deleted=False)
    data = [
        {
            "name": p.name,
            "slug": p.slug,
            "code": p.code,
            "allowed_types": p.allowed_types,
            "allowed_sizes": p.allowed_sizes,
            "page_context": p.context or p.page_context,
            "template_reference": p.template_reference,
        }
        for p in placements
    ]
    return JsonResponse({"items": data})


@csrf_exempt
@require_POST
def record_event(request: HttpRequest) -> JsonResponse:
    if not _ads_enabled():
        return JsonResponse({"ok": False, "error": "ads_disabled"}, status=403)
    if not _has_ads_consent(request):
        return JsonResponse({"ok": True, "skipped": "no_consent"})
    event_type = request.POST.get("event_type") or ""
    placement_slug = request.POST.get("placement") or ""
    campaign_id = request.POST.get("campaign")
    page_url = request.POST.get("page_url", "")
    referrer = request.POST.get("referrer", "")
    user_agent = request.META.get("HTTP_USER_AGENT", "")
    if not placement_slug or event_type not in {"impression", "click"}:
        return JsonResponse({"ok": False, "error": "bad_payload"}, status=400)
    if page_url and not page_url.startswith(("http://", "https://")):
        return JsonResponse({"ok": False, "error": "bad_payload"}, status=400)
    try:
        placement = AdPlacement.objects.filter(slug=placement_slug).first()
        campaign = Campaign.objects.filter(pk=campaign_id).first() if campaign_id else None
        AdEvent.objects.create(
            event_type=event_type or "impression",
            placement=placement,
            campaign=campaign,
            request_meta={"ip": request.META.get("REMOTE_ADDR")},
            page_url=page_url,
            referrer_url=referrer,
            user_agent=user_agent,
        )
        _log(
            request,
            "ads_event_recorded",
            event_type=event_type,
            placement=placement_slug,
            campaign=str(campaign_id or ""),
            page_url=page_url,
        )
    except Exception:
        return JsonResponse({"ok": False}, status=400)
    return JsonResponse({"ok": True})


@require_GET
def fill_ad(request: HttpRequest) -> JsonResponse:
    """
    Returns a creative for a placement slug using rotation engine.
    """
    if not _ads_enabled():
        return JsonResponse({"ok": False, "error": "ads_disabled"}, status=403)
    if not _has_ads_consent(request):
        return JsonResponse({"ok": True, "skipped": "no_consent"})
    slug = request.GET.get("placement") or ""
    page_url = request.GET.get("page_url", "")
    if page_url and not page_url.startswith(("http://", "https://")):
        return JsonResponse({"ok": False, "error": "bad_payload"}, status=400)
    if not slug:
        return JsonResponse({"ok": False, "error": "missing_placement"}, status=400)
    placement = AdPlacement.objects.filter(slug=slug, is_enabled=True, is_active=True, is_deleted=False).first()
    if not placement:
        return JsonResponse({"ok": False, "error": "placement_not_found"}, status=404)
    creative: AdCreative | None = choose_creative(placement)
    if not creative:
        return JsonResponse({"ok": False, "error": "no_creative"}, status=404)
    _log(
        request,
        "ads_fill",
        placement=slug,
        creative=str(getattr(creative, "id", "")),
        campaign=str(getattr(creative, "campaign_id", "")),
        page_url=page_url,
    )
    payload = {
        "type": creative.creative_type,
        "html": creative.html,
        "image_url": creative.image_url,
        "click_url": creative.click_url,
        "campaign": creative.campaign_id,
        "placement": placement.slug,
        "creative": creative.id,
        "page_url": page_url,
    }
    if _has_ads_consent(request):
        record_event(
            "impression",
            placement=placement,
            creative=creative,
            campaign=creative.campaign,
            user=request.user if request.user.is_authenticated else None,
            request_meta={
                "ip": request.META.get("REMOTE_ADDR"),
                "referrer": request.META.get("HTTP_REFERER", ""),
                "user_agent": request.META.get("HTTP_USER_AGENT", ""),
                "page_url": request.GET.get("page_url", ""),
            },
        )
    else:
        logger.info("Ads impression skipped due to missing consent", extra={"placement": placement.slug})
    return JsonResponse({"ok": True, "creative": payload})


@require_POST
def record_click(request: HttpRequest) -> JsonResponse:
    if not _ads_enabled():
        return JsonResponse({"ok": False, "error": "ads_disabled"}, status=403)
    if not _has_ads_consent(request):
        return JsonResponse({"ok": True, "skipped": "no_consent"})
    creative_id = request.POST.get("creative")
    placement_slug = request.POST.get("placement") or ""
    if not creative_id or not placement_slug:
        return JsonResponse({"ok": False, "error": "bad_payload"}, status=400)
    page_url = request.POST.get("page_url", "")
    referrer = request.POST.get("referrer", "")
    user_agent = request.META.get("HTTP_USER_AGENT", "")
    if page_url and not page_url.startswith(("http://", "https://")):
        return JsonResponse({"ok": False, "error": "bad_payload"}, status=400)
    creative = AdCreative.objects.filter(pk=creative_id).first() if creative_id else None
    placement = AdPlacement.objects.filter(slug=placement_slug).first() if placement_slug else None
    record_event(
        "click",
        placement=placement,
        creative=creative,
        campaign=creative.campaign if creative else None,
        user=request.user if request.user.is_authenticated else None,
        request_meta={
            "ip": request.META.get("REMOTE_ADDR"),
            "referrer": referrer,
            "user_agent": user_agent,
            "page_url": page_url,
        },
    )
    return JsonResponse({"ok": True})


@user_passes_test(lambda u: u.is_staff or u.is_superuser or getattr(u, "has_role", lambda *r: False)("admin", "editor"))
def dashboard(request: HttpRequest) -> HttpResponse:
    # Basic CTR stats
    impressions = AdEvent.objects.filter(event_type="impression").count()
    clicks = AdEvent.objects.filter(event_type="click").count()
    ctr = (clicks / impressions * 100) if impressions else 0
    ss = SiteSettings.get_solo()
    placements = AdPlacement.objects.all()[:50]
    campaigns = Campaign.objects.all()[:50]
    creatives = AdCreative.objects.select_related("campaign")[:50]
    affiliate_sources = Campaign.objects.none()
    try:
        from apps.ads.models import AffiliateSource
        affiliate_sources = AffiliateSource.objects.all()[:10]
    except Exception:
        affiliate_sources = []
    # Fill stats per placement / creative
    placement_stats = {}
    creative_stats = {}
    for p in placements:
        imp = AdEvent.objects.filter(placement=p, event_type="impression").count()
        clk = AdEvent.objects.filter(placement=p, event_type="click").count()
        ctr_local = (clk / imp * 100) if imp else 0
        placement_stats[p.id] = {"impressions": imp, "clicks": clk, "ctr": round(ctr_local, 2)}
    for c in AdCreative.objects.all()[:50]:
        imp = AdEvent.objects.filter(creative=c, event_type="impression").count()
        clk = AdEvent.objects.filter(creative=c, event_type="click").count()
        ctr_local = (clk / imp * 100) if imp else 0
        creative_stats[c.id] = {"impressions": imp, "clicks": clk, "ctr": round(ctr_local, 2)}
    assignments = (
        PlacementAssignment.objects.filter(placement__in=placements, is_enabled=True)
        .select_related("placement", "creative", "creative__campaign")
    )
    placement_campaigns = defaultdict(list)
    for a in assignments:
        placement_campaigns[a.placement_id].append(
            {
                "creative": a.creative.name,
                "campaign": getattr(a.creative.campaign, "name", ""),
                "locked": a.locked,
                "weight": a.weight,
                "active": a.creative.is_enabled and a.creative.campaign.is_live() if a.creative.campaign else a.creative.is_enabled,
            }
        )
    return render(
        request,
        "ads/dashboard.html",
        {
            "placements": placements,
            "campaigns": campaigns,
            "ads_enabled": _ads_enabled(),
            "ad_networks_enabled": getattr(ss, "ad_networks_enabled", False),
            "affiliate_enabled": getattr(ss, "affiliate_enabled", False),
            "impressions": impressions,
            "clicks": clicks,
            "ctr": round(ctr, 2),
            "ad_aggressiveness_level": getattr(ss, "ad_aggressiveness_level", "balanced"),
            "placement_stats": placement_stats,
            "placement_campaigns": placement_campaigns,
            "affiliate_sources": affiliate_sources,
            "creative_stats": creative_stats,
            "creatives": creatives,
        },
    )


@csrf_exempt
@require_POST
def toggle_settings(request: HttpRequest) -> HttpResponse:
    ss = SiteSettings.get_solo()
    action = request.POST.get("action", "")
    placement_id = request.POST.get("placement")
    campaign_id = request.POST.get("campaign")

    if action in ("disable_placement", "enable_placement") and placement_id:
        placement = AdPlacement.objects.filter(pk=placement_id).first()
        if placement:
            placement.is_enabled = action == "enable_placement"
            placement.save(update_fields=["is_enabled"])
    elif action == "toggle_lock" and placement_id:
        placement = AdPlacement.objects.filter(pk=placement_id).first()
        if placement:
            placement.locked = not placement.locked
            placement.save(update_fields=["locked"])
    elif action in ("disable_campaign", "enable_campaign") and campaign_id:
        campaign = Campaign.objects.filter(pk=campaign_id).first()
        if campaign:
            campaign.is_active = action == "enable_campaign"
            campaign.save(update_fields=["is_active"])
    elif action == "toggle_campaign_lock" and campaign_id:
        campaign = Campaign.objects.filter(pk=campaign_id).first()
        if campaign:
            campaign.locked = not campaign.locked
            campaign.save(update_fields=["locked"])
    else:
        ss.ads_enabled = request.POST.get("ads_enabled") == "1"
        ss.ad_networks_enabled = request.POST.get("ad_networks_enabled") == "1"
        ss.affiliate_enabled = request.POST.get("affiliate_enabled") == "1"
        level = request.POST.get("ad_aggressiveness_level") or ss.ad_aggressiveness_level
        if level in ("minimal", "balanced", "aggressive"):
            ss.ad_aggressiveness_level = level
        ss.save()
    return redirect("ads:dashboard")


--------------------------------------------
### FILE: apps\blog\__init__.py
### SIZE: 16 bytes
### HASH: BC399080B060ABCA14BCD307E5F82287A20E72F1B4646BCEA310C054CB551881

# blog app init


--------------------------------------------
### FILE: apps\blog\admin.py
### SIZE: 653 bytes
### HASH: 8FA56822DE0D8C5A4B05A4EB4499AC2F5EB76024499611981BC305C224108D78

from django.contrib import admin

from .models import Category, Post


@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ("name", "slug")
    search_fields = ("name", "slug")
    prepopulated_fields = {"slug": ("name",)}


@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ("title", "author", "is_published", "published_at")
    list_filter = ("is_published", "category")
    search_fields = ("title", "summary", "body")
    prepopulated_fields = {"slug": ("title",)}
    autocomplete_fields = ("author", "category", "tags")
    raw_id_fields = ("author",)
    date_hierarchy = "published_at"


--------------------------------------------
### FILE: apps\blog\apps.py
### SIZE: 237 bytes
### HASH: 98A0D181E7E2629A74505094B2440F65409968B50CBEEE82F3020A201F863094

from django.apps import AppConfig


class BlogConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.blog"
    verbose_name = "Blog"

    def ready(self):
        from . import signals  # noqa: F401


--------------------------------------------
### FILE: apps\blog\forms.py
### SIZE: 899 bytes
### HASH: 90ABB8BBC438944EE5AEB5D118831F92240ACEA8BCBA98F777B7D589DC4091E7

from __future__ import annotations

from django import forms

from .models import Post


class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = [
            "title",
            "summary",
            "body",
            "category",
            "tags",
            "status",
            "publish_at",
            "featured",
            "seo_title",
            "seo_description",
            "canonical_url",
            "hero_image",
        ]
        widgets = {
            "body": forms.Textarea(attrs={"rows": 8, "class": "form-control"}),
            "summary": forms.Textarea(attrs={"rows": 3, "class": "form-control"}),
            "publish_at": forms.DateTimeInput(
                attrs={"type": "datetime-local", "class": "form-control"}
            ),
            "seo_description": forms.Textarea(attrs={"rows": 2, "class": "form-control"}),
        }


--------------------------------------------
### FILE: apps\blog\models.py
### SIZE: 5324 bytes
### HASH: 83E1581EB918C91C07B84645AD0A792F654A6C8A456F403C13DCC41DC78E261E

from __future__ import annotations

from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.text import slugify
from django.urls import reverse


class PostStatus(models.TextChoices):
    DRAFT = "draft", "Draft"
    SCHEDULED = "scheduled", "Scheduled"
    PUBLISHED = "published", "Published"
    ARCHIVED = "archived", "Archived"


class Category(models.Model):
    name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(max_length=120, unique=True, blank=True)

    class Meta:
        ordering = ["name"]
        verbose_name_plural = "Categories"

    def __str__(self) -> str:
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)[:120]
        super().save(*args, **kwargs)


class Post(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(max_length=240, unique=True, blank=True)
    summary = models.TextField(blank=True, default="")
    seo_title = models.CharField(max_length=240, blank=True, default="")
    seo_description = models.CharField(max_length=320, blank=True, default="")
    canonical_url = models.URLField(blank=True, default="")
    hero_image = models.URLField(blank=True, default="")
    body = models.TextField()
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="posts"
    )
    category = models.ForeignKey(
        Category, on_delete=models.SET_NULL, null=True, blank=True, related_name="posts"
    )
    tags = models.ManyToManyField("tags.Tag", blank=True, related_name="posts")
    status = models.CharField(
        max_length=20, choices=PostStatus.choices, default=PostStatus.DRAFT
    )
    publish_at = models.DateTimeField(null=True, blank=True)
    published_at = models.DateTimeField(null=True, blank=True)
    is_published = models.BooleanField(default=False)
    featured = models.BooleanField(default=False)
    reading_time = models.PositiveIntegerField(default=0, help_text="Minutes")
    version = models.PositiveIntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-published_at", "-created_at"]

    def __str__(self) -> str:
        return self.title

    def get_absolute_url(self) -> str:
        return reverse("blog:post_detail", kwargs={"slug": self.slug})

    @property
    def is_live(self) -> bool:
        if self.status == PostStatus.PUBLISHED:
            if self.publish_at:
                return self.publish_at <= timezone.now()
            return True
        if self.status == PostStatus.SCHEDULED and self.publish_at:
            return self.publish_at <= timezone.now()
        return False

    def save(self, *args, **kwargs):
        if not self.slug:
            base = slugify(self.title)[:230]
            candidate = base
            idx = 1
            while Post.objects.filter(slug=candidate).exclude(pk=self.pk).exists():
                candidate = f"{base}-{idx}"
                idx += 1
            self.slug = candidate
        # Normalize status + published timestamps
        if self.status == PostStatus.PUBLISHED:
            self.is_published = True
            if not self.published_at:
                self.published_at = timezone.now()
            if not self.publish_at:
                self.publish_at = self.published_at
        elif self.status == PostStatus.SCHEDULED:
            self.is_published = False
            if self.publish_at and self.publish_at <= timezone.now():
                self.is_published = True
                self.published_at = self.publish_at
        else:
            self.is_published = False

        # Derive SEO title/description fallbacks
        if not self.seo_title:
            self.seo_title = self.title[:240]
        if not self.seo_description and self.summary:
            self.seo_description = self.summary[:320]

        # Estimate reading time (200 wpm)
        words = len(self.body.split())
        self.reading_time = max(1, round(words / 200)) if words else 1

        super().save(*args, **kwargs)


class PostDraft(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="post_drafts")
    post = models.ForeignKey("blog.Post", null=True, blank=True, on_delete=models.CASCADE, related_name="drafts")
    data = models.JSONField(default=dict, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-updated_at"]

    def __str__(self) -> str:
        return f"Draft for {self.post or 'new post'} by {self.user}"


class PostRevision(models.Model):
    post = models.ForeignKey("blog.Post", on_delete=models.CASCADE, related_name="revisions")
    user = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET_NULL, related_name="post_revisions")
    snapshot = models.JSONField(default=dict, blank=True)
    created_at = models.DateTimeField(default=timezone.now)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Revision {self.created_at} for {self.post}"


--------------------------------------------
### FILE: apps\blog\signals.py
### SIZE: 1825 bytes
### HASH: EC90F9A8EB2CBD5A1EEB1A537FD54AC4D2F2DF89D0904BA3789F0E7699D47F9F

from __future__ import annotations

import logging

from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.contenttypes.models import ContentType

from apps.core.utils import feature_flags
from apps.seo.models import SEOModel, Metadata
from apps.seo.services.internal_linking.engine import refresh_linkable_entity
from .models import Post, PostStatus

logger = logging.getLogger(__name__)


def _sync_tag_usage(post: Post) -> None:
    try:
        tags = post.tags.all()
        for tag in tags:
            count = tag.posts.filter(status=PostStatus.PUBLISHED).count()
            if tag.usage_count != count:
                tag.usage_count = count
                tag.save(update_fields=["usage_count"])
    except Exception:
        logger.debug("Tag usage sync failed for post %s", post.pk)


def _ensure_post_seo(post: Post) -> None:
    if not feature_flags.seo_enabled():
        return
    try:
        ct = ContentType.objects.get_for_model(Post)
        seo_obj, _ = SEOModel.objects.get_or_create(content_type=ct, object_id=post.pk)
        meta, _ = Metadata.objects.get_or_create(seo=seo_obj)
        if not meta.meta_title:
            meta.meta_title = post.seo_title or post.title
        if not meta.meta_description:
            meta.meta_description = post.seo_description or post.summary[:320]
        meta.save()
        refresh_linkable_entity(
            post,
            title=post.title,
            url=post.get_absolute_url(),
            keywords=",".join(post.tags.values_list("name", flat=True)),
        )
    except Exception:
        logger.debug("SEO sync failed for post %s", post.pk)


@receiver(post_save, sender=Post)
def post_after_save(sender, instance: Post, **kwargs):
    _sync_tag_usage(instance)
    _ensure_post_seo(instance)


--------------------------------------------
### FILE: apps\blog\urls.py
### SIZE: 893 bytes
### HASH: 8E193E702A4B83EDDC042E08BD990FE3B11C6F179DFF38FA2D43BC4F5F5BE91D

from django.urls import path

from . import views

app_name = "blog"

urlpatterns = [
    path("", views.post_list, name="post_list"),
    path("create/", views.post_create, name="post_create"),
    path("api/posts/", views.api_posts, name="api_posts"),
    path("api/posts/<slug:slug>/related/", views.api_related, name="api_related"),
    path("api/autosave/", views.post_autosave, name="post_autosave"),
    path("api/preview/", views.post_preview, name="post_preview"),
    path("api/widgets/trending-tags/", views.widget_trending_tags, name="widget_trending_tags"),
    path("api/widgets/latest/", views.widget_latest_posts, name="widget_latest_posts"),
    path("api/widgets/top/", views.widget_top_posts, name="widget_top_posts"),
    path("api/widgets/bounty/", views.widget_bounty_posts, name="widget_bounty_posts"),
    path("<slug:slug>/", views.post_detail, name="post_detail"),
]


--------------------------------------------
### FILE: apps\blog\views.py
### SIZE: 14212 bytes
### HASH: 0D2F88D0CA20CC204775129E98989BD12E8A1E00C43B122D3E2F420B4329D2E8

from __future__ import annotations

from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.paginator import Paginator
from django.http import HttpRequest, HttpResponse, Http404, JsonResponse
from django.shortcuts import get_object_or_404, redirect, render
from django.views.decorators.http import require_http_methods, require_POST
from django.template.loader import render_to_string
from django.db.models import Q
from django.db import transaction
from django.utils import timezone
from django.contrib.contenttypes.models import ContentType

from apps.core.views import _get_site_settings_snapshot
from .forms import PostForm
from .models import Post, PostStatus, Category, PostDraft, PostRevision
from apps.tags.models import Tag
from apps.seo.models import SEOModel, Metadata
from apps.core.utils import feature_flags
from apps.users.models import CustomUser


def _sync_tag_usage(tags_qs):
    for tag in tags_qs:
        try:
            count = tag.posts.filter(status=PostStatus.PUBLISHED).count()
            if tag.usage_count != count:
                tag.usage_count = count
                tag.save(update_fields=["usage_count"])
        except Exception:
            continue


def _ensure_post_seo(post: Post, request: HttpRequest | None = None):
    """
    Ensure SEO metadata/linkable entry for a post when SEO is enabled.
    """
    if not feature_flags.seo_enabled():
        return
    try:
        ct = ContentType.objects.get_for_model(Post)
        seo_obj, _ = SEOModel.objects.get_or_create(content_type=ct, object_id=post.pk)
        meta, _ = Metadata.objects.get_or_create(seo=seo_obj)
        if not meta.meta_title:
            meta.meta_title = post.seo_title or post.title
        if not meta.meta_description:
            meta.meta_description = post.seo_description or post.summary[:320]
        if not meta.canonical_url and request:
            meta.canonical_url = request.build_absolute_uri()
        meta.save()
        # Register linkable entity for internal linking
        from apps.seo.services.internal_linking.engine import refresh_linkable_entity

        refresh_linkable_entity(
            post,
            title=post.title,
            url=post.get_absolute_url(),
            keywords=",".join(post.tags.values_list("name", flat=True)),
        )
    except Exception:
        # Defensive: SEO failures should not block blog rendering
        return


def post_list(request: HttpRequest) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()
    blog_enabled = settings_snapshot.get("enable_blog", True)
    if not blog_enabled and not (request.user.is_staff or request.user.is_superuser):
        raise Http404("Blog is disabled.")
    allow_user_posts = settings_snapshot.get("allow_user_blog_posts", False)
    allow_user_bounties = settings_snapshot.get("allow_user_bounty_posts", False)

    now_ts = timezone.now()
    posts = Post.objects.filter(
        status=PostStatus.PUBLISHED, publish_at__lte=now_ts
    ).select_related("author", "category")
    q = request.GET.get("q", "").strip()
    tag = request.GET.get("tag", "").strip()
    category_slug = request.GET.get("category", "").strip()
    author = request.GET.get("author", "").strip()

    if q:
        posts = posts.filter(Q(title__icontains=q) | Q(body__icontains=q) | Q(summary__icontains=q))
    if tag:
        posts = posts.filter(tags__slug=tag)
    if category_slug:
        posts = posts.filter(category__slug=category_slug)
    if author:
        posts = posts.filter(author__username=author)

    posts = posts.prefetch_related("tags")
    paginator = Paginator(posts, 10)
    page_obj = paginator.get_page(request.GET.get("page") or 1)
    # Precompute display strings to keep templates simple and avoid filter gymnastics.
    for p in page_obj:
        published = p.published_at.strftime("%b %d, %Y") if p.published_at else "Draft"
        p.meta_text = f"By {p.author} · {published}"

    trending_tags = Tag.objects.order_by("-usage_count")[:10]
    trending_posts = list(
        Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=now_ts)
        .select_related("author")
        .order_by("-featured", "-published_at")[:5]
    )
    if not trending_posts:
        trending_posts = list(
            Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=now_ts)
            .select_related("author")
            .order_by("-published_at")[:5]
        )
    latest_posts = (
        Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=now_ts)
        .order_by("-published_at")[:5]
    )
    bounty_posts = (
        Post.objects.filter(
            status=PostStatus.PUBLISHED, publish_at__lte=now_ts, tags__slug="bounty"
        )
        .distinct()
        .order_by("-published_at")[:5]
    )

    context = {
        "posts": page_obj.object_list,
        "page_obj": page_obj,
        "q": q,
        "trending_tags": trending_tags,
        "trending_posts": trending_posts,
        "latest_posts": latest_posts,
        "bounty_posts": bounty_posts,
        "allow_user_posts": allow_user_posts,
    }
    return render(request, "blog/post_list.html", context)


def post_detail(request: HttpRequest, slug: str) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()
    blog_enabled = settings_snapshot.get("enable_blog", True)
    if not blog_enabled and not (request.user.is_staff or request.user.is_superuser):
        raise Http404("Blog is disabled.")
    allow_user_posts = settings_snapshot.get("allow_user_blog_posts", False)
    allow_user_bounties = settings_snapshot.get("allow_user_bounty_posts", False)

    post = get_object_or_404(
        Post.objects.select_related("author", "category").prefetch_related("tags"),
        slug=slug,
    )
    if not post.is_live and not (request.user.is_staff or request.user == post.author):
        raise Http404("Post not published.")
    related = Post.objects.filter(
        tags__in=post.tags.all(),
        status=PostStatus.PUBLISHED,
        publish_at__lte=timezone.now(),
    ).exclude(pk=post.pk).distinct().order_by("-published_at")[:4]
    related_widget_html = render_to_string(
        "blog/partials/related_widget.html", {"posts": related}
    )
    trending_tags = Tag.objects.order_by("-usage_count")[:10]
    trending_posts = list(
        Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=timezone.now())
        .select_related("author")
        .order_by("-featured", "-published_at")[:5]
    )
    if not trending_posts:
        trending_posts = list(
            Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=timezone.now())
            .select_related("author")
            .order_by("-published_at")[:5]
        )
    bounty_posts = (
        Post.objects.filter(
            status=PostStatus.PUBLISHED, publish_at__lte=timezone.now(), tags__slug="bounty"
        )
        .distinct()
        .order_by("-published_at")[:5]
    )
    _ensure_post_seo(post, request)

    return render(
        request,
        "blog/post_detail.html",
        {
            "post": post,
            "related_widget_html": related_widget_html,
            "trending_tags": trending_tags,
            "trending_posts": trending_posts,
            "bounty_posts": bounty_posts,
            "allow_user_posts": allow_user_posts,
        },
    )


@login_required
@require_http_methods(["GET", "POST"])
def post_create(request: HttpRequest) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()
    blog_enabled = settings_snapshot.get("enable_blog", True)
    if not blog_enabled and not (request.user.is_staff or request.user.is_superuser):
        raise Http404("Blog is disabled.")

    allow_user_posts = settings_snapshot.get("allow_user_blog_posts", False)
    # RBAC: allow staff, editors, authors; optionally allow authenticated users if toggle enabled.
    allowed = (
        request.user.is_staff
        or request.user.is_superuser
        or getattr(request.user, "has_role", lambda *r: False)(
            CustomUser.Roles.EDITOR, CustomUser.Roles.AUTHOR
        )
    )
    if not allowed and not (allow_user_posts and request.user.is_authenticated):
        raise Http404()

    if request.method == "POST":
        form = PostForm(request.POST)
        if form.is_valid():
            # Community bounty guardrails
            if not allow_user_bounties and not allowed:
                tags_qs = form.cleaned_data.get("tags")
                try:
                    if tags_qs and tags_qs.filter(slug="bounty").exists():
                        form.add_error(
                            "tags",
                            "Bounty posts are restricted by admin settings.",
                        )
                        return render(request, "blog/post_form.html", {"form": form})
                except Exception:
                    pass
            post = form.save(commit=False)
            post.author = request.user
            with transaction.atomic():
                post.save()
                form.save_m2m()
                _sync_tag_usage(post.tags.all())
                _ensure_post_seo(post, request)
                PostRevision.objects.create(
                    post=post,
                    user=request.user,
                    snapshot={
                        "title": post.title,
                        "summary": post.summary,
                        "body": post.body,
                        "tags": list(post.tags.values_list("slug", flat=True)),
                        "status": post.status,
                    },
                )
            messages.success(request, "Post saved.")
            return redirect("blog:post_detail", slug=post.slug)
    else:
        form = PostForm()
    return render(request, "blog/post_form.html", {"form": form})


def api_posts(request: HttpRequest) -> JsonResponse:
    """
    Lightweight JSON listing for widgets/search.
    """
    posts = Post.objects.filter(
        status=PostStatus.PUBLISHED, publish_at__lte=timezone.now()
    )
    q = request.GET.get("q", "").strip()
    if q:
        posts = posts.filter(Q(title__icontains=q) | Q(summary__icontains=q))
    posts = posts.select_related("author").order_by("-published_at")[:20]
    items = [
        {
            "title": p.title,
            "slug": p.slug,
            "author": str(p.author),
            "published_at": p.published_at.isoformat() if p.published_at else None,
        }
        for p in posts
    ]
    return JsonResponse({"items": items})


def api_related(request: HttpRequest, slug: str) -> JsonResponse:
    post = get_object_or_404(Post, slug=slug, status=PostStatus.PUBLISHED, publish_at__lte=timezone.now())
    related = (
        Post.objects.filter(tags__in=post.tags.all(), status=PostStatus.PUBLISHED, publish_at__lte=timezone.now())
        .exclude(pk=post.pk)
        .distinct()
        .order_by("-published_at")[:5]
    )
    items = [{"title": p.title, "slug": p.slug} for p in related]
    return JsonResponse({"items": items})


@login_required
@require_POST
def post_autosave(request: HttpRequest) -> JsonResponse:
    """
    Autosave stub for editor. Uses cache to persist the last payload per-user for 10 minutes.
    """
    post_id = request.POST.get("post_id")
    data = {
        "title": request.POST.get("title", ""),
        "summary": request.POST.get("summary", ""),
        "body": request.POST.get("body", ""),
        "tags": request.POST.getlist("tags"),
        "updated_at": timezone.now().isoformat(),
    }
    draft, _ = PostDraft.objects.update_or_create(
        user=request.user,
        post_id=post_id or None,
        defaults={"data": data},
    )
    return JsonResponse({"ok": True, "message": "Autosave stored", "draft_id": draft.id, "data": data})


@login_required
@require_POST
def post_preview(request: HttpRequest) -> JsonResponse:
    """
    Preview stub: echoes body/summary; replace with markdown rendering as needed.
    """
    body = request.POST.get("body", "")
    summary = request.POST.get("summary", "")
    rendered_body = body
    try:
        import markdown

        rendered_body = markdown.markdown(body, extensions=["fenced_code", "tables"])
    except Exception:
        pass
    return JsonResponse({"ok": True, "body": rendered_body, "summary": summary})


def widget_trending_tags(request: HttpRequest) -> JsonResponse:
    tags = Tag.objects.order_by("-usage_count", "name")[:10]
    items = [{"name": t.name, "slug": t.slug, "usage_count": t.usage_count} for t in tags]
    return JsonResponse({"items": items})


def widget_latest_posts(request: HttpRequest) -> JsonResponse:
    posts = (
        Post.objects.filter(status=PostStatus.PUBLISHED)
        .select_related("author")
        .order_by("-published_at")[:5]
    )
    items = [
        {
            "title": p.title,
            "slug": p.slug,
            "published_at": p.published_at.isoformat() if p.published_at else None,
        }
        for p in posts
    ]
    return JsonResponse({"items": items})


def widget_top_posts(request: HttpRequest) -> JsonResponse:
    posts = (
        Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=timezone.now())
        .select_related("author")
        .order_by("-published_at")[:5]
    )
    items = [
        {
            "title": p.title,
            "slug": p.slug,
            "published_at": p.published_at.isoformat() if p.published_at else None,
        }
        for p in posts
    ]
    return JsonResponse({"items": items})


def widget_bounty_posts(request: HttpRequest) -> JsonResponse:
    posts = (
        Post.objects.filter(
            status=PostStatus.PUBLISHED,
            publish_at__lte=timezone.now(),
            tags__slug="bounty",
        )
        .select_related("author")
        .distinct()
        .order_by("-published_at")[:5]
    )
    items = [
        {
            "title": p.title,
            "slug": p.slug,
            "published_at": p.published_at.isoformat() if p.published_at else None,
        }
        for p in posts
    ]
    return JsonResponse({"items": items})


--------------------------------------------
### FILE: apps\comments\__init__.py
### SIZE: 20 bytes
### HASH: E17757CB2D8DB4E4E532128172567FE2B70C7C37314BD7836EACFB8A2F60C8D3

# comments app init


--------------------------------------------
### FILE: apps\comments\admin.py
### SIZE: 1115 bytes
### HASH: B8A2F7B4AE46614418E309B8927F0CEE1650239C798F4C1A8E6D6C9A8CE61B53

from django.contrib import admin

from .models import Comment


@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ("post", "user", "status", "toxicity_score", "is_deleted", "created_at")
    list_filter = ("status", "is_deleted", "created_at")
    search_fields = ("body", "user__email", "post__title")
    raw_id_fields = ("post", "user")
    actions = ("mark_approved", "mark_rejected", "mark_spam", "soft_delete")

    @admin.action(description="Mark selected comments approved")
    def mark_approved(self, request, queryset):
        queryset.update(status="approved", is_approved=True)

    @admin.action(description="Mark selected comments rejected")
    def mark_rejected(self, request, queryset):
        queryset.update(status="rejected", is_approved=False)

    @admin.action(description="Mark selected comments spam")
    def mark_spam(self, request, queryset):
        queryset.update(status="spam", is_approved=False)

    @admin.action(description="Soft delete selected comments")
    def soft_delete(self, request, queryset):
        queryset.update(is_deleted=True)


--------------------------------------------
### FILE: apps\comments\apps.py
### SIZE: 183 bytes
### HASH: F813082AA1033CE88C2E974E846A71C0F47B07643613832F4F35F27E8BC38F88

from django.apps import AppConfig


class CommentsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.comments"
    verbose_name = "Comments"


--------------------------------------------
### FILE: apps\comments\models.py
### SIZE: 1609 bytes
### HASH: FE0756A9270710E9A3D75859F80909CD77CF42663DCF8C15DC1D07F5914B6DCC

from __future__ import annotations

from django.conf import settings
from django.db import models
from django.utils import timezone
from apps.core.models import TimestampedModel, SoftDeleteModel


class Comment(TimestampedModel, SoftDeleteModel):
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        APPROVED = "approved", "Approved"
        REJECTED = "rejected", "Rejected"
        SPAM = "spam", "Spam"

    post = models.ForeignKey(
        "blog.Post",
        on_delete=models.CASCADE,
        related_name="comments",
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="comments",
    )
    body = models.TextField()
    parent = models.ForeignKey(
        "self",
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="children",
    )
    status = models.CharField(
        max_length=20, choices=Status.choices, default=Status.PENDING, db_index=True
    )
    is_approved = models.BooleanField(default=True)
    score = models.IntegerField(default=0)
    metadata = models.JSONField(default=dict, blank=True)
    moderation_flags = models.JSONField(default=dict, blank=True)
    toxicity_score = models.FloatField(default=0.0)
    edited_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(default=timezone.now)
    is_deleted = models.BooleanField(default=False, db_index=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Comment by {self.user} on {self.post}"


--------------------------------------------
### FILE: apps\comments\tests.py
### SIZE: 3381 bytes
### HASH: 1A50237641946B7291766E4800F344CCE11012D60F149B747072CA44F67B1572

from __future__ import annotations

from unittest.mock import patch
import os
import django

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "gsminfinity.settings")
os.environ.setdefault("DJANGO_SECRET_KEY", "test-secret")
django.setup()

from django.contrib.auth import get_user_model
from django.test import Client, TestCase, override_settings
from django.urls import reverse
from django.utils import timezone

from apps.blog.models import Post, PostStatus
from apps.site_settings.models import SiteSettings
from .models import Comment

User = get_user_model()


@override_settings(ALLOWED_HOSTS=["testserver", "localhost"], ROOT_URLCONF="gsminfinity.urls", SECURE_SSL_REDIRECT=False)
class CommentModerationTests(TestCase):
    def setUp(self) -> None:
        ss = SiteSettings.get_solo()
        ss.enable_blog = True
        ss.enable_blog_comments = True
        ss.save()
        self.user = User.objects.create_user(email="u@example.com", password="pass")
        self.client = Client()
        self.client.force_login(self.user)
        self.post = Post.objects.create(
            title="Hello",
            body="Body",
            author=self.user,
            status=PostStatus.PUBLISHED,
            publish_at=timezone.now(),
        )

    @patch("apps.comments.views.ai_client.moderate_text")
    def test_add_comment_marks_spam_on_high_toxicity(self, mock_moderate):
        mock_moderate.return_value = {"label": "high", "toxicity_score": 0.9}
        url = reverse("comments:add_comment_json", kwargs={"slug": self.post.slug})
        res = self.client.post(url, {"body": "bad words"})
        self.assertEqual(res.status_code, 200)
        payload = res.json()
        self.assertEqual(payload["status"], Comment.Status.SPAM)
        comment = Comment.objects.get(pk=payload["id"])
        self.assertEqual(comment.status, Comment.Status.SPAM)
        self.assertFalse(comment.is_approved)

    def test_list_comments_excludes_non_approved(self):
        approved = Comment.objects.create(
            post=self.post,
            user=self.user,
            body="ok",
            status=Comment.Status.APPROVED,
            is_approved=True,
        )
        Comment.objects.create(
            post=self.post,
            user=self.user,
            body="nope",
            status=Comment.Status.SPAM,
            is_approved=False,
        )
        url = reverse("comments:list_comments", kwargs={"slug": self.post.slug})
        res = self.client.get(url)
        self.assertEqual(res.status_code, 200)
        ids = [c["id"] for c in res.json()["items"]]
        self.assertIn(approved.id, ids)
        self.assertEqual(len(ids), 1)

    def test_moderation_actions(self):
        staff = User.objects.create_user(email="staff@example.com", password="pass", is_staff=True)
        self.client.force_login(staff)
        comment = Comment.objects.create(
            post=self.post,
            user=self.user,
            body="pending",
            status=Comment.Status.PENDING,
            is_approved=False,
        )
        url = reverse("comments:moderation_action")
        res = self.client.post(url, {"comment_id": comment.id, "action": "approve"})
        self.assertEqual(res.status_code, 302)
        comment.refresh_from_db()
        self.assertEqual(comment.status, Comment.Status.APPROVED)
        self.assertTrue(comment.is_approved)


--------------------------------------------
### FILE: apps\comments\urls.py
### SIZE: 562 bytes
### HASH: 3925031A3240B82CDF236E077411E3400AE23453EA8D8D202C9DFE7242A30A3E

from django.urls import path

from . import views

app_name = "comments"

urlpatterns = [
    path("<slug:slug>/add/", views.add_comment, name="add_comment"),
    path("<slug:slug>/add.json", views.add_comment_json, name="add_comment_json"),
    path("<slug:slug>/list.json", views.list_comments, name="list_comments"),
    path("upvote/<int:comment_id>/", views.upvote_comment, name="upvote_comment"),
    path("moderation/", views.moderation_queue, name="moderation_queue"),
    path("moderation/action/", views.moderation_action, name="moderation_action"),
]


--------------------------------------------
### FILE: apps\comments\views.py
### SIZE: 8680 bytes
### HASH: 79563568031C4407E5222928E536651735954E33946BE844CFD5187030CE832E

from __future__ import annotations

from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.http import (
    HttpRequest,
    HttpResponse,
    HttpResponseBadRequest,
    JsonResponse,
)
from django.shortcuts import get_object_or_404, redirect
from django.views.decorators.http import require_GET, require_POST
from django.utils import timezone
from django.core.cache import cache
from django.db.models import F
from django.contrib.admin.views.decorators import staff_member_required

from apps.blog.models import Post
from apps.core.views import _get_site_settings_snapshot
from .models import Comment
from apps.core import ai_client
from apps.core.utils import feature_flags


@login_required
@require_POST
def add_comment(request: HttpRequest, slug: str) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()
    if not settings_snapshot.get("enable_blog") or not settings_snapshot.get(
        "enable_blog_comments"
    ):
        return HttpResponseBadRequest("Comments are disabled.")
    if not _has_comments_consent(request):
        return HttpResponseBadRequest("Consent required.")

    post = get_object_or_404(Post, slug=slug, is_published=True)
    body = (request.POST.get("body") or "").strip()
    if not body:
        return HttpResponseBadRequest("Comment body required.")
    if not _check_comment_rate_limit(request):
        return HttpResponseBadRequest("Too many comments, slow down.")
    Comment.objects.create(
        post=post,
        user=request.user,
        body=body,
        status=Comment.Status.APPROVED,
        is_approved=True,
    )
    return redirect("blog:post_detail", slug=slug)


@require_GET
def list_comments(request: HttpRequest, slug: str) -> JsonResponse:
    """
    JSON API for comments with pagination and sorting.
    """
    settings_snapshot = _get_site_settings_snapshot()
    if not settings_snapshot.get("enable_blog") or not settings_snapshot.get(
        "enable_blog_comments"
    ):
        return JsonResponse({"error": "comments_disabled"}, status=403)
    if not _has_comments_consent(request):
        return JsonResponse({"error": "consent_required"}, status=403)

    post = get_object_or_404(Post, slug=slug, is_published=True)
    sort = request.GET.get("sort", "new")
    qs = Comment.objects.filter(
        post=post,
        status=Comment.Status.APPROVED,
        is_deleted=False,
        parent__isnull=True,
    ).prefetch_related("children")
    if sort == "old":
        qs = qs.order_by("created_at")
    elif sort == "top":
        qs = qs.order_by("-score", "-created_at")
    else:
        qs = qs.order_by("-created_at")
    paginator = Paginator(qs, 10)
    page_number = request.GET.get("page") or 1
    page_obj = paginator.get_page(page_number)
    def serialize(comment):
        children = [
            serialize(child)
            for child in comment.children.all()
            if child.status == Comment.Status.APPROVED and not child.is_deleted
        ]
        return {
            "id": comment.id,
            "user": str(comment.user),
            "body": comment.body,
            "created_at": comment.created_at.isoformat(),
            "score": comment.score,
            "children": children,
            "metadata": comment.metadata or {},
            "status": comment.status,
        }

    payload = [serialize(c) for c in page_obj]
    return JsonResponse(
        {
            "items": payload,
            "page": page_obj.number,
            "pages": paginator.num_pages,
            "total": paginator.count,
        }
    )


@login_required
@require_POST
def add_comment_json(request: HttpRequest, slug: str) -> JsonResponse:
    """
    JSON POST endpoint for async comment submission.
    """
    settings_snapshot = _get_site_settings_snapshot()
    if not settings_snapshot.get("enable_blog") or not settings_snapshot.get(
        "enable_blog_comments"
    ):
        return JsonResponse({"error": "Comments are disabled."}, status=400)
    if not _has_comments_consent(request):
        return JsonResponse({"error": "consent_required"}, status=403)
    if not _check_comment_rate_limit(request):
        return JsonResponse({"error": "rate_limited"}, status=429)
    post = get_object_or_404(Post, slug=slug, is_published=True)
    if not _has_comments_consent(request):
        return JsonResponse({"error": "consent_required"}, status=403)
    body = (request.POST.get("body") or "").strip()
    if not body:
        return JsonResponse({"error": "Comment body required."}, status=400)
    parent_id = request.POST.get("parent")
    parent = None
    if parent_id:
        parent = Comment.objects.filter(pk=parent_id, post=post).first()
    meta = {}
    status = Comment.Status.PENDING
    toxicity_score = 0.0
    try:
        moderation = ai_client.moderate_text(body, request.user)
        meta["moderation"] = moderation
        toxicity_score = float(moderation.get("toxicity_score", 0.0) or 0.0)
        label = str(moderation.get("label", "low")).lower()
        if label == "high" or toxicity_score >= 0.5:
            status = Comment.Status.SPAM
        else:
            status = Comment.Status.APPROVED
    except Exception:
        status = Comment.Status.APPROVED
    is_approved = status == Comment.Status.APPROVED

    comment = Comment.objects.create(
        post=post,
        user=request.user,
        body=body,
        parent=parent,
        created_at=timezone.now(),
        is_approved=is_approved,
        status=status,
        metadata=meta,
        moderation_flags=meta,
        toxicity_score=toxicity_score,
    )
    return JsonResponse(
        {
            "ok": True,
            "id": comment.id,
            "body": comment.body,
            "user": str(comment.user),
            "created_at": comment.created_at.isoformat(),
            "metadata": meta,
            "status": status,
            "message": "Submitted for review" if status != Comment.Status.APPROVED else "Posted",
        }
    )


@login_required
@require_POST
def upvote_comment(request: HttpRequest, comment_id: int) -> JsonResponse:
    if not _has_comments_consent(request):
        return JsonResponse({"error": "consent_required"}, status=403)
    if not _check_comment_rate_limit(request):
        return JsonResponse({"error": "rate_limited"}, status=429)
    comment = get_object_or_404(Comment, pk=comment_id)
    Comment.objects.filter(pk=comment.pk).update(score=F("score") + 1)
    comment.refresh_from_db()
    return JsonResponse({"ok": True, "score": comment.score})


def _check_comment_rate_limit(request: HttpRequest) -> bool:
    """
    Simple per-IP + user throttle to prevent abuse.
    """
    key_bits = []
    if getattr(request, "user", None) and request.user.is_authenticated:
        key_bits.append(f"user:{request.user.pk}")
    ip = request.META.get("REMOTE_ADDR", "anon")
    key_bits.append(f"ip:{ip}")
    key = "comments:rl:" + ":".join(key_bits)
    try:
        count = cache.get(key, 0)
        if count and int(count) >= 10:
            return False
        cache.set(key, int(count) + 1, timeout=60)
    except Exception:
        # fail open
        return True
    return True


def _has_comments_consent(request: HttpRequest) -> bool:
    consent = getattr(request, "consent_categories", {}) or {}
    if consent and not consent.get("functional", True):
        return False
    if "comments" in consent and not consent.get("comments", False):
        return False
    return True


@staff_member_required
def moderation_queue(request: HttpRequest) -> HttpResponse:
    pending = Comment.objects.filter(status=Comment.Status.PENDING, is_deleted=False).order_by("-created_at")[:50]
    recent = Comment.objects.filter(status__in=[Comment.Status.APPROVED, Comment.Status.REJECTED, Comment.Status.SPAM], is_deleted=False).order_by("-created_at")[:50]
    return render(request, "comments/moderation.html", {"pending": pending, "recent": recent})


@staff_member_required
@require_POST
def moderation_action(request: HttpRequest) -> HttpResponse:
    cid = request.POST.get("comment_id")
    action = request.POST.get("action")
    comment = get_object_or_404(Comment, pk=cid)
    if action == "approve":
        comment.status = Comment.Status.APPROVED
        comment.is_approved = True
    elif action == "reject":
        comment.status = Comment.Status.REJECTED
        comment.is_approved = False
    elif action == "spam":
        comment.status = Comment.Status.SPAM
        comment.is_approved = False
    comment.save(update_fields=["status", "is_approved"])
    return redirect("comments:moderation_queue")


--------------------------------------------
### FILE: apps\common\totp.py
### SIZE: 857 bytes
### HASH: E7DFF054F6B6CB4E744B70F16001820B2A886BB93B18D80347FBCD8B25D367F5

"""
Legacy TOTP helpers.

For new code, prefer apps.users.mfa.TOTPService. These functions
remain as thin wrappers for backward compatibility.
"""

from __future__ import annotations

from typing import Optional

from apps.users.mfa import TOTPService


def generate_totp(
    secret: str,
    for_time: Optional[int] = None,
    digits: int = 6,
    digest: str = "sha1",
    period: int = 30,
) -> str:
    return TOTPService.generate_current_code(
        secret=secret,
        period=period,
        digits=digits,
        at_time=for_time,
    )


def verify_totp(
    secret: str,
    token: str,
    window: int = 1,
    digits: int = 6,
    digest: str = "sha1",
    period: int = 30,
) -> bool:
    return TOTPService.verify(
        secret=secret,
        code=token,
        tolerance=window,
        period=period,
        digits=digits,
    )


--------------------------------------------
### FILE: apps\common\utils.py
### SIZE: 160 bytes
### HASH: 997918FFB6E684F7526BF9CABE00EB5787DFF606C5AC26A918669F66CAE5B04D

# apps/common/utils.py
import hashlib


def short_hash(value: str, length: int = 10):
    return hashlib.sha256(value.encode("utf-8")).hexdigest()[:length]

--------------------------------------------
### FILE: apps\consent\__init__.py
### SIZE: 889 bytes
### HASH: 6F9BACE649A07D2C0255153473413710F76AE68C852D43DF35E7D273E3F4E0DE

"""
apps.consent package initializer.
Fails fast on API import errors outside test/CI to avoid silent misconfiguration.
"""

from __future__ import annotations

import logging
import os

logger = logging.getLogger(__name__)


def __getattr__(name: str):
    if name in {"get_consent_status", "update_consent"}:
        try:
            from apps.consent.api.views import get_consent_status, update_consent

            return {
                "get_consent_status": get_consent_status,
                "update_consent": update_consent,
            }[name]
        except Exception as exc:  # pragma: no cover
            logger.critical("Consent API import failure: %s", exc, exc_info=True)
            if os.getenv("DJANGO_ENV") not in {"test", "ci", "development"}:
                raise
            return None
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


--------------------------------------------
### FILE: apps\consent\admin.py
### SIZE: 12263 bytes
### HASH: 5CF996F86CD54B7D05A68A1A5E807A74089D14A5AE3C66E3CE4BF2B7EEB9A8B3

"""
apps.consent.admin
Enterprise-grade, hardened GDPR/CCPA admin interface.
Django 5.2+ • Fully safe • No deprecated APIs • No queryset logic errors.
"""

from __future__ import annotations

import csv
import json
from typing import Iterable

from django.contrib import admin
from django.db import transaction
from django.db.models import QuerySet
from django.http import HttpResponse
from django.utils.encoding import smart_str
from django.utils.html import format_html, mark_safe

from .models import ConsentLog, ConsentPolicy, ConsentRecord


# =====================================================================
#  FILTERS — ENTERPRISE HARDENED
# =====================================================================
class RejectAllFilter(admin.SimpleListFilter):
    """
    Filter records where the user rejected ALL optional cookies.

    Hardening:
    - Does NOT evaluate whole QuerySet
    - Uses DB-side filtering where possible
    - Falls back to safe in-Python logic only when required
    - Never returns lists
    """

    title = "Reject All"
    parameter_name = "reject_all"

    def lookups(self, request, model_admin):
        return [("yes", "Rejected All"), ("no", "Accepted Some")]

    def queryset(self, request, queryset: QuerySet):
        val = self.value()
        if val not in ("yes", "no"):
            return queryset

        # Optimized: detect reject_all via JSON field
        # "reject_all" is a boolean key under accepted_categories
        try:
            if val == "yes":
                return queryset.filter(accepted_categories__reject_all=True)
            else:
                return queryset.exclude(accepted_categories__reject_all=True)
        except Exception:
            # fallback safety version — robust, but slower
            ids = []
            for obj in queryset.only("pk"):
                try:
                    if (val == "yes" and obj.is_reject_all()) or (
                        val == "no" and not obj.is_reject_all()
                    ):
                        ids.append(obj.pk)
                except Exception:
                    continue

            return queryset.filter(pk__in=ids)


class PolicyVersionFilter(admin.SimpleListFilter):
    """
    Filter by policy version (distinct versions only).
    """

    title = "Policy Version"
    parameter_name = "policy_version"

    def lookups(self, request, model_admin):
        versions = (
            ConsentPolicy.objects.order_by("-created_at")
            .values_list("version", flat=True)
            .distinct()
        )
        return [(v, v) for v in versions]

    def queryset(self, request, queryset: QuerySet):
        val = self.value()
        if val:
            return queryset.filter(policy_version=val)
        return queryset


# =====================================================================
#  CONSENT POLICY ADMIN
# =====================================================================
@admin.register(ConsentPolicy)
class ConsentPolicyAdmin(admin.ModelAdmin):
    """
    Manage versioned consent policies with atomic activation logic.
    """

    readonly_fields = (
        "categories_snapshot_pretty",
        "created_at",
        "updated_at",
    )

    list_display = (
        "version",
        "site_domain",
        "is_active",
        "preview_snapshot",
        "created_at",
        "updated_at",
    )

    list_filter = ("site_domain", "is_active", "created_at")
    search_fields = ("version", "site_domain")
    ordering = ("-created_at",)
    actions = ["activate_policy", "export_policy_json"]

    fieldsets = (
        (
            "Policy Versioning",
            {
                "fields": ("version", "site_domain", "is_active"),
            },
        ),
        (
            "Snapshot (read-only)",
            {
                "fields": ("categories_snapshot_pretty",),
            },
        ),
        (
            "Timestamps",
            {
                "fields": ("created_at", "updated_at"),
            },
        ),
    )

    # ---------------- JSON Pretty Printer ----------------
    @admin.display(description="Categories Snapshot")
    def categories_snapshot_pretty(self, obj):
        data = obj.categories_snapshot or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:12px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    @admin.display(description="Snapshot")
    def preview_snapshot(self, obj):
        snap = obj.categories_snapshot or {}
        return f"{len(snap)} categories"

    # ---------------- Admin Actions ----------------
    @admin.action(description="Activate selected policy (auto-deactivate siblings)")
    def activate_policy(self, request, queryset: QuerySet):
        if queryset.count() != 1:
            self.message_user(request, "❌ Select exactly ONE policy", level="error")
            return

        policy = queryset.first()

        with transaction.atomic():
            ConsentPolicy.objects.select_for_update().filter(
                site_domain=policy.site_domain
            ).exclude(pk=policy.pk).update(is_active=False)

            policy.is_active = True
            policy.save(update_fields=["is_active"])

        self.message_user(
            request,
            f"✅ Activated Policy v{policy.version} for '{policy.site_domain}'",
        )

    @admin.action(description="Export selected policies → JSON")
    def export_policy_json(self, request, queryset: QuerySet):
        response = HttpResponse(content_type="application/json; charset=utf-8")
        response["Content-Disposition"] = "attachment; filename=consent_policies.json"

        try:
            payload = [obj.to_payload() for obj in queryset]
        except Exception:
            payload = []

        response.write(json.dumps(payload, indent=2, ensure_ascii=False))
        return response


# =====================================================================
#  CONSENT RECORD ADMIN
# =====================================================================
@admin.register(ConsentRecord)
class ConsentRecordAdmin(admin.ModelAdmin):
    """
    Admin interface for user consent records.
    """

    readonly_fields = (
        "accepted_categories_pretty",
        "accepted_at",
        "updated_at",
    )

    list_display = (
        "user_display",
        "session_key",
        "policy_display",
        "site_domain",
        "is_reject_all_display",
        "accepted_summary_display",
        "updated_at",
    )

    list_filter = (
        PolicyVersionFilter,
        "site_domain",
        "updated_at",
        RejectAllFilter,
    )

    search_fields = (
        "user__email",
        "user__username",
        "session_key",
        "policy_version",
        "site_domain",
    )

    ordering = ("-updated_at",)
    actions = ["export_to_csv"]

    fieldsets = (
        ("User / Session", {"fields": ("user", "session_key", "site_domain")}),
        ("Policy Info", {"fields": ("policy", "policy_version")}),
        ("Accepted Categories", {"fields": ("accepted_categories_pretty",)}),
        ("Timestamps", {"fields": ("accepted_at", "updated_at")}),
    )

    # ---------------- JSON Pretty Printer ----------------
    @admin.display(description="Accepted Categories")
    def accepted_categories_pretty(self, obj):
        data = obj.accepted_categories or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:8px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    # ---------------- Display Helpers ----------------
    @admin.display(description="User")
    def user_display(self, obj):
        try:
            if obj.user:
                return obj.user.email or obj.user.username
        except Exception:
            pass
        return "Anonymous"

    @admin.display(description="Policy")
    def policy_display(self, obj):
        try:
            if obj.policy_version:
                return obj.policy_version
            if obj.policy:
                return obj.policy.version
        except Exception:
            pass
        return "—"

    @admin.display(boolean=True, description="Rejected All?")
    def is_reject_all_display(self, obj):
        try:
            return obj.is_reject_all()
        except Exception:
            return False

    @admin.display(description="Accepted Categories Summary")
    def accepted_summary_display(self, obj):
        try:
            return obj.audit_summary()
        except Exception:
            return "(Error)"

    # ---------------- CSV Export ----------------
    @admin.action(description="Export selected consent records → CSV")
    def export_to_csv(self, request, queryset: QuerySet):
        response = HttpResponse(content_type="text/csv; charset=utf-8")
        response["Content-Disposition"] = "attachment; filename=consent_records.csv"
        response.write("\ufeff")  # Excel-safe BOM

        writer = csv.writer(response)
        writer.writerow(
            [
                "User",
                "Session Key",
                "Policy Version",
                "Site Domain",
                "Accepted Categories",
                "Rejected All",
                "Accepted At",
                "Updated At",
            ]
        )

        recs: Iterable[ConsentRecord] = queryset.select_related("user", "policy")

        for rec in recs:
            writer.writerow(
                [
                    smart_str(rec.user.email if rec.user else "Anonymous"),
                    smart_str(rec.session_key or ""),
                    smart_str(rec.policy_version),
                    smart_str(rec.site_domain),
                    json.dumps(rec.accepted_categories or {}, ensure_ascii=False),
                    rec.is_reject_all(),
                    rec.accepted_at.isoformat() if rec.accepted_at else "",
                    rec.updated_at.isoformat() if rec.updated_at else "",
                ]
            )

        return response


# =====================================================================
#  CONSENT LOG ADMIN — READ-ONLY AUDIT TRAIL
# =====================================================================
@admin.register(ConsentLog)
class ConsentLogAdmin(admin.ModelAdmin):
    """
    Immutable forensic log entries.
    """

    readonly_fields = (
        "user",
        "ip_address",
        "user_agent",
        "policy_version",
        "site_domain",
        "timestamp",
        "accepted_categories_pretty",
    )

    list_display = (
        "user_display",
        "ip_address",
        "policy_version",
        "site_domain",
        "timestamp",
    )

    list_filter = ("site_domain", "timestamp")
    search_fields = ("user__email", "ip_address", "policy_version")
    ordering = ("-timestamp",)
    date_hierarchy = "timestamp"

    @admin.display(description="Accepted Categories")
    def accepted_categories_pretty(self, obj):
        data = obj.accepted_categories or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:8px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    @admin.display(description="User")
    def user_display(self, obj):
        try:
            if obj.user:
                return obj.user.email
        except Exception:
            pass
        return "Anonymous"

--------------------------------------------
### FILE: apps\consent\api.py
### SIZE: 1376 bytes
### HASH: 8B7D6D237944BBB548FE8514513E45B5E3099CBF7A49467021C6EC52FD3AC115

"""
apps.consent.api
================

Public, import-stable API surface for Consent JSON endpoints.

Purpose:
    • Re-export the JSON API views from apps.consent.api.views
    • Allow import paths such as:
          from apps.consent.api import get_consent_status, update_consent
    • Keep internal folder structure flexible without breaking imports
    • Guarantee ASGI/WSGI-safe imports with zero side effects
    • Avoid unexpected failures during Django boot

This file must remain minimal, deterministic, and should never contain
heavy imports, query execution, or template logic.
"""

from __future__ import annotations

__all__ = [
    "get_consent_status",
    "update_consent",
]

# ---------------------------------------------------------------------
# Import Re-exports (Safe)
# ---------------------------------------------------------------------

try:
    # Canonical JSON API implementations
    from .api.views import get_consent_status, update_consent

except Exception as exc:
    # Boot-safe fallback:
    # We intentionally DO NOT raise errors here because Django may import
    # this module during ASGI/WSGI initialization or migrations.
    # Exposing "None" keeps the import path intact without silent breakage.
    get_consent_status = None  # type: ignore
    update_consent = None  # type: ignore

--------------------------------------------
### FILE: apps\consent\api\__init__.py
### SIZE: 195 bytes
### HASH: BEAA64B0D097CBC2FE6804B35124C6E201D042D183F4EFF5B0D924FFDF1F2123

"""
Consent API package initializer.
Exports key view functions for easier importing.
"""

from __future__ import annotations

from .views import get_consent_status, update_consent  # noqa: F401


--------------------------------------------
### FILE: apps\consent\api\views.py
### SIZE: 7601 bytes
### HASH: ED40FC0F77C53FA9C4CE32B420A1A49137BE689BABB78419669D240B96C7B841

"""
apps.consent.views
==================
Enterprise-grade Consent API Endpoints.

✔ Django 5.2 / Python 3.12 compliant
✔ Strict JSON parsing + 1MB payload cap
✔ Canonical category sanitization aligned with banner + context processor
✔ Atomic, idempotent upserts
✔ Per-user cache coherence
✔ No hard-coded site names
✔ Fully ASGI/WSGI-safe
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict

from apps.consent.models import ConsentRecord
from apps.consent.utils import consent_cache_key, get_active_policy, resolve_site_domain
from django.contrib.auth.decorators import login_required
from django.core.cache import cache
from django.db import transaction
from django.http import HttpRequest, JsonResponse
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_GET, require_POST

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------
# Safety limits
# ---------------------------------------------------------------

_MAX_PAYLOAD_BYTES = 1_048_576  # 1MB limit to prevent abuse


# ---------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------


def _safe_json_parse(request: HttpRequest) -> Dict[str, Any]:
    """
    Safely parse JSON or form payloads.

    Returns {} on:
        - non-JSON payloads (fallback to form)
        - invalid body
        - non-object JSON
        - exceeding size cap
    Never raises.
    """
    ctype = (request.content_type or "").lower()

    # JSON payload
    if "application/json" in ctype:
        try:
            raw = request.body.decode("utf-8", errors="ignore")
            if len(raw) > _MAX_PAYLOAD_BYTES:
                raise ValueError("payload_too_large")

            parsed = json.loads(raw or "{}")
            return parsed if isinstance(parsed, dict) else {}

        except Exception as exc:
            logger.debug("JSON parse failed → %s", exc)
            return {}

    # Fallback: form data
    try:
        return request.POST.dict()
    except Exception:
        return {}


def _sanitize_categories(
    policy_snapshot: Dict[str, Any], user_data: Dict[str, Any]
) -> Dict[str, bool]:
    """
    Convert user categories → {slug: bool}, enforcing required categories as True.

    Snapshot schema:
      {
        slug: {
          "required": bool,
          "name": str,
          "checked": bool
        }
      }
    """
    result: Dict[str, bool] = {}

    try:
        for slug, meta in policy_snapshot.items():
            required = bool(meta.get("required", False))
            raw = user_data.get(slug)

            # User-provided value considered only if not required
            result[slug] = True if required else bool(raw)

    except Exception as exc:
        logger.debug("Category sanitization error → %s", exc)
        # Guaranteed minimum baseline
        return {"functional": True}

    return result


# ---------------------------------------------------------------
# GET /consent/status
# ---------------------------------------------------------------


@require_GET
def get_consent_status(request: HttpRequest) -> JsonResponse:
    """
    Retrieve active policy + categories snapshot for the current site.

    Response:
        {
          "ok": True/False,
          "version": str or null,
          "site_domain": str,
          "categories": dict
        }
    """
    try:
        site_domain = resolve_site_domain(request)
        _ = consent_cache_key(site_domain)

        policy = get_active_policy(site_domain)
        if not policy:
            logger.warning("No active policy for site=%s", site_domain)
            return JsonResponse(
                {"ok": False, "error": "no_active_policy"},
                status=404,
            )

        version = str(policy.get("version", "") or "")
        categories = policy.get("categories_snapshot") or {}

        return JsonResponse(
            {
                "ok": True,
                "version": version,
                "site_domain": site_domain,
                "categories": categories,
            },
            status=200,
        )

    except Exception as exc:
        logger.exception("get_consent_status failure → %s", exc)
        return JsonResponse({"ok": False, "error": "internal_error"}, status=500)


# ---------------------------------------------------------------
# POST /consent/update
# ---------------------------------------------------------------


@csrf_protect
@login_required
@require_POST
def update_consent(request: HttpRequest) -> JsonResponse:
    """
    Persist authenticated user consent for the active policy.

    Guarantees:
    - Strict JSON parsing
    - Required categories always True
    - Atomic update_or_create
    - Cache coherence (invalidate only user-related cache keys)
    - Zero silent failures
    """
    try:
        # 1) Parse user payload
        data = _safe_json_parse(request)
        if not data:
            return JsonResponse(
                {"ok": False, "error": "invalid_payload"},
                status=400,
            )

        # 2) Resolve site + policy
        site_domain = resolve_site_domain(request)
        _ = consent_cache_key(site_domain)

        policy = get_active_policy(site_domain)
        if not policy:
            return JsonResponse(
                {"ok": False, "error": "no_active_policy"},
                status=404,
            )

        snapshot = policy.get("categories_snapshot") or {}
        policy_version = str(policy.get("version", "") or "")

        # 3) Sanitize categories
        sanitized = _sanitize_categories(snapshot, data)

        # 4) Atomic DB write
        try:
            with transaction.atomic():
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy_version,
                    site_domain=site_domain,
                    defaults={"accepted_categories": sanitized},
                )
        except Exception as exc:
            logger.exception("DB error updating consent → %s", exc)
            return JsonResponse(
                {"ok": False, "error": "db_error"},
                status=500,
            )

        # 5) Cache coherence — scoped delete
        try:
            cache.delete(f"user_consent_{request.user.pk}_{site_domain}")
        except Exception:
            pass

        logger.info(
            "Consent updated: user=%s site=%s policy=%s",
            getattr(request.user, "email", request.user.pk),
            site_domain,
            policy_version,
        )

        return JsonResponse(
            {
                "ok": True,
                "version": policy_version,
                "site_domain": site_domain,
            },
            status=200,
        )

    # Malformed JSON or bad logic in input
    except ValueError as exc:
        logger.warning("update_consent bad request → %s", exc)
        return JsonResponse({"ok": False, "error": "bad_request"}, status=400)

    # True unexpected server failure
    except Exception as exc:
        logger.exception("update_consent unexpected failure → %s", exc)
        return JsonResponse({"ok": False, "error": "internal_error"}, status=500)


--------------------------------------------
### FILE: apps\consent\apps.py
### SIZE: 1284 bytes
### HASH: 081C2B5EDA87456EE57D37164768D843AAAA98BD2F464558EA72D013EC0D7BD7

# apps/consent/apps.py
"""
Consent App Configuration
--------------------------
Initializes the Consent Management subsystem.
Ensures signal registration and avoids double import duplication.
"""

import logging

from django.apps import AppConfig

log = logging.getLogger(__name__)


class ConsentConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.consent"
    label = "consent"
    verbose_name = "Consent Management"

    def ready(self):
        """
        App startup logic:
        ✅ Imports signals after Django app registry is ready
        ✅ Prevents double import issues under ASGI/WSGI reloads
        ✅ Provides safe logging for debugging startup issues
        """
        # Avoid running twice under autoreload (common in runserver)
        if getattr(self, "_consent_ready_ran", False):
            return
        self._consent_ready_ran = True

        try:
            import apps.consent.signals  # noqa: F401

            log.debug("Consent signals registered successfully.")
        except ImportError:
            log.info("No consent signals found (skipping registration).")
        except Exception as exc:
            log.warning(f"Error importing consent signals: {exc}")

--------------------------------------------
### FILE: apps\consent\context_processors.py
### SIZE: 5432 bytes
### HASH: D8770B99E5D4BC7AB0075C1D5A5D8DB11E5B1FD03776DFBB747CCF57C13C54CA

"""
apps.consent.context_processors
===============================

Injects consent state and metadata into all Django templates.

- Django 5.2+ / Python 3.12+
- Async-safe, thread-safe, side-effect free
- Compatible with canonical banner structure:
      {slug: {"checked": bool, "required": bool, "name": str}}
- Fully backward-compatible with older variables
"""

from __future__ import annotations

import logging
from typing import Any, Dict

from apps.consent.models import ConsentPolicy
from django.conf import settings
from django.http import HttpRequest
from django.utils.functional import SimpleLazyObject

logger = logging.getLogger(__name__)


def consent_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Canonical consent context for templates.

    Provides:
      - has_cookie_consent: bool
      - cookie_consent_categories: dict[str, bool]
      - consent_categories: dict[str, {checked, required, name}]
      - consent_version, consent_summary
      - active_consent_policy: lazy-loaded ConsentPolicy | None
      - consent_cookie_* settings

    Never raises — always returns safe defaults.
    """

    def _lazy_active_policy():
        """Lazy resolver for active ConsentPolicy (middleware-first)."""
        try:
            existing = getattr(request, "consent_policy", None)
            if existing is not None:
                return existing
            return ConsentPolicy.get_active()
        except Exception as exc:
            logger.warning("Consent context lazy policy failed: %s", exc)
            return None

    try:
        raw = getattr(request, "consent_categories", {}) or {}

        cookie_map: Dict[str, bool] = {}
        canonical: Dict[str, Dict[str, Any]] = {}

        # -----------------------------
        # Build canonical structured map
        # -----------------------------
        try:
            for slug, val in dict(raw).items():
                if isinstance(val, dict):
                    checked = bool(val.get("checked", val.get("accepted", False)))
                    required = bool(val.get("required", False))
                    name = val.get("name", slug)
                else:
                    checked = bool(val)
                    required = False
                    name = slug

                cookie_map[str(slug)] = checked
                canonical[str(slug)] = {
                    "checked": checked,
                    "required": required,
                    "name": name,
                }
        except Exception:
            # if any corruption or unexpected structure occurs
            cookie_map = {"functional": True}
            canonical = {
                "functional": {"checked": True, "required": True, "name": "functional"}
            }

        # ------------------------------------------------------------------
        # Guarantee presence of functional cookies — required by EU regulation
        # ------------------------------------------------------------------
        if "functional" not in canonical:
            canonical["functional"] = {
                "checked": True,
                "required": True,
                "name": "functional",
            }
            cookie_map.setdefault("functional", True)
        else:
            canonical["functional"]["required"] = True
            cookie_map.setdefault("functional", True)

        # ---------------------------
        # Construct final safe context
        # ---------------------------
        ctx: Dict[str, Any] = {
            "has_cookie_consent": bool(getattr(request, "has_cookie_consent", False)),
            "cookie_consent_categories": cookie_map,
            "consent_categories": canonical,  # canonical, banner-safe
            "consent_version": getattr(request, "consent_version", None),
            "consent_summary": dict(getattr(request, "consent_summary", {}) or {}),
            "active_consent_policy": SimpleLazyObject(_lazy_active_policy),
            "consent_cookie_name": getattr(
                settings, "CONSENT_COOKIE_NAME", "consent_status"
            ),
            "consent_cookie_secure": bool(
                getattr(
                    settings,
                    "CONSENT_COOKIE_SECURE",
                    not getattr(settings, "DEBUG", False),
                )
            ),
            "consent_cookie_samesite": getattr(
                settings, "CONSENT_COOKIE_SAMESITE", "Lax"
            ),
            "consent_cookie_max_age": int(
                getattr(settings, "CONSENT_COOKIE_MAX_AGE", 31536000)
            ),
        }

        return ctx

    except Exception as exc:
        logger.exception("Consent context processor failed: %s", exc)
        return {
            "has_cookie_consent": False,
            "cookie_consent_categories": {"functional": True},
            "consent_categories": {
                "functional": {"checked": True, "required": True, "name": "functional"}
            },
            "consent_version": None,
            "consent_summary": {},
            "active_consent_policy": None,
            "consent_cookie_name": "consent_status",
            "consent_cookie_secure": False,
            "consent_cookie_samesite": "Lax",
            "consent_cookie_max_age": 31536000,
        }

--------------------------------------------
### FILE: apps\consent\decorators.py
### SIZE: 4470 bytes
### HASH: EFD43AB0BAF74325714563EDE2D3CDA7DBA45729806E1833444F278214E2B5B3

# apps/consent/decorators.py
"""
Consent Decorators
------------------
Reusable decorators to enforce consent validation for
protected or analytics-sensitive endpoints.

Features:
- Sync & async view support (Django 4.2+)
- Works with middleware-injected cookie_consent namespace
- AJAX-friendly JSON response
- Graceful fallback when middleware missing
"""

import asyncio
import logging
from functools import wraps
from inspect import iscoroutinefunction

from django.http import HttpResponseForbidden, JsonResponse

log = logging.getLogger(__name__)


def require_consent(category: str = "analytics", ajax_friendly: bool = True):
    """
    Decorator to enforce cookie/data-usage consent before executing a view.

    Args:
        category (str): Consent category slug (e.g., "analytics", "ads", "functional").
        ajax_friendly (bool): If True, returns JSON 403 for AJAX requests.

    Behavior:
        ✅ Checks `request.cookie_consent` and `request.has_cookie_consent`
        ✅ Graceful fallback when middleware not initialized
        ✅ Works with both sync and async Django views
        ✅ Prevents accidental access without consent
    """

    def _deny_access(request, category: str):
        """Return a standardized 403 response."""
        msg = f"Consent required for category '{category}'."
        if ajax_friendly and (
            request.headers.get("x-requested-with") == "XMLHttpRequest"
            or (request.content_type or "").startswith("application/json")
        ):
            return JsonResponse(
                {"error": "consent_required", "category": category}, status=403
            )
        return HttpResponseForbidden(msg, content_type="text/plain; charset=utf-8")

    def decorator(view_func):
        if iscoroutinefunction(view_func):
            # ---------------- Async Path ----------------
            @wraps(view_func)
            async def _wrapped_async(request, *args, **kwargs):
                try:
                    cookie_ns = getattr(request, "cookie_consent", None)
                    has_category = (
                        bool(getattr(cookie_ns, category, False))
                        if cookie_ns
                        else False
                    )
                    has_overall = bool(getattr(request, "has_cookie_consent", False))

                    if not (has_category and has_overall):
                        log.info(
                            "Access blocked (async): user=%s ip=%s category=%s path=%s",
                            getattr(request.user, "email", "anon"),
                            request.META.get("REMOTE_ADDR", "unknown"),
                            category,
                            request.path,
                        )
                        return _deny_access(request, category)
                except Exception as exc:
                    log.warning(
                        "Consent validation failed (async) for %s → %s", category, exc
                    )
                    return HttpResponseForbidden("Consent validation error.")
                return await view_func(request, *args, **kwargs)

            return _wrapped_async

        # ---------------- Sync Path ----------------
        @wraps(view_func)
        def _wrapped(request, *args, **kwargs):
            try:
                cookie_ns = getattr(request, "cookie_consent", None)
                has_category = (
                    bool(getattr(cookie_ns, category, False)) if cookie_ns else False
                )
                has_overall = bool(getattr(request, "has_cookie_consent", False))

                if not (has_category and has_overall):
                    log.info(
                        "Access blocked: user=%s ip=%s category=%s path=%s",
                        getattr(request.user, "email", "anon"),
                        request.META.get("REMOTE_ADDR", "unknown"),
                        category,
                        request.path,
                    )
                    return _deny_access(request, category)
            except Exception as exc:
                log.warning("Consent validation failed for %s → %s", category, exc)
                return HttpResponseForbidden("Consent validation error.")
            return view_func(request, *args, **kwargs)

        return _wrapped

    return decorator

--------------------------------------------
### FILE: apps\consent\middleware.py
### SIZE: 12514 bytes
### HASH: DA7E1A37A45439727E6ED1C3E4133A45ED3F018504C019D8A1A47C3D666815C3

"""
apps.consent.middleware
=======================

Enterprise-grade cookie-consent middleware.

- Callable middleware (WSGI + ASGI safe)
- Uses canonical utils (serializable policy payloads only)
- Session guarantee for anonymous visitors (best-effort)
- Robust ConsentRecord loading for user or session
- Exposes request.consent_* attributes for templates/analytics
- Defensive: never raises even if DB or cache is down
"""

from __future__ import annotations

import json
import logging
from types import SimpleNamespace
from typing import Any, Dict, Optional, Set, Tuple

from apps.consent.models import ConsentRecord
from apps.consent.utils import consent_cache_key, get_active_policy, resolve_site_domain
from django.conf import settings
from django.http import HttpRequest, HttpResponse

logger = logging.getLogger(__name__)


# =====================================================================
#  MAIN MIDDLEWARE
# =====================================================================
class ConsentMiddleware:
    """
    Middleware that attaches consent information to each request.

    Add:
        "apps.consent.middleware.ConsentMiddleware"
    AFTER:
        AuthenticationMiddleware
        SessionMiddleware
    """

    def __init__(self, get_response):
        self.get_response = get_response

        # Avoid unsafe, brand-specific defaults — now generic
        self.cookie_name: str = getattr(
            settings, "CONSENT_COOKIE_NAME", "cookie_consent"
        )
        self.cookie_max_age: int = int(
            getattr(settings, "CONSENT_COOKIE_MAX_AGE", 60 * 60 * 24 * 365)
        )
        self.cookie_samesite: str = getattr(settings, "CONSENT_COOKIE_SAMESITE", "Lax")
        self.cookie_secure: bool = bool(
            getattr(settings, "CONSENT_COOKIE_SECURE", not settings.DEBUG)
        )

    # =================================================================
    #  WSGI + ASGI entrypoint
    # =================================================================
    def __call__(self, request: HttpRequest) -> HttpResponse:
        # Baseline request attributes — MUST be set before any early returns
        request.has_cookie_consent = False
        request.consent_policy = None
        request.consent_version = None
        request.consent_categories = {}
        request.cookie_consent = SimpleNamespace()
        request.consent_summary = {}

        # -------------------------------
        # Ensure session exists (safe)
        # -------------------------------
        try:
            self._ensure_session(request)
        except Exception as exc:
            logger.debug("ConsentMiddleware: session bootstrap failed -> %s", exc)

        # -------------------------------
        # Determine domain
        # -------------------------------
        try:
            site_domain = resolve_site_domain(request)
        except Exception as exc:
            logger.debug("ConsentMiddleware: resolve_site_domain failed -> %s", exc)
            site_domain = None

        if not site_domain:
            site_domain = getattr(settings, "DEFAULT_SITE_DOMAIN", "default")

        # -------------------------------
        # Validate that cache_key works
        # -------------------------------
        try:
            consent_cache_key(site_domain)
        except Exception:
            logger.debug("ConsentMiddleware: cache key generation failure (ignored)")

        # -------------------------------
        # Load policy payload
        # -------------------------------
        try:
            policy_payload = get_active_policy(site_domain)
        except Exception as exc:
            logger.debug("ConsentMiddleware: policy load failed -> %s", exc)
            policy_payload = None

        if policy_payload:
            request.consent_policy = policy_payload
            request.consent_version = policy_payload.get("version")

        # -------------------------------
        # Try retrieving stored record
        # -------------------------------
        consent_record = None
        if request.consent_version:
            try:
                consent_record = self._get_consent_record(
                    request, request.consent_version, site_domain
                )
            except Exception as exc:
                logger.debug("ConsentMiddleware: record lookup failed -> %s", exc)

        # -------------------------------
        # Build baseline categories
        # -------------------------------
        try:
            categories, required = self._build_baseline_categories(policy_payload)
        except Exception:
            logger.exception(
                "ConsentMiddleware: baseline categories build failed, using safe fallback"
            )
            categories, required = {"functional": True}, {"functional"}

        # -------------------------------
        # Apply stored consent OR defaults
        # -------------------------------
        try:
            if consent_record:
                categories, has_opt_in = self._apply_consent_record(
                    categories, required, consent_record
                )
                request.has_cookie_consent = has_opt_in
            else:
                # Anonymous fallback (required=True, optional=False)
                for slug in list(categories.keys()):
                    categories[slug] = bool(slug in required)
                request.has_cookie_consent = False
        except Exception:
            logger.exception("ConsentMiddleware: applying record failed; fallback")
            for slug in list(categories.keys()):
                categories[slug] = bool(slug in required)
            request.has_cookie_consent = False

        # -------------------------------
        # Hard enforce required categories
        # -------------------------------
        for slug in required:
            categories[slug] = True

        # -------------------------------
        # Attach attributes
        # -------------------------------
        request.consent_categories = categories
        try:
            request.cookie_consent = SimpleNamespace(**categories)
        except Exception:
            request.cookie_consent = SimpleNamespace()

        request.consent_summary = {
            "version": request.consent_version,
            "active": bool(policy_payload),
            "has_consent": request.has_cookie_consent,
            "required": sorted(list(required)),
            "site": site_domain,
        }

        logger.debug("ConsentMiddleware summary: %s", request.consent_summary)

        # =================================================================
        #  Downstream request
        # =================================================================
        response = self.get_response(request)

        # =================================================================
        #  Response hook (cookie writer)
        # =================================================================
        try:
            response = self.process_response(request, response)
        except Exception:
            logger.exception("ConsentMiddleware: response hook failed")

        return response

    # =====================================================================
    #  INTERNAL HELPERS
    # =====================================================================
    def _ensure_session(self, request: HttpRequest) -> None:
        """Ensure session exists for anonymous users."""
        session = getattr(request, "session", None)
        if not session:
            logger.warning("ConsentMiddleware: SessionMiddleware missing.")
            return

        try:
            if not session.session_key:
                session.create()
                session.modified = True
                logger.debug("ConsentMiddleware: new session created")
        except Exception as exc:
            logger.debug("ConsentMiddleware: session create failed -> %s", exc)

    # ---------------------------------------------------------------------
    def _get_consent_record(
        self, request: HttpRequest, policy_version: str, site_domain: str
    ) -> Optional[ConsentRecord]:
        """
        Retrieve ConsentRecord applying database-accurate filters.
        """
        user = getattr(request, "user", None)
        lookup = {"site_domain": site_domain, "policy_version": policy_version}

        try:
            if user and getattr(user, "is_authenticated", False):
                lookup["user"] = user
            else:
                lookup["user__isnull"] = True
                lookup["session_key"] = getattr(request.session, "session_key", None)

            return (
                ConsentRecord.objects.filter(**lookup)
                .order_by("-updated_at", "-created_at")
                .first()
            )
        except Exception as exc:
            logger.debug("ConsentMiddleware: ORM lookup failed -> %s", exc)
            return None

    # ---------------------------------------------------------------------
    def _build_baseline_categories(
        self, policy_payload: Optional[dict]
    ) -> Tuple[Dict[str, bool], Set[str]]:
        """Build baseline categories purely from the JSON snapshot."""
        categories: Dict[str, bool] = {}
        required: Set[str] = set()

        try:
            snap = (
                policy_payload.get("categories_snapshot", {}) if policy_payload else {}
            )
            if isinstance(snap, dict):
                for slug, data in snap.items():
                    slug = str(slug)
                    categories[slug] = False
                    if isinstance(data, dict) and data.get("required"):
                        required.add(slug)
        except Exception as exc:
            logger.debug("ConsentMiddleware: category parsing failed -> %s", exc)

        # Functional is always required
        categories.setdefault("functional", True)
        required.add("functional")

        return categories, required

    # ---------------------------------------------------------------------
    def _apply_consent_record(
        self, categories: Dict[str, bool], required: Set[str], record: ConsentRecord
    ) -> Tuple[Dict[str, bool], bool]:

        try:
            accepted = record.accepted_categories or {}
        except Exception:
            accepted = {}

        if accepted.get("reject_all"):
            for slug in list(categories.keys()):
                categories[slug] = slug in required
            return categories, False

        any_optional = False
        for slug in list(categories.keys()):
            if slug in required:
                categories[slug] = True
            else:
                categories[slug] = bool(accepted.get(slug))
                if categories[slug]:
                    any_optional = True

        return categories, any_optional

    # =====================================================================
    #  RESPONSE HOOK — cookie writer
    # =====================================================================
    def process_response(
        self, request: HttpRequest, response: HttpResponse
    ) -> HttpResponse:
        """Write cookie storing accepted categories — best effort."""
        try:
            if request.has_cookie_consent:
                try:
                    payload = dict(request.consent_categories)
                except Exception:
                    payload = {"functional": True}

                try:
                    value = json.dumps(payload)
                    response.set_cookie(
                        self.cookie_name,
                        value,
                        max_age=self.cookie_max_age,
                        samesite=self.cookie_samesite,
                        secure=self.cookie_secure,
                        httponly=False,  # UI needs access
                    )
                except Exception as exc:
                    logger.debug("ConsentMiddleware: set_cookie failed -> %s", exc)
        except Exception as exc:
            logger.debug("ConsentMiddleware: process_response error -> %s", exc)

        return response

--------------------------------------------
### FILE: apps\consent\models.py
### SIZE: 13420 bytes
### HASH: A7E8CE853428965FF3D592274EEC74FDFE6037A6D0E0C63603CC466439D79DDC

"""
apps.consent.models
===================

Authoritative, consolidated GDPR/CCPA consent models.
- Django 5.2 / Python 3.12 compliant
- No duplicate definitions
- No deprecated APIs
- Correct FK wiring
- Fully aligned with utils + views + API
"""

from __future__ import annotations

import logging
from typing import Any, Dict, Optional

from django.conf import settings
from django.core.cache import cache
from django.db import models, transaction
from django.utils import timezone
from django.utils.text import slugify

logger = logging.getLogger(__name__)


# ============================================================================
# ConsentCategory
# ============================================================================


class ConsentCategory(models.Model):
    """Configurable GDPR/CCPA category such as analytics, marketing, essential."""

    name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    required = models.BooleanField(default=False)

    class Meta:
        ordering = ["required", "name"]
        verbose_name = "Consent category"
        verbose_name_plural = "Consent categories"
        indexes = [
            models.Index(fields=["slug"], name="consent_cat_slug_idx"),
        ]

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)

        super().save(*args, **kwargs)

        # Invalidate all domains — safe
        try:
            from apps.consent.utils import invalidate_policy_cache

            invalidate_policy_cache(None)
        except Exception as exc:
            logger.warning("ConsentCategory.save: cache invalidation failed → %s", exc)


# ============================================================================
# ConsentPolicy
# ============================================================================


class ConsentPolicy(models.Model):
    """
    Versioned, auditable consent policy.
    Provides banner text, management text, snapshot, and TTL.
    """

    # NOT PK — Django still generates automatic integer PK
    version = models.CharField(max_length=20, unique=True)

    site_domain = models.CharField(
        max_length=100,
        default="default",
        db_index=True,
        help_text="Domain this policy belongs to.",
    )

    is_active = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    categories_snapshot = models.JSONField(default=dict, blank=True)

    banner_text = models.TextField(
        blank=True,
        default="We use cookies to improve your browsing experience.",
    )
    manage_text = models.TextField(
        blank=True,
        default="Manage your cookie preferences.",
    )

    cache_ttl_seconds = models.PositiveIntegerField(
        default=300,
        help_text="Cache TTL for the active policy payload.",
    )

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Consent policy"
        verbose_name_plural = "Consent policies"
        constraints = [
            # Only one active policy per domain
            models.UniqueConstraint(
                fields=["site_domain", "is_active"],
                condition=models.Q(is_active=True),
                name="unique_active_policy_per_site",
            )
        ]
        indexes = [
            models.Index(fields=["site_domain"], name="consent_policy_site_idx"),
            models.Index(fields=["version"], name="consent_policy_version_idx"),
        ]

    def __str__(self):
        return f"{self.site_domain} · v{self.version}"

    # ----------------------------------------------------------------------

    @staticmethod
    def _build_snapshot() -> Dict[str, Any]:
        """Convert ConsentCategory rows → JSON snapshot."""
        try:
            return {
                c.slug: {
                    "name": c.name,
                    "description": c.description or "",
                    "required": bool(c.required),
                }
                for c in ConsentCategory.objects.all()
            }
        except Exception as exc:
            logger.exception("ConsentPolicy._build_snapshot failed → %s", exc)
            return {}

    # ----------------------------------------------------------------------

    def to_payload(self) -> Dict[str, Any]:
        """Serializable dict consumed by utils, views, and API."""
        ttl = int(self.cache_ttl_seconds or settings.CONSENT_POLICY_CACHE_TTL)
        return {
            "version": str(self.version),
            "categories_snapshot": self.categories_snapshot or {},
            "cache_ttl_seconds": ttl,
            "banner_text": self.banner_text or "",
            "manage_text": self.manage_text or "",
            "site_domain": self.site_domain,
        }

    # ----------------------------------------------------------------------

    def save(self, *args, **kwargs):
        """Atomic write + ensure only one active policy per domain."""
        self.site_domain = (self.site_domain or "default").strip().lower()

        # Always rebuild snapshot
        try:
            snapshot = self._build_snapshot()
            if not self.pk or snapshot != self.categories_snapshot:
                self.categories_snapshot = snapshot
        except Exception as exc:
            logger.error("ConsentPolicy.save: snapshot error → %s", exc)

        try:
            if self.is_active:
                # Enforce active=1 per domain
                with transaction.atomic():
                    ConsentPolicy.objects.select_for_update().filter(
                        site_domain=self.site_domain, is_active=True
                    ).exclude(pk=self.pk).update(is_active=False)

                    super().save(*args, **kwargs)
            else:
                super().save(*args, **kwargs)

        except Exception as exc:
            logger.error("ConsentPolicy.save failed → %s", exc)
            raise

        # Invalidate only this domain
        try:
            from apps.consent.utils import invalidate_policy_cache

            invalidate_policy_cache(self.site_domain)
        except Exception as exc:
            logger.warning("ConsentPolicy.save: failed to invalidate → %s", exc)

    # ----------------------------------------------------------------------

    @classmethod
    def get_active(cls, site_domain="default") -> Optional[Dict[str, Any]]:
        try:
            from apps.consent.utils import get_active_policy

            return get_active_policy(site_domain)
        except Exception:
            return None


# ============================================================================
# ConsentRecord
# ============================================================================


class ConsentRecord(models.Model):
    """
    Per-user/session consent state for a *specific policy version*.
    """

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="consent_records",
    )

    session_key = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        db_index=True,
    )

    # Correct FK wiring — bind by version string, not PK
    policy = models.ForeignKey(
        ConsentPolicy,
        to_field="version",
        db_column="policy_version", # FK uses this column name
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="records",
    )

    # Duplicate for quick lookup
    # FIX: Use a distinct db_column name to avoid collision with the FK
    policy_version = models.CharField(
        max_length=20, 
        blank=True,
        db_column="policy_version_str" # <-- FIX APPLIED HERE
    )

    site_domain = models.CharField(max_length=100, default="default")

    accepted_categories = models.JSONField(default=dict, blank=True)

    accepted_at = models.DateTimeField(null=True, blank=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-updated_at"]
        verbose_name = "Consent record"
        verbose_name_plural = "Consent records"
        constraints = [
            models.UniqueConstraint(
                fields=["user", "policy_version", "site_domain"],
                name="unique_consent_per_user",
            ),
            models.UniqueConstraint(
                fields=["session_key", "policy_version", "site_domain"],
                name="unique_consent_per_session",
            ),
            models.CheckConstraint(
                check=models.Q(user__isnull=False)
                | (models.Q(session_key__isnull=False) & ~models.Q(session_key="")),
                name="valid_user_or_session",
            ),
        ]
        indexes = [
            models.Index(fields=["policy_version"], name="consent_rec_policy_idx"),
            models.Index(fields=["site_domain"], name="consent_rec_site_idx"),
            models.Index(
                fields=["user", "site_domain", "updated_at"],
                name="consent_user_site_time_idx",
            ),
        ]

    def __str__(self):
        ident = getattr(self.user, "email", None) or self.session_key or "anonymous"
        return f"{ident} · v{self.policy_version or 'N/A'}"

    # ----------------------------------------------------------------------

    def save(self, *args, **kwargs):
        """Strict, deterministic, no silent failure."""
        if self.accepted_categories and not self.accepted_at:
            self.accepted_at = timezone.now()

        # Sync version from FK
        if self.policy and not self.policy_version:
            try:
                self.policy_version = self.policy.version
            except Exception:
                pass

        self.site_domain = (self.site_domain or "default").strip().lower()

        super().save(*args, **kwargs)

    # ----------------------------------------------------------------------

    def is_reject_all(self) -> bool:
        """
        True if all optional categories are rejected.
        Required categories don't count.
        """
        accepted = self.accepted_categories or {}
        if not accepted:
            return True

        # Cache required slugs
        try:
            required = cache.get("required_consent_categories")
            if required is None:
                required = set(
                    ConsentCategory.objects.filter(required=True).values_list(
                        "slug", flat=True
                    )
                )
                cache.set("required_consent_categories", required, 3600)
        except Exception:
            required = set()

        try:
            return not any(v for k, v in accepted.items() if k not in required)
        except Exception:
            return True

    # ----------------------------------------------------------------------

    def audit_summary(self) -> str:
        """Human-readable list of accepted categories."""
        try:
            if not self.accepted_categories:
                return "No categories accepted"

            accepted_names = []
            for slug, val in self.accepted_categories.items():
                if not val:
                    continue
                cat = ConsentCategory.objects.filter(slug=slug).only("name").first()
                if cat:
                    accepted_names.append(cat.name)

            return ", ".join(sorted(accepted_names)) if accepted_names else "None"
        except Exception:
            return "Unavailable"


# ============================================================================
# ConsentLog
# ============================================================================


class ConsentLog(models.Model):
    """Immutable audit log of user/session consent actions."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="consent_logs",
    )

    ip_address = models.GenericIPAddressField(null=True, blank=True)
    user_agent = models.TextField(blank=True)

    accepted_categories = models.JSONField(default=dict, blank=True)

    policy_version = models.CharField(max_length=20, blank=True)
    site_domain = models.CharField(max_length=100, default="default")

    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-timestamp"]
        verbose_name = "Consent log"
        verbose_name_plural = "Consent logs"
        indexes = [
            models.Index(fields=["timestamp"], name="consent_log_time_idx"),
        ]

    def __str__(self):
        ident = getattr(self.user, "email", None) or self.ip_address or "unknown"
        version = self.policy_version or "N/A"
        return f"{ident} · v{version}"


--------------------------------------------
### FILE: apps\consent\signals.py
### SIZE: 6634 bytes
### HASH: 85CE3C9FF92BA1D0AD6E46761F999C06BE855B97ADA196ED859608C9793780B6

"""
apps.consent.signals
====================

Enterprise-grade signal handlers for consent management.

✅ Django 5.2 / Python 3.12 Ready
✅ Seamless merge of session → user consent on login
✅ Cleans redundant session records post-merge
✅ Uses canonical utils for site & policy resolution
✅ Defensive session handling and cleanup
✅ Atomic DB ops, async-safe, no silent leaks
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from apps.consent.models import ConsentRecord
from apps.consent.utils import get_active_policy, resolve_site_domain
from django.contrib.auth.signals import user_logged_in, user_logged_out
from django.db import transaction
from django.dispatch import receiver

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Internal helper
# ---------------------------------------------------------------------------


def _safe_session_key(request) -> Optional[str]:
    """Return session key if available, else None."""
    try:
        return getattr(getattr(request, "session", None), "session_key", None)
    except Exception:
        return None


# ---------------------------------------------------------------------------
# USER LOGIN — Merge Session Consent
# ---------------------------------------------------------------------------


@receiver(user_logged_in, dispatch_uid="merge_session_consent_v2")
def merge_session_consent(sender: Any, user: Any, request, **kwargs) -> None:
    """
    On user login, merge any session-based consent record into the
    user's permanent consent record.

    - Uses canonical helpers
    - Fully defensive and idempotent
    - Atomic update to avoid partial merges
    """

    # 1️⃣ Resolve site domain
    try:
        site_domain = resolve_site_domain(request)
    except Exception as exc:
        logger.debug("merge_session_consent: resolve_site_domain failed → %s", exc)
        site_domain = "default"

    # 2️⃣ Retrieve active policy (payload dict)
    policy = get_active_policy(site_domain)
    if not policy:
        logger.debug("merge_session_consent: no active policy for site=%s", site_domain)
        return

    policy_version = str(policy.get("version", "") or "")
    if not policy_version:
        logger.debug(
            "merge_session_consent: active policy missing version for site=%s",
            site_domain,
        )
        return

    # 3️⃣ Get session key
    session_key = _safe_session_key(request)
    if not session_key:
        logger.debug(
            "merge_session_consent: session missing or no key for user=%s",
            getattr(user, "email", None),
        )
        return

    # 4️⃣ Fetch anonymous session consent record
    try:
        session_rec = ConsentRecord.objects.filter(
            session_key=session_key,
            policy_version=policy_version,
            site_domain=site_domain,
            user__isnull=True,
        ).first()
    except Exception as exc:
        logger.exception(
            "merge_session_consent: lookup failed for %s → %s", session_key, exc
        )
        return

    if not session_rec:
        logger.debug("merge_session_consent: no session record for key=%s", session_key)
        return

    # 5️⃣ Merge into user-level record (atomic)
    try:
        with transaction.atomic():
            user_rec, created = ConsentRecord.objects.select_for_update().get_or_create(
                user=user,
                policy_version=policy_version,
                site_domain=site_domain,
                defaults={
                    "accepted_categories": session_rec.accepted_categories,
                    "session_key": session_key,
                },
            )

            if created:
                logger.info(
                    "merge_session_consent: created consent v%s for %s (%s)",
                    policy_version,
                    getattr(user, "email", None),
                    site_domain,
                )
            else:
                if user_rec.accepted_categories != session_rec.accepted_categories:
                    user_rec.accepted_categories = session_rec.accepted_categories
                    user_rec.save(update_fields=["accepted_categories", "updated_at"])
                    logger.debug(
                        "merge_session_consent: updated existing consent for %s (site=%s)",
                        getattr(user, "email", None),
                        site_domain,
                    )

            # 6️⃣ Clean redundant session record
            try:
                session_rec.delete()
                logger.debug(
                    "merge_session_consent: cleaned session record key=%s", session_key
                )
            except Exception as exc:
                logger.debug(
                    "merge_session_consent: cleanup failed for %s → %s",
                    session_key,
                    exc,
                )

    except Exception as exc:
        logger.exception(
            "merge_session_consent: atomic merge failed for user=%s → %s",
            getattr(user, "email", None),
            exc,
        )


# ---------------------------------------------------------------------------
# USER LOGOUT — Clear Session Consent
# ---------------------------------------------------------------------------


@receiver(user_logged_out, dispatch_uid="clear_session_consent_v2")
def clear_session_consent(sender: Any, request, user: Any, **kwargs) -> None:
    """
    On logout, remove transient consent data from the session
    to prevent stale reuse in subsequent logins.
    """
    try:
        session = getattr(request, "session", None)
        if not session:
            logger.debug(
                "clear_session_consent: no session for user=%s",
                getattr(user, "email", None),
            )
            return

        if "consent_data" in session:
            session.pop("consent_data", None)
            try:
                session.save()
            except Exception as exc:
                logger.debug("clear_session_consent: session.save() failed → %s", exc)
            logger.debug(
                "clear_session_consent: cleared session consent for user=%s",
                getattr(user, "email", None),
            )

    except Exception as exc:
        logger.debug("clear_session_consent: unexpected failure → %s", exc)


--------------------------------------------
### FILE: apps\consent\urls.py
### SIZE: 2705 bytes
### HASH: 037AD701C64865AC82DEE940051E960332B0D0549C453F3D1249956D7C895B61

from __future__ import annotations

from django.urls import path
from . import views

# If you have a lazy loader utility, import it here.
# Otherwise, implement with django.utils.module_loading.import_string.
try:
    from gsminfinity.urls import lazy_view
except ImportError:
    from django.utils.module_loading import import_string

    def lazy_view(dotted_path: str):
        def _wrapped(*args, **kwargs):
            view = import_string(dotted_path)
            return view(*args, **kwargs)
        return _wrapped

app_name = "consent"

urlpatterns = [
    # ------------------------------------------------------------------
    # Banner loader (HTML partial — HTMX / JS)
    # ------------------------------------------------------------------
    path("banner/", views.banner_partial, name="banner"),

    # ------------------------------------------------------------------
    # Canonical HTML endpoints (UI-driven)
    # ------------------------------------------------------------------
    path("manage/", views.manage_consent, name="manage"),
    path("status/", views.consent_status, name="status"),

    # ------------------------------------------------------------------
    # Consent mutation handlers (HTML/HTMX + JSON fallback)
    # ------------------------------------------------------------------
    path("accept/", views.consent_accept, name="accept"),
    path("accept-all/", views.consent_accept_all, name="accept_all"),
    path("reject-all/", views.consent_reject_all, name="reject_all"),

    # ------------------------------------------------------------------
    # Compatibility aliases (underscore style)
    # Required because frontend still calls /consent/accept_all/ etc.
    # ------------------------------------------------------------------
    path("accept_all/", views.consent_accept_all, name="accept_all_alias"),
    path("reject_all/", views.consent_reject_all, name="reject_all_alias"),

    # ------------------------------------------------------------------
    # Legacy alias (deprecated, kept for JS compatibility)
    # ------------------------------------------------------------------
    path("save/", views.consent_accept, name="save"),

    # ------------------------------------------------------------------
    # JSON API (canonical, frontend-safe)
    # ------------------------------------------------------------------
    path(
        "api/status/",
        lazy_view("apps.consent.api.get_consent_status"),
        name="api_status",
    ),
    path(
        "api/update/",
        lazy_view("apps.consent.api.update_consent"),
        name="api_update",
    ),
]


--------------------------------------------
### FILE: apps\consent\utils.py
### SIZE: 5981 bytes
### HASH: 0838EE7A508340C02C71EDC1D47FFE54445656309D5059704232B0FC4F411BD7

"""
apps.consent.utils
==================

Canonical helpers for enterprise-grade consent management.

✔ Safe, unified domain normalization
✔ Canonical cache key generation
✔ Fully serializable active-policy payloads
✔ ORM → cache promotion with TTL
✔ Django 5.2 / Python 3.12 compliant
✔ No silent failures
"""

from __future__ import annotations

import hashlib
import logging
from typing import Any, Dict, Optional

from apps.consent.models import ConsentPolicy
from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Defaults
# ---------------------------------------------------------------------------

DEFAULT_TTL_SECONDS = 300


# ---------------------------------------------------------------------------
# Cache Key Helpers
# ---------------------------------------------------------------------------


def consent_cache_key(domain: str) -> str:
    """
    Canonical, collision-resistant cache key for a site's active ConsentPolicy.
    """
    safe = (domain or "default").strip().lower()
    digest = hashlib.sha256(safe.encode("utf-8")).hexdigest()[:12]
    return f"active_consent_policy_{digest}"


# ---------------------------------------------------------------------------
# Domain Resolution
# ---------------------------------------------------------------------------


def resolve_site_domain(request) -> str:
    """
    Resolve domain according to canonical order:

        1) django.contrib.sites
        2) request.get_host()
        3) "default"

    Always normalized to lowercase + stripped.
    """
    try:
        site = get_current_site(request)
        domain = getattr(site, "domain", None) or request.get_host() or "default"
        domain = str(domain).strip().lower()
        return domain or "default"
    except Exception as exc:
        logger.debug("resolve_site_domain fallback → %s", exc)
        return "default"


# ---------------------------------------------------------------------------
# Active Policy Retrieval
# ---------------------------------------------------------------------------


def get_active_policy(domain: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve active ConsentPolicy payload for a given domain.

    Schema returned:
        {
            "version": "v1",
            "categories_snapshot": {...},
            "banner_text": "...",
            "manage_text": "...",
            "is_active": True,
            "site_domain": "example.com",
            "cache_ttl_seconds": 300
        }

    - Never returns ORM objects
    - Cache is authoritative when present
    - Safe under all backends
    - Defensive normalization
    """
    domain = (domain or "default").strip().lower()
    key = consent_cache_key(domain)

    # ----- Cache Read -----
    try:
        cached = cache.get(key)
        if cached is not None:
            return cached
    except Exception as exc:
        logger.debug("get_active_policy: cache.get failed → %s", exc)

    # ----- DB Fallback -----
    try:
        policy = (
            ConsentPolicy.objects.filter(is_active=True, site_domain=domain)
            .only(
                "version",
                "categories_snapshot",
                "banner_text",
                "manage_text",
                "cache_ttl_seconds",
                "is_active",
                "site_domain",
            )
            .order_by("-created_at")
            .first()
        )
    except Exception as exc:
        logger.exception("get_active_policy: DB failure → %s", exc)
        return None

    if not policy:
        return None

    ttl = int(
        getattr(policy, "cache_ttl_seconds", DEFAULT_TTL_SECONDS) or DEFAULT_TTL_SECONDS
    )

    payload: Dict[str, Any] = {
        "version": str(policy.version),
        "categories_snapshot": policy.categories_snapshot or {},
        "banner_text": getattr(policy, "banner_text", "") or "",
        "manage_text": getattr(policy, "manage_text", "") or "",
        "is_active": bool(policy.is_active),
        "site_domain": (policy.site_domain or domain).strip().lower(),
        "cache_ttl_seconds": ttl,
    }

    # ----- Cache Write -----
    try:
        cache.set(key, payload, timeout=ttl)
        logger.debug("get_active_policy: cached active policy for domain=%s", domain)
    except Exception as exc:
        logger.debug("get_active_policy: cache.set failed → %s", exc)

    return payload


# ---------------------------------------------------------------------------
# Cache Invalidator
# ---------------------------------------------------------------------------


def invalidate_policy_cache(domain: Optional[str] = None) -> None:
    """
    Invalidate cached active policies:

        domain provided → delete only that domain
        no domain       → wildcard purge if supported

    Never raises.
    """
    # Per-domain invalidate
    if domain:
        key = consent_cache_key((domain or "default").strip().lower())
        try:
            cache.delete(key)
            logger.debug("invalidate_policy_cache: deleted key=%s", key)
        except Exception as exc:
            logger.debug("invalidate_policy_cache: delete failed → %s", exc)
        return

    # Wildcard invalidate (Redis / LocMem, etc.)
    try:
        if hasattr(cache, "delete_pattern"):
            cache.delete_pattern("active_consent_policy_*")
            logger.debug("invalidate_policy_cache: wildcard invalidation performed")
        else:
            logger.debug("invalidate_policy_cache: backend lacks delete_pattern()")
    except Exception as exc:
        logger.debug("invalidate_policy_cache: wildcard failed → %s", exc)

--------------------------------------------
### FILE: apps\consent\views.py
### SIZE: 21660 bytes
### HASH: F44090AD880F52AB9F9D3A3C566C4BCC9AAE34ABB40806AB6F29E103AD27BF83

"""
apps.consent.views
==================

Enterprise-grade GDPR / CCPA consent management views.
Hardened, deterministic, free from unsafe fallbacks.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, Optional

from apps.consent.models import ConsentPolicy, ConsentRecord
from apps.consent.utils import consent_cache_key, get_active_policy, resolve_site_domain
from django.conf import settings
from django.contrib import messages
from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.db import transaction
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.middleware.csrf import get_token
from django.shortcuts import redirect, render
from django.template import TemplateDoesNotExist
from django.template.loader import render_to_string
from django.template.response import TemplateResponse
from django.views.decorators.http import require_GET, require_POST

logger = logging.getLogger(__name__)


# ============================================================================
# INTERNAL UTILITIES
# ============================================================================


def hx_response(
    content: str = "", status: int = 200, triggers: Optional[dict] = None
) -> HttpResponse:
    """HTMX-safe response helper with HX-Trigger."""
    resp = HttpResponse(content, status=status)
    if triggers:
        try:
            resp["HX-Trigger"] = json.dumps(triggers)
        except Exception:
            logger.debug("hx_response: HX-Trigger serialization failed")
    return resp


def _is_htmx_or_ajax(request: HttpRequest) -> bool:
    """Detect HTMX or AJAX request."""
    try:
        if request.headers.get("HX-Request"):
            return True
        return request.headers.get("X-Requested-With", "").lower() == "xmlhttprequest"
    except Exception:
        return False


def _parse_json(request: HttpRequest, max_bytes: int = 1_048_576) -> Dict[str, Any]:
    try:
        raw = request.body or b""
        if len(raw) > max_bytes:
            return {"__error__": "payload_too_large"}
        if not raw:
            return {}
        return json.loads(raw.decode("utf-8", errors="ignore"))
    except Exception:
        return {}


def _bool(v: Any) -> bool:
    if isinstance(v, bool):
        return v
    return str(v).strip().lower() in {"1", "true", "yes", "on"}


def _ensure_session(request: HttpRequest) -> Optional[str]:
    """Guarantee a valid session key for anonymous users."""
    try:
        if not getattr(request, "session", None):
            return None
        if not request.session.session_key:
            request.session.create()
        return request.session.session_key
    except Exception:
        return None


def _domain(request: HttpRequest) -> str:
    """Unified domain resolver."""
    try:
        return (
            resolve_site_domain(request)
            or get_current_site(request).domain
            or request.get_host()
        )
    except Exception:
        return request.get_host()


def _active_policy(request: HttpRequest) -> Optional[Dict[str, Any]]:
    """Resolve the active policy safely with cache + ORM fallback."""
    try:
        domain = _domain(request)
        key = consent_cache_key(domain)

        cached = cache.get(key)
        if cached is not None:
            return cached

        # helper
        try:
            payload = get_active_policy(domain)
            if payload:
                ttl = int(
                    payload.get(
                        "cache_ttl_seconds",
                        getattr(settings, "CONSENT_POLICY_CACHE_TTL", 300),
                    )
                )
                cache.set(key, payload, timeout=ttl)
                return payload
        except Exception:
            pass

        # ORM
        obj = (
            ConsentPolicy.objects.filter(is_active=True, site_domain=domain)
            .order_by("-created_at")
            .first()
        )
        if not obj:
            return None

        payload = {
            "version": str(obj.version or ""),
            "categories_snapshot": obj.categories_snapshot or {},
            "banner_text": obj.banner_text or "",
            "manage_text": obj.manage_text or "",
            "is_active": obj.is_active,
            "site_domain": domain,
            "cache_ttl_seconds": int(
                getattr(
                    obj,
                    "cache_ttl_seconds",
                    getattr(settings, "CONSENT_POLICY_CACHE_TTL", 300),
                )
            ),
        }
        cache.set(key, payload, timeout=payload["cache_ttl_seconds"])
        return payload

    except Exception as exc:
        logger.exception("_active_policy failed -> %s", exc)
        return None


# ============================================================================
# BANNER
# ============================================================================


@require_GET
def banner_partial(request: HttpRequest) -> HttpResponse:
    """Render banner safely with multi-template fallback."""
    try:
        policy = _active_policy(request)
        if not policy:
            return HttpResponse("", content_type="text/html")

        # If user accepted everything earlier
        if getattr(request, "session", None) and request.session.get(
            "consent_all_accepted"
        ):
            return HttpResponse("", content_type="text/html")

        snapshot = policy.get("categories_snapshot", {}) or {}

        # Build categories
        categories = {
            slug: {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "required": bool(meta.get("required")),
                "accepted": bool(meta.get("required") or meta.get("default", False)),
            }
            for slug, meta in snapshot.items()
        }

        # Fallback (minimal required cookie)
        if not categories:
            categories = {
                "functional": {"name": "Functional", "required": True, "accepted": True}
            }

        ctx = {
            "consent_active": True,
            "consent_version": policy.get("version", ""),
            "consent_text": policy.get("banner_text", ""),
            "consent_categories": categories,
            "csrf_token": get_token(request),
        }

        for tpl in [
            "consent/includes/banner.html",
            "includes/banner.html",
            "consent/banner.html",
        ]:
            try:
                return TemplateResponse(request, tpl, ctx)
            except TemplateDoesNotExist:
                continue
            except Exception as exc:
                logger.exception("banner render error -> %s", exc)
                return HttpResponse("", content_type="text/html")

        return HttpResponse("", content_type="text/html")

    except Exception as exc:
        logger.exception("banner_partial failed -> %s", exc)
        return HttpResponse("", content_type="text/html")


# ============================================================================
# CONSENT MANAGEMENT PAGE
# ============================================================================


@require_GET
def manage_consent(request: HttpRequest) -> HttpResponse:
    try:
        policy = _active_policy(request)
        snapshot = (policy or {}).get("categories_snapshot", {}) or {}

        categories = [
            {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "slug": slug,
                "description": meta.get("description", ""),
                "required": bool(meta.get("required")),
                "accepted": bool(meta.get("required") or meta.get("default", False)),
            }
            for slug, meta in snapshot.items()
        ]

        if not categories:
            categories = [
                {
                    "name": "Functional",
                    "slug": "functional",
                    "required": True,
                    "accepted": True,
                },
                {
                    "name": "Analytics",
                    "slug": "analytics",
                    "required": False,
                    "accepted": False,
                },
            ]

        return render(
            request,
            "site_settings/consent_manage.html",
            {
                "consent_active": bool(policy),
                "consent_version": (policy or {}).get("version", ""),
                "consent_text": (policy or {}).get("manage_text", ""),
                "categories": categories,
            },
        )

    except Exception as exc:
        logger.exception("manage_consent failed -> %s", exc)
        return render(request, "site_settings/consent_manage.html", {"categories": []})


# ============================================================================
# STATUS ENDPOINT (HTML/JS)
# ============================================================================


@require_GET
def consent_status(request: HttpRequest) -> JsonResponse:
    """HTML/JS-safe status endpoint (NOT the API version)."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=404)

        snapshot = policy.get("categories_snapshot", {}) or {}

        categories = {
            slug: {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "required": bool(meta.get("required")),
                "default": bool(meta.get("default")),
                "accepted": bool(meta.get("required")),
            }
            for slug, meta in snapshot.items()
        }

        # Ensure functional
        categories.setdefault(
            "functional",
            {
                "name": "Functional",
                "required": True,
                "default": True,
                "accepted": True,
            },
        )

        domain = _domain(request)

        # Load previous record
        rec = None
        try:
            if request.user.is_authenticated:
                rec = ConsentRecord.objects.filter(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                ).first()
            else:
                sk = _ensure_session(request)
                if sk:
                    rec = ConsentRecord.objects.filter(
                        session_key=sk,
                        policy_version=policy["version"],
                        site_domain=domain,
                    ).first()
        except Exception:
            rec = None

        if rec and rec.accepted_categories:
            for slug, val in rec.accepted_categories.items():
                if slug in categories and not categories[slug]["required"]:
                    categories[slug]["accepted"] = bool(val)

        return JsonResponse(
            {
                "consent_active": True,
                "consent_version": policy["version"],
                "categories": categories,
                "site_domain": domain,
            },
            json_dumps_params={"indent": 2},
        )

    except Exception as exc:
        logger.exception("consent_status failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


# ============================================================================
# MUTATION HANDLERS
# ============================================================================


@require_POST
def consent_accept(request: HttpRequest) -> HttpResponse:
    """
    Save granular accept / accept_all / reject_all preferences.
    Unified deterministic handler.
    """
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"ok": False, "error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        # JSON or form
        if "json" in (request.content_type or "").lower():
            data = _parse_json(request)
            if data.get("__error__") == "payload_too_large":
                return JsonResponse({"error": "payload_too_large"}, status=413)
        else:
            data = request.POST.copy()

        reject_all = _bool(data.get("reject_all"))
        accept_all = _bool(data.get("accept_all"))

        # Build acceptance map
        if reject_all:
            accepted = {slug: False for slug in valid_slugs}
            accepted["functional"] = True
            for slug, meta in snapshot.items():
                if meta.get("required"):
                    accepted[slug] = True

        elif accept_all:
            accepted = {slug: True for slug in valid_slugs}

        else:
            accepted = {
                slug: (
                    True
                    if slug == "functional" or snapshot.get(slug, {}).get("required")
                    else _bool(data.get(slug))
                )
                for slug in valid_slugs
            }

        sanitized = {slug: bool(v) for slug, v in accepted.items()}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {
            "accepted_categories": sanitized,
            "site_domain": domain,
            "session_key": sk,
        }

        # Save record
        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        # Session flags
        try:
            if getattr(request, "session", None):
                non_required = [v for k, v in sanitized.items() if k != "functional"]
                request.session["consent_all_accepted"] = (
                    all(non_required) if non_required else True
                )
                request.session["consent_rejected"] = (
                    not any(non_required) if non_required else False
                )
                request.session.modified = True
        except Exception:
            pass

        msg = (
            "You have rejected all optional cookies."
            if reject_all
            else (
                "You have accepted all optional cookies."
                if accept_all
                else "Your preferences have been saved."
            )
        )

        # JSON response
        if "json" in (request.content_type or "").lower() and _is_htmx_or_ajax(request):
            return JsonResponse(
                {
                    "ok": True,
                    "message": msg,
                    "consent": sanitized,
                    "hx_trigger": {"showToast": {"html": msg}},
                },
                json_dumps_params={"indent": 2},
            )

        # HTMX
        if _is_htmx_or_ajax(request):
            toast_html = render_to_string(
                "partials/toast_fragment.html",
                {"message": msg},
                request=request,  # CSP nonce propagation
            )
            return hx_response(
                "",
                triggers={
                    "removeConsentBanner": True,
                    "showToast": {"html": toast_html},
                },
            )

        messages.success(request, msg)
        return redirect(data.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_accept failed -> %s", exc)
        if _is_htmx_or_ajax(request):
            return JsonResponse({"ok": False, "error": "internal_error"}, status=500)
        messages.error(request, "Unexpected error while saving preferences.")
        return redirect("/")


@require_POST
def consent_accept_all(request: HttpRequest) -> HttpResponse:
    """Accept all optional categories."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        sanitized = {slug: True for slug in valid_slugs}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {
            "accepted_categories": sanitized,
            "site_domain": domain,
            "session_key": sk,
        }

        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        try:
            if getattr(request, "session", None):
                request.session["consent_all_accepted"] = True
                request.session["consent_rejected"] = False
                request.session.modified = True
        except Exception:
            pass

        msg = "You have accepted all optional cookies."

        if _is_htmx_or_ajax(request):
            toast_html = render_to_string(
                "partials/toast_fragment.html",
                {"message": msg},
                request=request,  # CSP nonce propagation
            )
            return hx_response(
                "",
                triggers={
                    "removeConsentBanner": True,
                    "showToast": {"html": toast_html},
                },
            )

        messages.success(request, msg)
        return redirect(request.POST.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_accept_all failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


@require_POST
def consent_reject_all(request: HttpRequest) -> HttpResponse:
    """Reject all optional categories."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        accepted = {slug: False for slug in valid_slugs}
        accepted["functional"] = True

        for slug, meta in snapshot.items():
            if meta.get("required"):
                accepted[slug] = True

        sanitized = {k: bool(v) for k, v in accepted.items()}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {
            "accepted_categories": sanitized,
            "site_domain": domain,
            "session_key": sk,
        }

        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        try:
            if getattr(request, "session", None):
                request.session["consent_all_accepted"] = False
                request.session["consent_rejected"] = True
                request.session.modified = True
        except Exception:
            pass

        msg = "You rejected optional cookies."

        if _is_htmx_or_ajax(request):
            toast_html = render_to_string(
                "partials/toast_fragment.html",
                {"message": msg},
                request=request,  # CSP nonce propagation
            )
            return hx_response(
                "",
                triggers={
                    "removeConsentBanner": True,
                    "showToast": {"html": toast_html},
                },
            )

        messages.success(request, msg)
        return redirect(request.POST.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_reject_all failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


--------------------------------------------
### FILE: apps\core\__init__.py
### SIZE: 198 bytes
### HASH: 42AB58497CD5DB429005E3A9067135FE0CCF1301D1A6472DA1E2A4598D9EA8B3

"""
Core application package for GSMInfinity.

Keep this file free of side effects so imports remain predictable
and safe in management commands, migrations, and tests.
"""

__all__: list[str] = []


--------------------------------------------
### FILE: apps\core\admin.py
### SIZE: 7513 bytes
### HASH: D74C956026749B9916BDAB75AC93DC8A3E38AFF13A8F2195F52A46F6153FEFBA

"""
admin.py
--------
Enterprise-ready admin bootstrap for the app.

Features:
- Admin site branding (centralized)
- Safe JSON/CSV export admin action helper
- Automatic registration of unregistered models with a default ModelAdmin
- Clear defaults for list_display/search_fields to avoid heavy table scans
- No deprecated APIs (Django 5.2+ compatible)
"""

from __future__ import annotations

import json
import logging
from typing import Iterable

from django import forms
from django.contrib import admin
from django.core.exceptions import ImproperlyConfigured
from django.db import models
from django.http import HttpResponse
from django.utils.encoding import smart_str
from django.utils.text import capfirst

logger = logging.getLogger(__name__)

# ---------------------------
# Admin site branding (change as needed)
# ---------------------------
admin.site.site_header = "GSMInfinity Administration"
admin.site.site_title = "GSM Admin"
admin.site.index_title = "System Administration"


# ---------------------------
# Utility admin actions
# ---------------------------
def export_as_json_action(description: str = "Export selected objects as JSON"):
    """
    Returns an admin action that exports selected queryset to JSON.
    Usage:
        actions = [export_as_json_action("Export selected users as JSON")]
    """

    def action(modeladmin, request, queryset):
        model = modeladmin.model
        # Use values() to avoid serializing complex relations; admins can override for custom output
        try:
            fields = [f.name for f in model._meta.concrete_fields]
        except Exception:
            fields = None

        data = list(queryset.values(*fields)) if fields else list(queryset.values())
        resp = HttpResponse(
            json.dumps(data, ensure_ascii=False, indent=2),
            content_type="application/json; charset=utf-8",
        )
        resp["Content-Disposition"] = (
            f"attachment; filename={model._meta.model_name}_export.json"
        )
        return resp

    action.short_description = description
    return action


def export_as_csv_action(description: str = "Export selected objects as CSV"):
    """
    Returns an admin action that exports selected queryset to CSV.
    Basic, safe implementation — override in specific ModelAdmin for customized exports.
    """

    def action(modeladmin, request, queryset):
        import csv

        model = modeladmin.model
        try:
            fields = [f.name for f in model._meta.concrete_fields]
        except Exception:
            fields = None

        response = HttpResponse(content_type="text/csv; charset=utf-8")
        response["Content-Disposition"] = (
            f"attachment; filename={model._meta.model_name}_export.csv"
        )
        response.write("\ufeff")  # UTF-8 BOM for Excel

        writer = csv.writer(response)
        if fields:
            writer.writerow([smart_str(capfirst(f)) for f in fields])
            for obj in queryset.values_list(*fields):
                writer.writerow([smart_str(v) for v in obj])
        else:
            # fallback to keys of values()
            first = queryset.values().first()
            if not first:
                return response
            keys = list(first.keys())
            writer.writerow([smart_str(capfirst(k)) for k in keys])
            for obj in queryset.values(*keys):
                writer.writerow([smart_str(obj.get(k, "")) for k in keys])

        return response

    action.short_description = description
    return action


# ---------------------------
# Default ModelAdmin used for auto-registration
# ---------------------------
class DefaultModelAdmin(admin.ModelAdmin):
    """
    Sensible defaults for auto-registered models:
    - show first 6 concrete fields in list_display
    - search on TextField/CharField if present (first 3)
    - readonly auto timestamp fields if present
    - includes JSON/CSV export actions
    """

    actions = [
        export_as_json_action(),
        export_as_csv_action(),
    ]

    def __init__(self, model, admin_site):
        # attempt to build light-weight list_display and search_fields to avoid heavy DB scans
        try:
            concrete_fields = [
                f
                for f in model._meta.concrete_fields
                if not isinstance(f, models.ManyToManyField)
            ]
            # prefer id/email/username/date fields if present
            preferred = []
            for name in (
                "email",
                "username",
                "name",
                "title",
                "id",
                "created_at",
                "created",
                "date_joined",
            ):
                if any(f.name == name for f in concrete_fields):
                    preferred.append(name)
            # fallback to first N concrete fields
            fallback = [f.name for f in concrete_fields][:6]
            list_display = preferred + [f for f in fallback if f not in preferred]
            self.list_display = tuple(list_display) if list_display else ("__str__",)
            # search on first few textual fields
            text_fields = [
                f.name
                for f in concrete_fields
                if isinstance(f, (models.CharField, models.TextField))
            ][:3]
            self.search_fields = tuple(text_fields) if text_fields else ()
            # readonly timestamp-like fields
            ro = [
                f.name
                for f in concrete_fields
                if f.name in ("created_at", "updated_at", "date_joined", "created")
            ]
            self.readonly_fields = tuple(ro)
        except Exception as exc:
            logger.debug("DefaultModelAdmin init fallback: %s", exc)
        super().__init__(model, admin_site)


# ---------------------------
# Auto-register any models from this app that are not already registered
# ---------------------------
def auto_register_models(app_label: str):
    """
    Automatically register models belonging to `app_label` that are not yet registered.
    Use with caution — it's convenient during development and safe in production because
    ModelAdmin defaults are conservative.
    """
    from django.apps import apps as django_apps

    try:
        app_config = django_apps.get_app_config(app_label)
    except LookupError as exc:
        raise ImproperlyConfigured(
            f"Cannot auto-register models: unknown app_label '{app_label}'"
        ) from exc

    for model in app_config.get_models():
        model_name = model._meta.model_name
        if model in admin.site._registry:
            continue
        try:
            admin.site.register(model, DefaultModelAdmin)
            logger.info("Auto-registered model %s.%s in admin", app_label, model_name)
        except admin.sites.AlreadyRegistered:
            continue
        except Exception as exc:
            logger.exception(
                "Failed to auto-register %s.%s : %s", app_label, model_name, exc
            )


# ---------------------------
# If you want automatic registration for the current app, un-comment and set the app label:
# e.g. for apps.core use app_label = "apps.core"
# ---------------------------
# auto_register_models("apps.core")

--------------------------------------------
### FILE: apps\core\ai.py
### SIZE: 1656 bytes
### HASH: 791DA12E8383A1DBA7B083562D9C917DCA50A52625D636494636D60314FB3708

from __future__ import annotations

import logging
import time
from typing import List, Dict, Any

from apps.core import ai_client
from apps.core.utils.logging import log_event

logger = logging.getLogger(__name__)


def generate_text(prompt: str, context: str = "", constraints: Dict[str, Any] | None = None, user=None) -> str:
    start = time.monotonic()
    full_prompt = prompt
    if context:
        full_prompt = f"{prompt}\nContext:\n{context}"
    try:
        result = ai_client.generate_answer(question=full_prompt, user=user)
        log_event(logger, "info", "ai.generate_text.success", elapsed_ms=round((time.monotonic() - start) * 1000))
        return result
    except Exception as exc:
        log_event(logger, "warning", "ai.generate_text.failed", error=str(exc))
        return ""


def classify_text(text: str, labels: List[str] | None = None, user=None) -> str:
    try:
        prompt = f"Classify the following text into one of the labels {labels}: {text}"
        result = ai_client.generate_answer(question=prompt, user=user)
        log_event(logger, "info", "ai.classify_text.success", labels=labels or [])
        return result
    except Exception as exc:
        log_event(logger, "warning", "ai.classify_text.failed", error=str(exc))
        return ""


def embed_text(text: str) -> bytes:
    try:
        # Placeholder: return empty bytes until embedding provider is wired.
        vec = b""
        log_event(logger, "info", "ai.embed_text.success", has_embedding=bool(vec))
        return vec
    except Exception as exc:
        log_event(logger, "warning", "ai.embed_text.failed", error=str(exc))
        return b""


--------------------------------------------
### FILE: apps\core\ai_client.py
### SIZE: 10474 bytes
### HASH: E59B4C7AB85320FD20DFAF7E8637C7E6F881ADB6DE896D180C535218F55C0ACB

"""
apps.core.ai_client
-------------------
Enterprise AI provider integration for the assistant endpoint.

- OpenAI SDK v1-style implementation with timeouts
- Explicit configuration loading and fail-fast behaviour
- Safe fallbacks and structured logging
"""

from __future__ import annotations

import logging
import time
from dataclasses import dataclass
from typing import Optional, List, Dict

from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.exceptions import ImproperlyConfigured

try:
    from openai import OpenAI  # type: ignore
except Exception:  # pragma: no cover
    OpenAI = None  # type: ignore

logger = logging.getLogger(__name__)
User = get_user_model()


class AiClientError(RuntimeError):
    """Raised when the AI backend cannot be used safely."""


@dataclass
class AiConfig:
    api_key: str
    model: str
    max_retries: int = 2
    retry_backoff: float = 0.75
    timeout: float = 15.0
    mock_mode: bool = False


def _load_config() -> AiConfig:
    """
    Load AI provider configuration from Django settings.
    """
    api_key = getattr(settings, "AI_OPENAI_API_KEY", "") or ""
    mock_mode = bool(getattr(settings, "AI_MOCK_MODE", False))

    if not api_key and not mock_mode:
        raise AiClientError("AI_OPENAI_API_KEY is not configured")

    model = getattr(settings, "AI_OPENAI_MODEL", "gpt-4.1-mini")
    timeout = float(getattr(settings, "AI_OPENAI_TIMEOUT", 15.0))
    max_retries = int(getattr(settings, "AI_OPENAI_MAX_RETRIES", 2))
    retry_backoff = float(getattr(settings, "AI_OPENAI_RETRY_BACKOFF", 0.75))

    return AiConfig(
        api_key=api_key,
        model=model,
        timeout=timeout,
        max_retries=max_retries,
        retry_backoff=retry_backoff,
        mock_mode=mock_mode,
    )


def _get_client(config: AiConfig):
    if OpenAI is None:
        raise AiClientError("OpenAI SDK is not installed")
    return OpenAI(api_key=config.api_key)


def _build_system_prompt(user: User) -> str:
    username = getattr(user, "username", "user")
    return (
        "You are the GSMInfinity support assistant. "
        "Answer questions concisely and accurately based on general knowledge. "
        "Never reveal internal system details, secrets, or source code. "
        f"User identifier: {username}."
    )


def generate_answer(*, question: str, user: User) -> str:
    """
    Main AI entrypoint used by apps.core.views.ai_assistant_view.

    Returns a plain text answer or raises AiClientError on config/client issues.
    """
    question = (question or "").strip()
    if not question:
        raise AiClientError("Empty question passed to generate_answer")

    config = _load_config()
    system_prompt = _build_system_prompt(user)

    start = time.monotonic()
    if config.mock_mode:
        return _mock_response(question)

    client = _get_client(config)

    attempts = config.max_retries + 1
    for attempt in range(1, attempts + 1):
        try:
            response = client.responses.create(
                model=config.model,
                input=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": question},
                ],
                timeout=config.timeout,
            )
            text = _extract_text_response(response)
            _emit_metrics(
                ok=bool(text),
                attempt=attempt,
                elapsed_ms=round((time.monotonic() - start) * 1000),
            )
            return text or "I don't have an answer for that yet."
        except Exception as exc:  # pragma: no cover - provider edge cases
            logger.warning(
                "AI provider attempt %s/%s failed: %s", attempt, attempts, exc
            )
            if attempt >= attempts:
                logger.exception("AI provider call failed after retries")
                raise AiClientError("AI provider call failed") from exc
            time.sleep(config.retry_backoff * attempt)

    return "I'm not sure how to answer that yet."


# --------------------------------------------------------------------
# Action-specific helpers (generate title/excerpt/seo/tags/summarize/moderate)
# If OpenAI is unavailable or not configured, fallback to simple heuristics.
# --------------------------------------------------------------------


def _fallback_title(text: str) -> str:
    base = text.strip() or "Concise, compelling title"
    return base[:120]


def _fallback_excerpt(text: str) -> str:
    return (text.strip() or "Add a short summary.").split(".")[0][:200]


def _fallback_tags(text: str) -> List[str]:
    seeds = ["ai", "engineering", "product", "update", "announcement", "guide"]
    out = []
    text_lower = text.lower()
    for t in seeds:
        if t in text_lower and t not in out:
            out.append(t)
    return out[:5] or ["general"]


def _fallback_seo(text: str) -> str:
    return (text.strip() or "Actionable, keyword-rich description for this post.")[:150]


def _fallback_summary(text: str) -> str:
    return "Summary: " + (text.strip()[:240] or "Key points and takeaways.")


def _fallback_moderation(text: str) -> Dict[str, str]:
    lower = text.lower()
    toxic = any(w in lower for w in ["hate", "kill", "idiot"])
    score = 0.8 if toxic else 0.05
    return {"toxicity_score": score, "label": "high" if toxic else "low"}


def _call_openai_response(config: AiConfig, system_prompt: str, user_content: str) -> str:
    start = time.monotonic()
    if config.mock_mode:
        return _mock_response(user_content)

    client = _get_client(config)
    attempts = config.max_retries + 1
    for attempt in range(1, attempts + 1):
        try:
            response = client.responses.create(
                model=config.model,
                input=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_content},
                ],
                timeout=config.timeout,
            )
            text = _extract_text_response(response)
            _emit_metrics(
                ok=bool(text),
                attempt=attempt,
                elapsed_ms=round((time.monotonic() - start) * 1000),
            )
            return text
        except Exception as exc:
            logger.warning(
                "AI provider attempt %s/%s failed: %s", attempt, attempts, exc
            )
            if attempt >= attempts:
                return ""
            time.sleep(config.retry_backoff * attempt)
    return ""


def generate_title(text: str, user: User) -> str:
    try:
        config = _load_config()
        prompt = "Generate a concise, engaging blog post title:\n" + text
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, prompt)
        return result or _fallback_title(text)
    except Exception:
        return _fallback_title(text)


def generate_excerpt(text: str, user: User) -> str:
    try:
        config = _load_config()
        prompt = "Generate a 1-2 sentence summary/excerpt for this post:\n" + text
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, prompt)
        return result or _fallback_excerpt(text)
    except Exception:
        return _fallback_excerpt(text)


def generate_seo_description(text: str, user: User) -> str:
    try:
        config = _load_config()
        prompt = "Write an SEO meta description (max 150 chars):\n" + text
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, prompt)
        return result or _fallback_seo(text)
    except Exception:
        return _fallback_seo(text)


def suggest_tags(text: str, user: User) -> List[str]:
    try:
        config = _load_config()
        prompt = "Suggest up to 5 comma-separated tags for this post:\n" + text
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, prompt)
        if result:
            tags = [t.strip().lower() for t in result.split(",") if t.strip()]
            return tags[:5]
    except Exception:
        pass
    return _fallback_tags(text)


def summarize_text(text: str, user: User) -> str:
    try:
        config = _load_config()
        prompt = "Summarize the following content in 3 bullet points:\n" + text
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, prompt)
        return result or _fallback_summary(text)
    except Exception:
        return _fallback_summary(text)


def moderate_text(text: str, user: User) -> Dict[str, str]:
    try:
        config = _load_config()
        prompt = (
            "Assess the following text for toxicity/harm. "
            "Return 'low' or 'high' risk and a numeric toxicity score 0-1."
        )
        system = _build_system_prompt(user)
        result = _call_openai_response(config, system, f"{prompt}\n{text}")
        if result:
            lower = result.lower()
            label = "high" if "high" in lower else "low"
            score = "0.8" if label == "high" else "0.05"
            return {"toxicity_score": float(score), "label": label}
    except Exception:
        pass
    return _fallback_moderation(text)


# --------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------

def _extract_text_response(response) -> str:
    try:
        for output in response.output:
            for item in getattr(output, "content", []):
                if getattr(item, "type", "") == "output_text":
                    text = getattr(item, "text", "") or ""
                    return text.strip()
    except Exception:
        return ""
    return ""


def _mock_response(user_content: str) -> str:
    # Deterministic mock useful for tests and local dev without keys.
    snippet = (user_content or "").strip().split("\n")[0][:120]
    return f"[mock-ai] {snippet or 'No content provided.'}"


def _emit_metrics(*, ok: bool, attempt: int, elapsed_ms: int) -> None:
    try:
        logger.info(
            "ai.call",
            extra={
                "event": {
                    "ok": ok,
                    "attempt": attempt,
                    "elapsed_ms": elapsed_ms,
                }
            },
        )
    except Exception:
        # Metrics should never break the request flow
        return


--------------------------------------------
### FILE: apps\core\api.py
### SIZE: 1555 bytes
### HASH: 6CBD3523A8C73DB31089C3F3A7830CDEC2B694A840B1EE69C83A3FD08A3B2355

from __future__ import annotations

import logging
from typing import Any, Dict

from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.pagination import PageNumberPagination

logger = logging.getLogger(__name__)


class StandardResultsSetPagination(PageNumberPagination):
    page_size = 20
    page_size_query_param = "page_size"
    max_page_size = 100


class BaseAPIView(APIView):
    """
    Base API view with structured logging helpers and standard pagination.
    """

    pagination_class = StandardResultsSetPagination

    def log_event(self, level: str, message: str, **extra: Any) -> None:
        try:
            cid = getattr(getattr(self, "request", None), "correlation_id", None)
            logger.log(
                getattr(logging, level.upper(), logging.INFO),
                message,
                extra={"event": extra, "correlation_id": cid},
            )
        except Exception:
            return

    def paginate(self, queryset):
        paginator = self.pagination_class()
        page = paginator.paginate_queryset(queryset, self.request, view=self)
        return page, paginator

    def ok(self, data: Dict[str, Any] | None = None, status_code: int = status.HTTP_200_OK) -> Response:
        return Response({"ok": True, **(data or {})}, status=status_code)

    def error(self, error: str, status_code: int = status.HTTP_400_BAD_REQUEST) -> Response:
        return Response({"ok": False, "error": error}, status=status_code)


--------------------------------------------
### FILE: apps\core\apps.py
### SIZE: 726 bytes
### HASH: 1998C280D9D1AE9B0CEB127614888BAC55509D20D5A2367346FFAE7A6B73912F

from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.core"
    label = "core"
    verbose_name = "Core"

    def ready(self):
        """
        Core app initialization:
        - Safely clear the django.contrib.sites cache after registry load
        - Autodiscover signals or other startup modules
        """
        try:
            from django.contrib.sites.models import Site

            Site.objects.clear_cache()
        except Exception:
            pass

        # Auto-discover signals.py in submodules
        autodiscover_modules("signals")

--------------------------------------------
### FILE: apps\core\cache.py
### SIZE: 8067 bytes
### HASH: 6373E3B62AD89BB125A869B36D012CCBA21F31EE597657369146FF133CB1DB73

"""
apps.core.cache
===============

Enterprise-grade centralized cache utilities.

✔ Django 5.2+ / Python 3.12+
✔ Redis / LocMem / cluster cache compatible
✔ Multi-tenant safe: stable digested keys, namespace isolation
✔ Strict key normalization to prevent collisions
✔ Defensive invalidators (site + consent)
✔ Atomic get/set with fallback
"""

from __future__ import annotations

import hashlib
import logging
from typing import Any, Callable, Optional, TypeVar

from django.contrib.sites.models import Site
from django.core.cache import cache

logger = logging.getLogger(__name__)

_T = TypeVar("_T")

# =====================================================================
# KEY UTILITIES
# =====================================================================


def _namespaced_key(
    key: str,
    *,
    version: Optional[int] = None,
    namespace: Optional[str] = None,
) -> str:
    """
    Portable canonical key format.

    Example:
        _namespaced_key("user_session", version=3, namespace="auth")
        → "auth::user_session::v3"
    """
    key = (key or "").strip()
    ns = (namespace or "").strip()

    parts: list[str] = []
    if ns:
        parts.append(ns)
    parts.append(key)
    if version is not None:
        parts.append(f"v{int(version)}")
    return "::".join(parts)


def _digest_key(base: str) -> str:
    """
    Safe digest for long/unsafe keys (Redis + memcached-safe)
    Ensures namespacing cannot collide.
    """
    base = base.replace(" ", "").strip()
    digest = hashlib.sha256(base.encode("utf-8")).hexdigest()[:16]
    return f"{base[:32]}::{digest}"


# =====================================================================
# DISTRIBUTED CACHE MANAGER
# =====================================================================


class DistributedCacheManager:
    """
    High-reliability cache manager for multi-site deployments.
    All operations are fully defensive (never crash).
    """

    # ------------------------------------------------------------------
    # Pattern deletes (Redis-only or custom backends)
    # ------------------------------------------------------------------
    @staticmethod
    def safe_delete_pattern(pattern: str) -> None:
        """
        Delete keys matching pattern (if backend supports it).
        """
        try:
            if hasattr(cache, "delete_pattern"):
                cache.delete_pattern(pattern)
                logger.debug("Pattern delete: %s", pattern)
            else:
                logger.debug("Backend lacks delete_pattern (pattern=%s)", pattern)
        except Exception as exc:
            logger.debug("delete_pattern failed (%s → %s)", pattern, exc)

    # ------------------------------------------------------------------
    # SITE SETTINGS INVALIDATION
    # ------------------------------------------------------------------
    @staticmethod
    def invalidate_site_settings(site_id: Optional[int] = None) -> None:
        """
        Invalidate all cache entries for site settings.

        This implementation is fully aligned with:
        - context processor key scheme
        - multi-tenant domain hashing
        """
        try:
            # Remove legacy global key
            try:
                cache.delete("active_site_settings")
            except Exception:
                pass

            # Remove new hashed-domain keys (pattern)
            DistributedCacheManager.safe_delete_pattern("active_site_settings_*")

            # Remove site-specific numeric key
            if site_id is not None:
                try:
                    cache.delete(f"site_settings_{site_id}")
                except Exception:
                    pass

            # Defensive enumeration (non-fatal)
            try:
                for s in Site.objects.only("id"):
                    try:
                        cache.delete(f"site_settings_{s.id}")
                    except Exception:
                        pass
            except Exception:
                pass

            logger.info("Site settings cache invalidated (site_id=%s)", site_id)

        except Exception as exc:
            logger.error("invalidate_site_settings failed → %s", exc)

    # ------------------------------------------------------------------
    # CONSENT POLICY INVALIDATION
    # ------------------------------------------------------------------
    @staticmethod
    def invalidate_consent_policy(site_identifier: Optional[str] = None) -> None:
        """
        Invalidate consent policy caches with full pattern-safe cleanup.
        """
        try:
            ident = (site_identifier or "global").strip().lower()
            digest_key = _digest_key(f"active_consent_policy::{ident}")

            # exact delete
            try:
                cache.delete(digest_key)
            except Exception:
                pass

            # legacy
            try:
                cache.delete("active_consent_policy")
            except Exception:
                pass

            # pattern cleanup
            DistributedCacheManager.safe_delete_pattern("active_consent_policy_*")

            logger.info("ConsentPolicy cache invalidated (identifier=%s)", ident)

        except Exception as exc:
            logger.error("invalidate_consent_policy failed → %s", exc)

    # ------------------------------------------------------------------
    # ATOMIC GET / SET WITH FALLBACK
    # ------------------------------------------------------------------
    @staticmethod
    def get_with_coherence(
        key: str,
        fallback_func: Callable[[], _T],
        *,
        timeout: int = 300,
        version: Optional[int] = None,
        namespace: Optional[str] = None,
    ) -> Optional[_T]:
        """
        Atomic get-or-compute with digest-safe keys.

        • Uses get_or_set when available (atomic)
        • Falls back to manual get → compute → set
        • Never raises exceptions
        """
        try:
            namespaced = _namespaced_key(key, version=version, namespace=namespace)
            cache_key = _digest_key(namespaced)

            # Preferred atomic path
            if hasattr(cache, "get_or_set"):
                try:
                    val = cache.get_or_set(cache_key, fallback_func, timeout=timeout)
                    logger.debug("get_or_set OK (%s)", cache_key)
                    return val
                except Exception:
                    logger.debug("get_or_set failed → manual fallback")

            # Manual path
            try:
                existing = cache.get(cache_key)
                if existing is not None:
                    logger.debug("Cache HIT (%s)", cache_key)
                    return existing
            except Exception:
                logger.debug("Cache.get failed for %s", cache_key)

            logger.debug("Cache MISS (%s) — computing fallback", cache_key)
            val = fallback_func()

            # Race-safe: try add() before set()
            try:
                added = False
                if hasattr(cache, "add"):
                    added = cache.add(cache_key, val, timeout=timeout)
                if not added:
                    cache.set(cache_key, val, timeout=timeout)
                logger.debug("Stored (%s, added=%s)", cache_key, added)
            except Exception:
                logger.debug("Cache set/add failed (%s)", cache_key)

            return val

        except Exception as exc:
            logger.warning("Cache coherence failure (%s)", exc)
            try:
                return fallback_func()
            except Exception as inner:
                logger.error("Fallback compute failed → %s", inner)
                return None


# Legacy alias for compatibility
CacheManager = DistributedCacheManager

--------------------------------------------
### FILE: apps\core\context_processors.py
### SIZE: 11529 bytes
### HASH: D7AA75C3E8724CB43E7D77381692F59F6A13D0DC15B7DDE93B80001747DC828B

"""
apps.core.context_processors
----------------------------
Enterprise-grade context processors.

Goals:
 - Lazy imports for startup/migration safety
 - Fully defensive (never break template rendering)
 - Zero branding (generic defaults)
 - Works seamlessly with new site_settings context processor (from apps.site_settings)
 - Hardened region detection + provider resolution
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from django.conf import settings
from django.http import HttpRequest

logger = logging.getLogger(__name__)


# =====================================================================
# SITE SETTINGS (LIGHT SNAPSHOT)
# =====================================================================
def site_settings_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Lightweight supplemental settings for templates.
    NOTE:
        Full site settings come from the main context processor:
        → apps.site_settings.context_processor.site_settings
        This function ONLY adds small frequently-used fields and never duplicates logic.
    """

    s = None
    # 1. Safe, lazy lookup for the model instance
    try:
        # Check for model existence defensively
        from apps.site_settings.models import SiteSettings

        if hasattr(SiteSettings, "get_solo"):
            s = SiteSettings.get_solo()
        else:
            s = SiteSettings.objects.first()
    except Exception as exc:
        # This occurs if the app/model is not installed or migrations haven't run
        logger.debug("SiteSettings lookup skipped/failed: %s", exc)
        pass # s remains None

    # 2. Extract values or use defensive defaults
    return {
        "site_theme": {
            "primary_color": getattr(s, "primary_color", "#0d6efd"),
            "secondary_color": getattr(s, "secondary_color", "#6c757d"),
        },
        "site_settings_light": {
            "site_name": getattr(s, "site_name", "Site"),  # no branding
            "enable_signup": bool(getattr(s, "enable_signup", True)),
            # Use getattr with a safe fallback to prevent exceptions
            "recaptcha_site_key": getattr(s, "recaptcha_public_key", "") or "",
            "show_consent_banner": bool(getattr(s, "enable_notifications", False)),
        },
    }


# =====================================================================
# SOCIAL PROVIDER SELECTION (LOCATION AWARE)
# =====================================================================
def location_based_providers(request: HttpRequest) -> Dict[str, Any]:
    """
    Returns providers suggested for the user's region, filtered by site's enabled providers.

    Output:
        {
            "location_based_providers": [...],
            "user_region": "...",
            "all_enabled_providers": [...],
        }
    """
    enabled_providers: List[str] = []

    # -----------------------------------------------------------------------------
    # Lazy import allauth only if installed
    # -----------------------------------------------------------------------------
    try:
        from allauth.socialaccount.models import SocialApp  # type: ignore
        from django.contrib.sites.models import Site  # type: ignore

        try:
            current_site = Site.objects.get_current()
        except Exception as exc:
            logger.debug("Site.get_current() failed: %s", exc)
            current_site = None

        try:
            if current_site:
                enabled_providers = list(
                    SocialApp.objects.filter(sites=current_site).values_list(
                        "provider", flat=True
                    )
                )
            else:
                # Fallback query for single-site setups if get_current fails defensively
                enabled_providers = list(
                    SocialApp.objects.values_list("provider", flat=True)
                )
        except Exception as exc:
            logger.debug("SocialApp query failed: %s", exc)
            enabled_providers = []

    except Exception:
        # If allauth or sites not installed → gracefully degrade
        enabled_providers = []

    # -----------------------------------------------------------------------------
    # Region detection
    # -----------------------------------------------------------------------------
    try:
        user_region = detect_user_region(request)
    except Exception as exc:
        logger.debug("detect_user_region failed: %s", exc)
        user_region = "global"

    # -----------------------------------------------------------------------------
    # Region → provider mapping
    # -----------------------------------------------------------------------------
    region_map = getattr(settings, "LOCATION_BASED_PROVIDERS", {}) or {}
    preferred_list = region_map.get(user_region, []) or []

    if not preferred_list:
        preferred_list = getattr(settings, "DEFAULT_SOCIAL_PROVIDERS", ["google"])

    # filter down to those enabled on the site
    try:
        # Ensure we only show providers that are configured AND are in the preferred list
        available = (
            [p for p in preferred_list if p in enabled_providers]
            if enabled_providers
            else preferred_list
        )
        
        # FINAL SANITY CHECK: If the resulting list is empty, fall back to all enabled providers
        if not available and enabled_providers:
            available = enabled_providers
            
    except Exception:
        available = preferred_list

    return {
        "location_based_providers": available,
        "user_region": user_region,
        "all_enabled_providers": enabled_providers,
    }


# =====================================================================
# REGION DETECTION
# =====================================================================
def detect_user_region(request: HttpRequest) -> str:
    """
    Hierarchical region detection:
        1) user preference (if authenticated)
        2) GeoIP (if available)
        3) Accept-Language header
        4) fallback = "global"
    """

    try:
        user = getattr(request, "user", None)
        if getattr(user, "is_authenticated", False):
            # Assumes the custom User model has a 'preferred_region' field
            pref = getattr(user, "preferred_region", None)
            if pref:
                return str(pref)
    except Exception:
        pass

    try:
        geo_region = _detect_region_via_geoip(request)
        if geo_region:
            return geo_region
    except Exception:
        pass

    try:
        lang_region = _detect_region_via_language(request)
        if lang_region:
            return lang_region
    except Exception:
        pass

    return "global"


# =====================================================================
# GEOIP REGION
# =====================================================================
def _detect_region_via_geoip(request: HttpRequest) -> Optional[str]:
    try:
        geoip_paths_configured = (
            getattr(settings, "GEOIP_PATH", None) or
            getattr(settings, "GEOIP_COUNTRY", None) or
            getattr(settings, "GEOIP_CITY", None)
        )
        if not geoip_paths_configured:
            return None

        try:
            from django.contrib.gis.geoip2 import GeoIP2  # type: ignore
        except Exception as exc:
            logger.debug("GeoIP2 unavailable (dependency missing): %s", exc)
            return None

        ip = _get_client_ip(request)
        if not ip or ip in ("127.0.0.1", "::1"): # Handle both IPv4 and IPv6 localhost
            return None

        try:
            g = GeoIP2()
            country = g.country_code(ip)
        except Exception as exc:
            logger.debug("GeoIP failure for %s: %s", ip, exc)
            return None

        if not country:
            return None

        region_map = getattr(settings, "COUNTRY_TO_REGION_MAP", None) or {}
        # Return region from map, or None if no region map entry exists
        return region_map.get(country, None)

    except Exception as exc:
        logger.debug("_detect_region_via_geoip unexpected error: %s", exc)
        return None


# =====================================================================
# LANGUAGE REGION
# =====================================================================
def _detect_region_via_language(request: HttpRequest) -> Optional[str]:
    try:
        header = request.META.get("HTTP_ACCEPT_LANGUAGE", "") or ""
        if not header:
            return None

        # Extract only the language part (e.g., 'en' from 'en-US,en;q=0.9')
        primary_lang = header.split(",")[0].split(";")[0].split("-")[0].lower()
        if not primary_lang:
            return None

        mapping = getattr(settings, "LANGUAGE_TO_REGION_MAP", None) or {
            "en": "global",
            "ar": "middle_east",
            "zh": "china",
            "ja": "asia",
            "ko": "asia",
            "ru": "russia",
            "de": "europe",
            "fr": "europe",
            "es": "europe",
            "it": "europe",
        }

        # Return specific region or fall back to "global" if language is unrecognized
        return mapping.get(primary_lang, "global")

    except Exception as exc:
        logger.debug("_detect_region_via_language failed: %s", exc)
        return None


# =====================================================================
# IP EXTRACTION (HARDENED)
# =====================================================================
def _get_client_ip(request: HttpRequest) -> str:
    """
    Hardened IP extraction logic, respecting proxy headers and settings.
    """
    try:
        # NOTE: SECURE_PROXY_SSL_HEADER is often used to determine if the request is secure
        # but the common practice for getting the client IP is via X-Forwarded-For or X-Real-IP.
        
        # 1. Check standard proxy header X-Forwarded-For (most common for load balancers)
        # Trust only the *first* IP in the list (the actual client).
        fwd = request.META.get("HTTP_X_FORWARDED_FOR")
        if fwd:
            return fwd.split(",")[0].strip()
        
        # 2. Check for Real IP header (e.g., Nginx, Cloudflare)
        real_ip = request.META.get("HTTP_X_REAL_IP")
        if real_ip:
            return real_ip.strip()

        # 3. Fallback to Django's native address
        return request.META.get("REMOTE_ADDR", "127.0.0.1") or "127.0.0.1"
    
    except Exception:
        # Never fail on IP extraction
        return "127.0.0.1"


# =====================================================================
# CORE CONTEXT
# =====================================================================
def core_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Small, safe global flags for templates.
    """
    return {
        "DEBUG": getattr(settings, "DEBUG", False),
        "ENV": getattr(settings, "ENV", "production"),
        # Use SITE_ID from settings, fallback to 1
        "SITE_ID": getattr(settings, "SITE_ID", 1), 
        "TIME_ZONE": getattr(settings, "TIME_ZONE", "UTC"),
    }

--------------------------------------------
### FILE: apps\core\exceptions.py
### SIZE: 6697 bytes
### HASH: 672127167534EF22B192F4C2417A274AA44B259CF7C2ACC0E157B4C48D795232

"""
apps.core.exceptions
====================

Enterprise-grade unified exception handling.

✓ Django 5.2 / Python 3.12+
✓ Async-safe, JSON + HTML aware
✓ Hardened against info disclosure
✓ DRF-compatible (wired via REST_FRAMEWORK.EXCEPTION_HANDLER)
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist, PermissionDenied, ValidationError
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.utils.translation import gettext_lazy as _

# -------------------------------------------------------------
# Optional DRF imports — explicit, safe, no broad try/except
# -------------------------------------------------------------
AuthenticationFailed = None
APIException = None

try:
    from rest_framework.exceptions import APIException as _APIException
    from rest_framework.exceptions import AuthenticationFailed as _AuthFailed

    AuthenticationFailed = _AuthFailed
    APIException = _APIException
except ImportError:
    # DRF not installed — these remain None (safe)
    pass

log = logging.getLogger(__name__)


# ============================================================
#  Utility helpers
# ============================================================
def _is_json_request(request: Optional[HttpRequest]) -> bool:
    """Detect JSON or AJAX requests for correct response type."""
    if not request:
        return False

    content_type = (request.content_type or "").lower()

    return (
        request.headers.get("x-requested-with") == "XMLHttpRequest"
        or content_type.startswith("application/json")
        or content_type.endswith("+json")
    )


def json_error_response(
    exc: Exception,
    code: int = 500,
    request: Optional[HttpRequest] = None,
) -> JsonResponse:
    """
    Hardened JSON error response.
    Internal exception details are hidden when DEBUG=False.
    """
    message = str(exc) if settings.DEBUG else _("Internal server error")

    return JsonResponse(
        {
            "ok": False,
            "error": message,
            "type": exc.__class__.__name__,
            "status": code,
        },
        status=code,
        json_dumps_params={"ensure_ascii": False},
    )


# ============================================================
#  Django / DRF unified exception handler
# ============================================================
class EnterpriseExceptionHandler:
    """
    Centralized handler for Django + DRF errors.

    Enable using:

        REST_FRAMEWORK = {
            "EXCEPTION_HANDLER": "apps.core.exceptions.EnterpriseExceptionHandler.handle_api_exception"
        }
    """

    @staticmethod
    def handle_api_exception(
        exc: Exception,
        context: Optional[dict[str, Any]] = None,
    ) -> JsonResponse:
        request = context.get("request") if context else None
        status_code: int
        response_data: dict[str, Any]

        # ------------------------------------------
        # Authentication / Permissions
        # ------------------------------------------
        if isinstance(exc, (PermissionDenied, AuthenticationFailed)):
            status_code = 401
            response_data = {
                "ok": False,
                "error": "authentication_failed",
                "message": _("Invalid credentials or insufficient permissions."),
            }

        # ------------------------------------------
        # Validation
        # ------------------------------------------
        elif isinstance(exc, ValidationError):
            status_code = 400
            details = getattr(exc, "message_dict", None) or str(exc)
            response_data = {
                "ok": False,
                "error": "validation_failed",
                "details": details,
            }

        # ------------------------------------------
        # Missing objects
        # ------------------------------------------
        elif isinstance(exc, ObjectDoesNotExist):
            status_code = 404
            response_data = {
                "ok": False,
                "error": "not_found",
                "message": _("Requested resource was not found."),
            }

        # ------------------------------------------
        # DRF base exceptions (ParseError, NotAuthenticated, etc.)
        # ------------------------------------------
        elif APIException and isinstance(exc, APIException):
            status_code = getattr(exc, "status_code", 500)
            response_data = {
                "ok": False,
                "error": getattr(exc, "default_code", "api_exception"),
                "message": str(getattr(exc, "detail", exc)),
            }

        # ------------------------------------------
        # Unhandled error (safe fallback)
        # ------------------------------------------
        else:
            log.exception("Unhandled exception occurred", exc_info=True)
            status_code = 500
            response_data = {
                "ok": False,
                "error": "internal_error",
                "message": (
                    f"{exc.__class__.__name__}: {exc}"
                    if settings.DEBUG
                    else _("An unexpected error occurred.")
                ),
            }

        return JsonResponse(
            response_data,
            status=status_code,
            json_dumps_params={
                "ensure_ascii": False,
                "indent": 2 if settings.DEBUG else None,
            },
        )


# ============================================================
#  Synchronous Django view fallback (non-DRF)
# ============================================================
def handle_view_exception(
    request: HttpRequest,
    exc: Exception,
    code: int = 500,
) -> HttpResponse:
    """
    Generic handler for standard Django views.
    Returns JSON for AJAX/JSON requests; otherwise text/plain.
    """
    # Only include traceback info when DEBUG=True (safe)
    log.warning("View exception caught: %s", exc, exc_info=settings.DEBUG)

    if _is_json_request(request):
        return json_error_response(exc, code=code, request=request)

    message = (
        f"{exc.__class__.__name__}: {exc}"
        if settings.DEBUG
        else _("Internal server error")
    )

    return HttpResponse(
        message,
        status=code,
        content_type="text/plain; charset=utf-8",
    )

--------------------------------------------
### FILE: apps\core\middleware\correlation.py
### SIZE: 790 bytes
### HASH: 949BBEF9CA1881BF41BD8B279D41AFAB76567613BC4E45853D093CAB09E81FBA

import logging
import uuid
from typing import Callable

from django.http import HttpRequest, HttpResponse

logger = logging.getLogger(__name__)


class CorrelationIdMiddleware:
    """
    Adds a per-request correlation ID for traceability across logs.
    """

    header_name = "X-Request-ID"

    def __init__(self, get_response: Callable[[HttpRequest], HttpResponse]):
        self.get_response = get_response

    def __call__(self, request: HttpRequest) -> HttpResponse:
        correlation_id = (
            request.META.get(self.header_name.replace("-", "_").upper())
            or str(uuid.uuid4())
        )
        request.correlation_id = correlation_id
        response = self.get_response(request)
        response[self.header_name] = correlation_id
        return response


--------------------------------------------
### FILE: apps\core\middleware\rate_limit_bridge.py
### SIZE: 1523 bytes
### HASH: 6E8E89D5B873DCAA1D8535C6ACAFC19883B6C5E6A3F58057053DB01AEA9223BC

"""
apps.core.middleware.rate_limit_bridge
--------------------------------------
Bridges Django requests to apps.users.services.rate_limit.allow_action().
Prevents brute-force login/signup attempts globally.
"""

import logging

from apps.users.services import rate_limit
from django.http import JsonResponse

logger = logging.getLogger(__name__)


class RateLimitMiddleware:
    """Attach global rate limit for login/signup endpoints."""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        path = request.path.lower()

        if "login" in path or "signup" in path:
            client_ip = self._get_client_ip(request)
            key = f"auth:{client_ip}:{path}"

            # 10 attempts / 5 minutes window
            allowed = rate_limit.allow_action(key, max_attempts=10, window_seconds=300)
            if not allowed:
                logger.warning(f"Rate limit exceeded for {client_ip} at {path}")
                return JsonResponse(
                    {
                        "error": "Too many attempts. Please wait a few minutes before retrying."
                    },
                    status=429,
                )

        return self.get_response(request)

    @staticmethod
    def _get_client_ip(request):
        xff = request.META.get("HTTP_X_FORWARDED_FOR")
        if xff:
            return xff.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "unknown")

--------------------------------------------
### FILE: apps\core\middleware\request_meta.py
### SIZE: 2622 bytes
### HASH: A6C107165E0CDB3E2D9C58CD27B2D5911AD7D19566300D0A5100F3FA847CFB83

"""
apps.core.middleware.request_meta
---------------------------------
Enterprise-grade request metadata middleware for GSMInfinity.

- Fully compatible with Django 5.2+
- Async + sync safe (modern middleware)
- Captures site, client IP, and user agent with fallbacks
- Normalizes headers for proxies/load balancers (X-Forwarded-For)
- Adds request.origin and request.scheme_normalized helpers
"""

from __future__ import annotations

import logging
from typing import Callable

from django.contrib.sites.shortcuts import get_current_site
from django.http import HttpRequest, HttpResponse

logger = logging.getLogger(__name__)


class RequestMetaMiddleware:
    """Attach normalized request metadata to every request safely."""

    def __init__(self, get_response: Callable[[HttpRequest], HttpResponse]):
        self.get_response = get_response

    def __call__(self, request: HttpRequest) -> HttpResponse:
        """
        Populate request attributes:
          - site_domain / site_name (from django.contrib.sites)
          - client_ip (honoring proxy headers)
          - user_agent
          - origin (for CORS/security logging)
          - scheme_normalized ("http"/"https")
        """
        self._attach_metadata(request)
        return self.get_response(request)

    def _attach_metadata(self, request: HttpRequest) -> None:
        # Site resolution with safe fallback
        try:
            site = get_current_site(request)
            request.site_domain = getattr(site, "domain", None) or request.get_host()
            request.site_name = getattr(site, "name", "") or request.site_domain
        except Exception as exc:
            logger.debug("RequestMetaMiddleware: site resolution failed - %s", exc)
            request.site_domain = request.get_host()
            request.site_name = request.site_domain

        # Determine client IP (handles X-Forwarded-For safely)
        xff = request.META.get("HTTP_X_FORWARDED_FOR")
        if xff:
            request.client_ip = xff.split(",")[0].strip()
        else:
            request.client_ip = request.META.get("REMOTE_ADDR", "")

        # Capture user agent
        request.user_agent = request.META.get("HTTP_USER_AGENT", "")

        # Origin & scheme helpers
        request.scheme_normalized = "https" if request.is_secure() else "http"
        request.origin = f"{request.scheme_normalized}://{request.get_host()}"

        logger.debug(
            "RequestMetaMiddleware attached - site=%s, ip=%s, ua=%s",
            request.site_domain,
            request.client_ip,
            (request.user_agent or "unknown")[:64],
        )


--------------------------------------------
### FILE: apps\core\middleware\security_headers.py
### SIZE: 3614 bytes
### HASH: 693D90C46BA893753BEADA6CC66621274C7E156D071CE06C02D3BA872DB8732D

"""
apps.core.middleware.security_headers
====================================

Enterprise-grade security header middleware.

✅ Django 5.2+ / Python 3.12+
✅ Per-request CSP nonces (no 'unsafe-inline')
✅ Compatible with modern browsers / COOP / CORP
✅ Minimal overhead (nonce generated once per request)
✅ Logging-aware, no silent leaks
"""

from __future__ import annotations

import logging
import secrets
from typing import Callable

from django.conf import settings
from django.http import HttpRequest, HttpResponse

logger = logging.getLogger(__name__)

DEFAULT_HSTS = "max-age=63072000; includeSubDomains; preload"
DEFAULT_COEP = "require-corp"
DEFAULT_CORP = "same-origin"


class SecurityHeadersMiddleware:
    """Attach enterprise-grade secure HTTP headers to each response."""

    def __init__(self, get_response: Callable[[HttpRequest], HttpResponse]):
        self.get_response = get_response
        self.hsts_value = getattr(settings, "SECURITY_HSTS_VALUE", DEFAULT_HSTS)
        self.coep_value = getattr(settings, "SECURITY_COEP_VALUE", DEFAULT_COEP)
        self.corp_value = getattr(settings, "SECURITY_CORP_VALUE", DEFAULT_CORP)
        # Log once at startup for visibility
        logger.info(
            "SecurityHeadersMiddleware initialized (DEBUG=%s)",
            getattr(settings, "DEBUG", False),
        )

    def __call__(self, request: HttpRequest) -> HttpResponse:
        # Create per-request nonce (used in inline scripts/styles if templates add it)
        nonce = secrets.token_urlsafe(16)
        setattr(request, "csp_nonce", nonce)

        response = self.get_response(request)

        # ------------------------------------------------------------------
        # Core modern security headers
        # ------------------------------------------------------------------
        response["X-Content-Type-Options"] = "nosniff"
        response["X-Frame-Options"] = "DENY"
        response["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response["Cross-Origin-Opener-Policy"] = "same-origin"
        response["Cross-Origin-Resource-Policy"] = self.corp_value
        response["Cross-Origin-Embedder-Policy"] = self.coep_value
        response["Permissions-Policy"] = (
            "geolocation=(), microphone=(), camera=(), payment=()"
        )

        # ------------------------------------------------------------------
        # Content Security Policy
        # ------------------------------------------------------------------
        # Nonce-based CSP even in DEBUG to discourage inline/eval
        csp = (
            "default-src 'self'; "
            f"script-src 'self' 'nonce-{nonce}' https://www.google.com/recaptcha/ "
            f"https://www.gstatic.com/recaptcha/; "
            f"style-src 'self' 'nonce-{nonce}' https://cdn.jsdelivr.net; "
            "img-src 'self' data: https:; "
            "connect-src 'self' ws: wss:; "
            "frame-src 'self' https://www.google.com/recaptcha/;"
        )

        response.setdefault("Content-Security-Policy", csp)

        # ------------------------------------------------------------------
        # Strict-Transport-Security (HSTS)
        # ------------------------------------------------------------------
        if not getattr(settings, "DEBUG", False) and self.hsts_value:
            is_secure = request.is_secure()
            xfp = request.META.get("HTTP_X_FORWARDED_PROTO", "")
            if is_secure or xfp.startswith("https"):
                response["Strict-Transport-Security"] = self.hsts_value

        return response


--------------------------------------------
### FILE: apps\core\middleware\ssl_toggle.py
### SIZE: 2711 bytes
### HASH: 96E42F45ED883F05E679006E901005AA907BFF1478360A800D5A14969050805A

# apps/core/middleware/ssl_toggle.py
"""
apps/core/middleware/ssl_toggle
===============================
Dynamic HTTPS enforcement driven by SiteSettings.force_https with safe dev defaults.
"""

from __future__ import annotations

import logging
import os
from typing import Optional

from django.conf import settings
from django.http import HttpRequest, HttpResponse, HttpResponseRedirect

logger = logging.getLogger(__name__)


def _should_force_https() -> bool:
    """
    Runtime-safe evaluation of SiteSettings.force_https.

    - Returns False on any import/config errors.
    - Can be overridden via the env var FORCE_HTTPS_DEV_OVERRIDE=0.
    """
    override = os.getenv("FORCE_HTTPS_DEV_OVERRIDE")
    if override is not None and override.strip().lower() in ("0", "false", "off", "no"):
        return False

    try:
        from apps.site_settings.models import SiteSettings  # local import

        settings_obj = SiteSettings.get_solo()
        return bool(getattr(settings_obj, "force_https", False))
    except Exception as exc:
        logger.debug("[SslToggle] Fallback to HTTP: %s", exc)
        return False


class SslToggleMiddleware:
    """
    Middleware to redirect HTTP -> HTTPS only when:
      1. The current request is insecure, AND
      2. SiteSettings.force_https == True, AND
      3. FORCE_HTTPS_DEV_OVERRIDE is not disabling enforcement, AND
      4. settings.DEBUG is False.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request: HttpRequest) -> HttpResponse:
        redirect_response = self._maybe_redirect(request)
        if redirect_response is not None:
            return redirect_response
        return self.get_response(request)

    def _maybe_redirect(self, request: HttpRequest) -> Optional[HttpResponse]:
        # Never interfere with local/dev debugging
        try:
            if getattr(settings, "DEBUG", False):
                return None
        except Exception:
            # If settings is weirdly inaccessible, fail open.
            return None

        # Already secure -> nothing to do
        if request.is_secure():
            return None

        # Respect SiteSettings + env override
        if not _should_force_https():
            return None

        # Only redirect idempotent methods (avoid breaking POST/PUT forms)
        if request.method not in ("GET", "HEAD"):
            return None

        # Build HTTPS URL preserving path + querystring
        host = request.get_host()
        path = request.get_full_path()
        url = f"https://{host}{path}"

        logger.debug("[SslToggle] Redirecting to HTTPS: %s", url)
        return HttpResponseRedirect(url)


--------------------------------------------
### FILE: apps\core\models.py
### SIZE: 1705 bytes
### HASH: 7D25EE41C5346F99411949C991462ABC419DBBC9EA9850F89DA52196DAD86B1B

from django.conf import settings
from django.db import models


class TimestampedModel(models.Model):
    """
    Minimal timestamp mixin for models that do not need soft-delete/audit.
    """

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


class SoftDeleteModel(models.Model):
    """
    Soft-delete abstraction (opt-in per concrete model).
    """

    is_deleted = models.BooleanField(default=False, db_index=True)
    deleted_at = models.DateTimeField(null=True, blank=True)
    deleted_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="%(class)s_deleted",
    )

    class Meta:
        abstract = True

    def soft_delete(self, user=None, commit: bool = True) -> None:
        self.is_deleted = True
        self.deleted_at = models.functions.Now()
        if user and not self.deleted_by:
            self.deleted_by = user
        if commit:
            self.save(update_fields=["is_deleted", "deleted_at", "deleted_by"])


class AuditFieldsModel(models.Model):
    """
    Adds created_by / updated_by without forcing concrete relations to use them.
    """

    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="%(class)s_created",
    )
    updated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="%(class)s_updated",
    )

    class Meta:
        abstract = True


--------------------------------------------
### FILE: apps\core\tests.py
### SIZE: 61 bytes
### HASH: 16BD2BFAA5A5193DBE66207AF62D6B157D55F883C23F32F344103BCF9BB7C506

from django.test import TestCase

# Create your tests here.

--------------------------------------------
### FILE: apps\core\urls.py
### SIZE: 3267 bytes
### HASH: 7698862C5AE9521E296CFB70FE5FB0C8978C337096AC054C427E99DE1CE8669B

# apps/core/urls.py
"""
GSMInfinity — Core URL Configuration (Enterprise-Grade)
========================================================
Features:
- Full Django 5.2+ compliance (no deprecated APIs)
- Lazy view loading with import_string (prevents circular imports)
- Explicit namespacing for reverse() lookups
- Legal and policy page aliases for seamless frontend template integration
- Fully aligned with apps.core.views and apps.site_settings.views

Namespace: "core"
"""

from typing import Any, Callable

from django.urls import path
from django.utils.module_loading import import_string


# ----------------------------------------------------------------------
# Lazy Import Utility
# ----------------------------------------------------------------------
def view(name: str) -> Callable[..., Any]:
    """
    Dynamically import a view function by its dotted name.

    Supports:
      - short names (e.g., "home") → imports apps.core.views.home
      - fully qualified names (e.g., "apps.site_settings.views.privacy_policy")
        → imports directly without namespacing

    This approach prevents circular imports and reduces startup time.
    """
    if "." in name and not name.startswith("apps.core.views"):
        return import_string(name)
    return import_string(f"apps.core.views.{name}")


# ----------------------------------------------------------------------
# Namespace Declaration
# ----------------------------------------------------------------------
app_name = "core"


# ----------------------------------------------------------------------
# URL Patterns
# ----------------------------------------------------------------------
urlpatterns = [
    # ---------------------------------------------------------------
    #  Public Home / Landing
    # ---------------------------------------------------------------
    path("", view("home"), name="home"),
    # ---------------------------------------------------------------
    #  Tenants (Multi-Site Overview)
    # ---------------------------------------------------------------
    path("tenants/", view("tenants"), name="tenants"),
    # ---------------------------------------------------------------
    #  Legal / Policy Page Aliases
    # ---------------------------------------------------------------
    # These aliases ensure existing templates referencing {% url 'privacy' %}
    # or {% url 'terms' %} continue to work seamlessly.
    # They map to canonical views in apps.site_settings.views.
    path("privacy/", view("apps.site_settings.views.privacy_policy"), name="privacy"),
    path("terms/", view("apps.site_settings.views.terms_of_service"), name="terms"),
    path("cookies/", view("apps.site_settings.views.cookies_policy"), name="cookies"),
]


# ----------------------------------------------------------------------
# Notes:
# - All paths are namespaced under "core" for explicit reverse() lookups:
#     {% url 'core:dashboard_overview' %}
#     {% url 'core:privacy' %}
# - For cross-app aliasing, dotted import paths are used safely.
# - No recursion, no deprecated include() nesting, 100% Django 5.2+ ready.
# ----------------------------------------------------------------------


--------------------------------------------
### FILE: apps\core\utils\feature_flags.py
### SIZE: 1537 bytes
### HASH: 8BDCAB4D9A460B99D40FD8FA434839F11F539EA4D5123AD114205EDE6F0C2D8D

from __future__ import annotations

import functools
from typing import Optional

from apps.site_settings.models import SiteSettings


@functools.lru_cache(maxsize=1)
def get_settings() -> Optional[SiteSettings]:
    """
    Small, process-local cache to avoid hitting the DB on every flag check.
    """
    try:
        return SiteSettings.get_solo()
    except Exception:
        return None


def seo_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "seo_enabled", False)) if ss else False


def ads_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "ads_enabled", False)) if ss else False


def affiliate_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "affiliate_enabled", False)) if ss else False


def auto_meta_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "auto_meta_enabled", False)) if ss else False


def auto_schema_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "auto_schema_enabled", False)) if ss else False


def auto_linking_enabled() -> bool:
    ss = get_settings()
    return bool(getattr(ss, "auto_linking_enabled", False)) if ss else False


def ad_aggressiveness() -> str:
    ss = get_settings()
    return getattr(ss, "ad_aggressiveness_level", "balanced") if ss else "balanced"


def reset_cache() -> None:
    """Used by signals/admin to clear process-local cache after updates."""
    try:
        get_settings.cache_clear()  # type: ignore[attr-defined]
    except Exception:
        return


--------------------------------------------
### FILE: apps\core\utils\logging.py
### SIZE: 1000 bytes
### HASH: 6BC264FD42D8C3E8851E84829617AA25A2430314BCD77FADA96FEE1144F3CC86

from __future__ import annotations

import logging
from typing import Any, Dict


def get_logger(name: str) -> logging.Logger:
    """
    Centralized logger factory to keep a consistent format across apps.
    """
    return logging.getLogger(name)


def log_event(logger: logging.Logger, level: str, message: str, **extra: Any) -> None:
    """
    Structured logging helper. Adds 'event' payload via `extra` without
    raising if the logger is misconfigured.
    """
    try:
        if level == "debug":
            logger.debug(message, extra={"event": extra})
        elif level == "info":
            logger.info(message, extra={"event": extra})
        elif level == "warning":
            logger.warning(message, extra={"event": extra})
        elif level == "error":
            logger.error(message, extra={"event": extra})
        else:
            logger.log(logging.INFO, message, extra={"event": extra})
    except Exception:
        # Never let logging break app flow
        return


--------------------------------------------
### FILE: apps\core\utils\sanitize.py
### SIZE: 953 bytes
### HASH: DDF258AF29A5E7481187DCD1B3BF2F1B924F4F6FD006736886B194A487BA69F5

from __future__ import annotations

import re
from typing import Any, Iterable

from django.utils.text import slugify as django_slugify

try:
    import bleach  # type: ignore
except Exception:  # pragma: no cover
    bleach = None


def slugify(value: str, allow_unicode: bool = False, max_length: int | None = None) -> str:
    slug = django_slugify(value, allow_unicode=allow_unicode)
    if max_length:
        slug = slug[:max_length]
    return slug


def sanitize_html(html: str, allowed_tags: Iterable[str] | None = None, allowed_attrs: dict[str, Any] | None = None) -> str:
    if not html:
        return ""
    if bleach is None:
        # fallback: strip tags by regex
        return re.sub(r"<[^>]+>", "", html)
    tags = allowed_tags or ["p", "br", "strong", "em", "ul", "ol", "li", "a", "code"]
    attrs = allowed_attrs or {"a": ["href", "title", "rel", "target"]}
    return bleach.clean(html, tags=tags, attributes=attrs, strip=True)


--------------------------------------------
### FILE: apps\core\views.py
### SIZE: 18199 bytes
### HASH: 163336BD6DCCBED940847AC364CC3D489DAA24609CBFA84E4DDF7077F8AF54A7

# apps/core/views.py
"""
Core views — Enterprise-grade, Django 5.2+ ready.

Hardened to:
 - never return async/coroutine objects
 - never leak errors from ORM calls in async event loops
 - return only serializable objects to templates
 - load only existing templates safely
 - provide fully brand-neutral, tenant-safe site settings snapshot
"""

from __future__ import annotations

import logging
import sys
from typing import Any, Dict, Iterable, List, Optional

import django
from django.core.cache import cache
from django.http import (
    Http404,
    HttpRequest,
    HttpResponse,
    HttpResponseServerError,
    JsonResponse,
)
from django.shortcuts import render
from django.template import TemplateDoesNotExist
from django.template.loader import get_template
from django.utils.timezone import now, timezone
from django.views.decorators.cache import never_cache
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required

logger = logging.getLogger(__name__)

# Snapshot cache keys
_SITE_SETTINGS_SNAPSHOT_KEY = "core_site_settings_snapshot_v1"
_SITE_SETTINGS_VERSION_KEY = "site_settings_version"

# Valid home templates
_HOME_TEMPLATE_PRIORITY: List[str] = ["home.html", "core/home.html"]
MAX_QUESTION_CHARS = 4_000


# ============================================================
# INTERNAL UTILITIES
# ============================================================
def _safe_count(q: Any) -> int:
    """Safe count for any queryset or iterable."""
    try:
        qs = q() if callable(q) else q
        if qs is None:
            return 0
        if hasattr(qs, "count"):
            return int(qs.count())
        return int(len(qs))
    except Exception as exc:
        logger.debug("_safe_count fallback 0: %s", exc)
        return 0


def _safe_iter(q: Any, limit: int = 5) -> list:
    """Safe slice/iteration over queryset or iterable."""
    try:
        qs = q() if callable(q) else q
        if qs is None:
            return []
        if hasattr(qs, "order_by"):
            return list(qs.order_by("-created_at")[:limit])
        return list(qs)[:limit]
    except Exception as exc:
        logger.debug("_safe_iter fallback empty: %s", exc)
        return []


# ============================================================
# SNAPSHOT OF SITE SETTINGS (BRAND-NEUTRAL)
# ============================================================
def _get_site_settings_snapshot() -> Dict[str, Any]:
    """
    Returns a fully serializable dict for templates.
    Never returns ORM objects and never raises.
    """

    # Versioned cache key
    try:
        version = cache.get(_SITE_SETTINGS_VERSION_KEY) or 0
        key = f"{_SITE_SETTINGS_SNAPSHOT_KEY}_v{version}"
    except Exception:
        key = _SITE_SETTINGS_SNAPSHOT_KEY

    # Load from cache
    try:
        payload = cache.get(key)
        if payload:
            return payload
    except Exception:
        payload = None

    # Build snapshot
    try:
        from apps.site_settings.models import SiteSettings  # type: ignore

        obj = (
            SiteSettings.get_solo()
            if hasattr(SiteSettings, "get_solo")
            else SiteSettings.objects.first()
        )

        payload = {
            "site_name": getattr(obj, "site_name", "Site"),
            "site_header": getattr(obj, "site_header", "Admin"),
            "site_description": getattr(obj, "site_description", ""),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "require_mfa": bool(getattr(obj, "require_mfa", False)),
            "maintenance_mode": bool(getattr(obj, "maintenance_mode", False)),
            # Feature toggles (admin controlled)
            "enable_tenants": bool(getattr(obj, "enable_tenants", False)),
            "enable_blog": bool(getattr(obj, "enable_blog", True)),
            "enable_blog_comments": bool(
                getattr(obj, "enable_blog_comments", True)
            ),
            "allow_user_blog_posts": bool(getattr(obj, "allow_user_blog_posts", False)),
            "allow_user_bounty_posts": bool(
                getattr(obj, "allow_user_bounty_posts", False)
            ),
            "primary_color": getattr(obj, "primary_color", "#0d6efd"),
            "secondary_color": getattr(obj, "secondary_color", "#6c757d"),
            "logo": (
                getattr(obj, "logo", None).url if getattr(obj, "logo", None) else None
            ),
            "dark_logo": (
                getattr(obj, "dark_logo", None).url
                if getattr(obj, "dark_logo", None)
                else None
            ),
            "favicon": (
                getattr(obj, "favicon", None).url
                if getattr(obj, "favicon", None)
                else None
            ),
        }
    except Exception as exc:
        logger.debug("site settings fallback: %s", exc)
        payload = {
            "site_name": "Site",
            "site_header": "Admin",
            "site_description": "",
            "enable_signup": True,
            "require_mfa": False,
            "maintenance_mode": False,
            "enable_tenants": False,
            "enable_blog": False,
            "enable_blog_comments": False,
            "primary_color": "#0d6efd",
            "secondary_color": "#6c757d",
            "logo": None,
            "dark_logo": None,
            "favicon": None,
        }

    try:
        cache.set(key, payload, timeout=300)
    except Exception:
        pass

    return payload


# ============================================================
# SAFE RENDERING WRAPPER
# ============================================================
def _render_safe(
    request: HttpRequest, template: str, context: Dict[str, Any], status: int = 200
) -> HttpResponse:
    """Completely safe render wrapper."""
    try:
        return render(request, template, context, status=status)
    except TemplateDoesNotExist as exc:
        logger.warning("Missing template: %s (%s)", template, exc)
        sn = (
            context.get("site_name")
            or context.get("site_settings", {}).get("site_name")
            or "Site"
        )
        return HttpResponse(
            f"<html><head><title>{sn}</title></head>"
            f"<body><h1>{sn}</h1><p>Content temporarily unavailable.</p></body></html>",
            status=status,
        )
    except Exception as exc:
        logger.exception("Render error for %s: %s", template, exc)
        return HttpResponseServerError("Internal server error")


def _first_existing_template(candidates: Iterable[str]) -> Optional[str]:
    """Pick first existing template (safe)."""
    for name in candidates:
        try:
            get_template(name)
            return name
        except TemplateDoesNotExist:
            continue
        except Exception:
            continue
    return None


# ============================================================
# HOME PAGE
# ============================================================
@never_cache
def home(request: HttpRequest) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()

    # Maintenance mode?
    if settings_snapshot.get("maintenance_mode"):
        return _render_safe(
            request,
            "errors/503.html",
            {
                "site_settings": settings_snapshot,
                "site_name": settings_snapshot.get("site_name"),
                "message": "This site is currently under maintenance.",
            },
            status=503,
        )

    # Query factories
    def _u():
        try:
            from apps.users.models import CustomUser  # type: ignore

            return CustomUser.objects.all()
        except Exception:
            return []

    def _d():
        try:
            from apps.users.models import DeviceFingerprint  # type: ignore

            return DeviceFingerprint.objects.filter(is_active=True)
        except Exception:
            return []

    def _n():
        try:
            from apps.users.models import Notification  # type: ignore

            if request.user.is_authenticated:
                return Notification.objects.filter(user=request.user, is_read=False)
            return Notification.objects.none()
        except Exception:
            return []

    def _a():
        try:
            from apps.users.models import Announcement  # type: ignore

            return Announcement.objects.filter(is_active=True)
        except Exception:
            return []

    # System info
    try:
        django_version = django.get_version()
    except Exception:
        django_version = "unknown"

    try:
        python_version = sys.version.split()[0]
    except Exception:
        python_version = "unknown"

    context = {
        "site_settings": settings_snapshot,
        "site_name": settings_snapshot.get("site_name"),
        "django_version": django_version,
        "python_version": python_version,
        "now": now(),
        "total_users": _safe_count(_u),
        "active_devices": _safe_count(_d),
        "unread_notifications": _safe_count(_n),
        "active_announcements": _safe_count(_a),
        "announcements": _safe_iter(_a, limit=5),
    }

    # Select homepage template
    template_name = _first_existing_template(_HOME_TEMPLATE_PRIORITY)
    if template_name:
        return _render_safe(request, template_name, context)

    # Ultimate fallback
    logger.error("No homepage template found among: %s", _HOME_TEMPLATE_PRIORITY)
    sn = context["site_name"]
    return HttpResponse(
        f"<html><head><title>{sn}</title></head>"
        f"<body><h1>{sn}</h1><p>Home page temporarily unavailable.</p></body></html>",
        status=503,
    )


# ============================================================
# TENANTS
# ============================================================
def tenants(request: HttpRequest) -> HttpResponse:
    # Gate tenants listing behind SiteSettings.enable_tenants
    try:
        from apps.site_settings.models import SiteSettings  # type: ignore

        ss = SiteSettings.get_solo()
        if not getattr(ss, "enable_tenants", False):
            raise Http404("Tenants listing is disabled.")
    except Http404:
        raise
    except Exception as exc:
        logger.debug("SiteSettings unavailable for tenants: %s", exc)
        raise Http404("Tenants listing is disabled.")

    try:
        from apps.site_settings.models import TenantSiteSettings  # type: ignore

        qs = TenantSiteSettings.objects.select_related("site").prefetch_related(
            "meta_tags", "verification_files"
        )
        tenants = list(qs.order_by("site__domain"))
    except Exception as exc:
        logger.debug("TenantSiteSettings unavailable: %s", exc)
        tenants = []

    return _render_safe(
        request,
        "core/tenants.html",
        {
            "site_settings": _get_site_settings_snapshot(),
            "tenants": tenants,
        },
    )


# ============================================================
# LEGAL PAGES
# ============================================================
def privacy(request: HttpRequest) -> HttpResponse:
    return _render_safe(
        request, "legal/privacy.html", {"site_settings": _get_site_settings_snapshot()}
    )


def terms(request: HttpRequest) -> HttpResponse:
    return _render_safe(
        request, "legal/terms.html", {"site_settings": _get_site_settings_snapshot()}
    )


def cookies(request: HttpRequest) -> HttpResponse:
    return _render_safe(
        request, "legal/cookies.html", {"site_settings": _get_site_settings_snapshot()}
    )


# ============================================================
# ERROR HANDLERS
# ============================================================
def error_400_view(
    request: HttpRequest, exception: Optional[Exception] = None
) -> HttpResponse:
    return _render_safe(
        request,
        "errors/400.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=400,
    )


def error_403_view(
    request: HttpRequest, exception: Optional[Exception] = None
) -> HttpResponse:
    return _render_safe(
        request,
        "errors/403.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=403,
    )


def error_404_view(
    request: HttpRequest, exception: Optional[Exception] = None
) -> HttpResponse:
    return _render_safe(
        request,
        "errors/404.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=404,
    )


def error_500_view(request: HttpRequest) -> HttpResponse:
    try:
        return _render_safe(
            request,
            "errors/500.html",
            {"site_settings": _get_site_settings_snapshot()},
            status=500,
        )
    except Exception:
        return HttpResponseServerError("Internal server error")


# ============================================================
# AI ASSISTANT ENDPOINT (Frontend widget)
# ============================================================
def _parse_json_body(request: HttpRequest, max_bytes: int = 64_000) -> dict:
    """Safe JSON body parser with size guard."""
    raw = request.body or b""
    if len(raw) > max_bytes:
        return {"__error__": "payload_too_large"}
    if not raw:
        return {}
    try:
        import json

        return json.loads(raw.decode("utf-8", errors="ignore"))
    except Exception:
        return {"__error__": "bad_json"}


def _enforce_ai_rate_limit(request: HttpRequest) -> Optional[JsonResponse]:
    """
    Optional per-view rate-limit hook. Integrate with middleware flags if present.
    Return a JsonResponse to short-circuit, or None to continue.
    """
    try:
        if getattr(request, "ai_rate_limited", False):
            return JsonResponse({"ok": False, "error": "rate_limited"}, status=429)

        # Simple per-session throttle: enforce a short cooldown between requests
        session = getattr(request, "session", None)
        if session is not None:
            if not session.session_key:
                session.save()
            last = session.get("ai_last_ts")
            now_ts = timezone.now().timestamp()
            if last and (now_ts - float(last)) < 3:  # 3-second cooldown
                return JsonResponse({"ok": False, "error": "rate_limited"}, status=429)
            session["ai_last_ts"] = now_ts
            session.modified = True

        # Per-user soft cap: 10 requests per minute
        user = getattr(request, "user", None)
        if user and getattr(user, "is_authenticated", False):
            key = f"ai_rl_user_{user.pk}"
            try:
                count = cache.get(key, 0)
                if count and int(count) >= 10:
                    return JsonResponse(
                        {"ok": False, "error": "rate_limited"}, status=429
                    )
                cache.set(key, int(count) + 1, timeout=60)
            except Exception:
                # Fail open if cache misbehaves
                pass
    except Exception:
        pass
    return None


@login_required
@require_POST
def ai_assistant_view(request: HttpRequest) -> JsonResponse:
    """
    Hardened AI assistant endpoint used by the frontend chat widget.

    Expects JSON: {"question": "<user question>"} or {"action": "generate_title", "payload": {...}}
    Returns: {"ok": true, "answer": "<assistant answer>"} or {"ok": false, "error": "..."}
    """
    payload = _parse_json_body(request)
    if payload.get("__error__"):
        return JsonResponse({"ok": False, "error": payload["__error__"]}, status=400)

    question = (payload.get("question") or "").strip()
    action = (payload.get("action") or "").strip()
    if not question and not action:
        return JsonResponse({"ok": False, "error": "empty_question"}, status=400)
    if question and len(question) > MAX_QUESTION_CHARS:
        return JsonResponse({"ok": False, "error": "question_too_long"}, status=400)

    rl_response = _enforce_ai_rate_limit(request)
    if rl_response is not None:
        return rl_response

    try:
        from apps.core import ai_client  # type: ignore

        if action:
            payload_text = ""
            try:
                payload_text = (payload.get("payload") or {}).get("text", "")
            except Exception:
                payload_text = ""
            if action == "generate_title":
                answer = ai_client.generate_title(payload_text or question, request.user)
            elif action == "generate_excerpt":
                answer = ai_client.generate_excerpt(payload_text or question, request.user)
            elif action == "generate_seo":
                answer = ai_client.generate_seo_description(payload_text or question, request.user)
            elif action == "suggest_tags":
                answer = ", ".join(ai_client.suggest_tags(payload_text or question, request.user))
            elif action in ("summarize", "summarize_comments"):
                answer = ai_client.summarize_text(payload_text or question, request.user)
            elif action == "moderate":
                answer = ai_client.moderate_text(payload_text or question, request.user)
            else:
                answer = f"AI action '{action}' processed."
        else:
            answer = ai_client.generate_answer(question=question, user=request.user)
    except Exception as exc:  # pragma: no cover - defensive logging
        logger.exception("ai_assistant_view failed: %s", exc)
        return JsonResponse(
            {
                "ok": False,
                "error": "ai_failure",
                "message": "Assistant is temporarily unavailable.",
            },
            status=503,
        )

    return JsonResponse({"ok": True, "answer": answer}, status=200)



--------------------------------------------
### FILE: apps\seo\__init__.py
### SIZE: 47 bytes
### HASH: B2E33B64209791D6040DFE93351304ED13AAA4C2678198FE2734CB6355E05665

default_app_config = "apps.seo.apps.SeoConfig"


--------------------------------------------
### FILE: apps\seo\admin.py
### SIZE: 1704 bytes
### HASH: 5A47618D6BF19BE50063DB48671DFC7C81A290137B859865BE40F1EE6994F691

from django.contrib import admin

from .models import (
    SEOModel,
    Metadata,
    SchemaEntry,
    SitemapEntry,
    Redirect,
    LinkableEntity,
    LinkSuggestion,
)


@admin.register(SEOModel)
class SEOModelAdmin(admin.ModelAdmin):
    list_display = ("content_type", "object_id", "locked", "ai_generated", "updated_at")
    list_filter = ("locked", "ai_generated")


@admin.register(Metadata)
class MetadataAdmin(admin.ModelAdmin):
    list_display = ("seo", "meta_title", "noindex", "nofollow", "updated_at")
    search_fields = ("meta_title", "meta_description", "focus_keywords")


@admin.register(SchemaEntry)
class SchemaEntryAdmin(admin.ModelAdmin):
    list_display = ("seo", "schema_type", "locked", "created_at")
    list_filter = ("schema_type", "locked")


@admin.register(SitemapEntry)
class SitemapEntryAdmin(admin.ModelAdmin):
    list_display = ("url", "is_active", "priority", "lastmod")
    list_filter = ("is_active",)
    search_fields = ("url",)


@admin.register(Redirect)
class RedirectAdmin(admin.ModelAdmin):
    list_display = ("source", "target", "is_permanent", "is_active", "created_at")
    list_filter = ("is_permanent", "is_active")
    search_fields = ("source", "target")


@admin.register(LinkableEntity)
class LinkableEntityAdmin(admin.ModelAdmin):
    list_display = ("title", "entity_type", "url", "is_active", "updated_at")
    list_filter = ("entity_type", "is_active")
    search_fields = ("title", "url", "keywords")


@admin.register(LinkSuggestion)
class LinkSuggestionAdmin(admin.ModelAdmin):
    list_display = ("source", "target", "score", "is_applied", "locked", "is_active", "created_at")
    list_filter = ("is_applied", "locked", "is_active")


--------------------------------------------
### FILE: apps\seo\apps.py
### SIZE: 241 bytes
### HASH: 7D36B453C6A612BE63FD2FF1539AAE63DCEBCD5483904B766BC58DA21A5DBF8E

from django.apps import AppConfig


class SeoConfig(AppConfig):
    name = "apps.seo"
    verbose_name = "SEO"

    def ready(self):
        try:
            import apps.seo.signals  # noqa: F401
        except Exception:
            return


--------------------------------------------
### FILE: apps\seo\management\commands\build_sitemap.py
### SIZE: 1238 bytes
### HASH: AFDE0287F0D4825EA5238DED7B2E28396B47056E49096779F51C4313033F2B2F

from __future__ import annotations

from django.core.management.base import BaseCommand
from django.utils import timezone
from django.contrib.sites.models import Site

from apps.seo.models import SitemapEntry
from apps.blog.models import Post, PostStatus


class Command(BaseCommand):
    help = "Builds sitemap entries from published blog posts."

    def handle(self, *args, **options):
        now = timezone.now()
        domain = getattr(Site.objects.get_current(), "domain", "")
        total = 0
        posts = Post.objects.filter(status=PostStatus.PUBLISHED)
        for p in posts:
            url = p.get_absolute_url() if hasattr(p, "get_absolute_url") else ""
            if domain and url.startswith("/"):
                url = f"https://{domain}{url}"
            if not url:
                continue
            SitemapEntry.objects.update_or_create(
                url=url,
                defaults={
                    "lastmod": p.updated_at or now,
                    "changefreq": "weekly",
                    "priority": 0.7,
                    "is_active": True,
                },
            )
            total += 1
        self.stdout.write(self.style.SUCCESS(f"Sitemap build complete. Entries: {total}"))


--------------------------------------------
### FILE: apps\seo\management\commands\check_links.py
### SIZE: 1359 bytes
### HASH: 41D3DC1561AABDE4FD0724527651F8E638653DD6FC632347090CAE15D9F5BA89

from __future__ import annotations

import urllib.request
from urllib.error import URLError, HTTPError

from django.core.management.base import BaseCommand
from django.utils import timezone

from apps.seo.models import SitemapEntry


class Command(BaseCommand):
    help = "Checks active sitemap entries for HTTP reachability."

    def handle(self, *args, **options):
        entries = SitemapEntry.objects.filter(is_active=True)
        ok = 0
        bad = 0
        for entry in entries:
            try:
                req = urllib.request.Request(entry.url, method="HEAD")
                with urllib.request.urlopen(req, timeout=5) as resp:
                    code = resp.getcode()
                    entry.last_status = code
                    entry.last_checked_at = timezone.now()
                    entry.save(update_fields=["last_status", "last_checked_at"])
                    if 200 <= code < 400:
                        ok += 1
                        continue
                bad += 1
            except (HTTPError, URLError, Exception):
                entry.last_status = 0
                entry.last_checked_at = timezone.now()
                entry.save(update_fields=["last_status", "last_checked_at"])
                bad += 1
        self.stdout.write(self.style.SUCCESS(f"Checked {entries.count()} URLs. OK: {ok}, Bad: {bad}"))


--------------------------------------------
### FILE: apps\seo\management\commands\inspect_url.py
### SIZE: 853 bytes
### HASH: E149E4BC75173C377387D44ED48389820BD2BCB813CA475934308B828D2928BF

from __future__ import annotations

import urllib.request
from urllib.error import HTTPError, URLError

from django.core.management.base import BaseCommand


class Command(BaseCommand):
    help = "Inspect a URL and print status code and headers."

    def add_arguments(self, parser):
        parser.add_argument("url", type=str)

    def handle(self, *args, **options):
        url = options["url"]
        try:
            req = urllib.request.Request(url, method="HEAD")
            with urllib.request.urlopen(req, timeout=5) as resp:
                self.stdout.write(self.style.SUCCESS(f"{url} -> {resp.getcode()}"))
                for k, v in resp.headers.items():
                    self.stdout.write(f"{k}: {v}")
        except (HTTPError, URLError, Exception) as exc:
            self.stdout.write(self.style.ERROR(f"{url} failed: {exc}"))


--------------------------------------------
### FILE: apps\seo\management\commands\rebuild_linkable.py
### SIZE: 772 bytes
### HASH: 3A339C63B609D172EBF0D89648B53B53123112C8C67BB242F4E342F50AA0034F

from __future__ import annotations

from django.core.management.base import BaseCommand
from django.contrib.contenttypes.models import ContentType

from apps.blog.models import Post
from apps.seo.services.internal_linking.engine import refresh_linkable_entity


class Command(BaseCommand):
    help = "Rebuild LinkableEntity registry from blog posts (extend for other models)."

    def handle(self, *args, **options):
        count = 0
        for post in Post.objects.all():
            url = post.get_absolute_url() if hasattr(post, "get_absolute_url") else ""
            refresh_linkable_entity(post, title=post.title, url=url, keywords=post.summary or "")
            count += 1
        self.stdout.write(self.style.SUCCESS(f"Linkable entities refreshed: {count}"))


--------------------------------------------
### FILE: apps\seo\management\commands\suggest_links.py
### SIZE: 777 bytes
### HASH: 2A67F710CC0261A6E2C863551DCF1D2AE3854DD04084DE6435DB87EEB3A558BC

from __future__ import annotations

from django.core.management.base import BaseCommand

from apps.seo.models import LinkableEntity
from apps.seo.services.internal_linking.engine import suggest_links


class Command(BaseCommand):
    help = "Generate link suggestions between linkable entities (simple heuristic)."

    def add_arguments(self, parser):
        parser.add_argument("--limit", type=int, default=5, help="Max suggestions per entity")

    def handle(self, *args, **options):
        entities = list(LinkableEntity.objects.all())
        total = 0
        for source in entities:
            suggest_links(source, entities, limit=options["limit"])
            total += 1
        self.stdout.write(self.style.SUCCESS(f"Suggestions generated for {total} entities"))


--------------------------------------------
### FILE: apps\seo\models.py
### SIZE: 4844 bytes
### HASH: 9A9D0101B620C084340F475A4E60C18DB0827DF45235005A18CF3B6FAB67921A

from __future__ import annotations

from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils import timezone
from django.utils.text import slugify

from apps.core.models import AuditFieldsModel, SoftDeleteModel, TimestampedModel


class SEOModel(TimestampedModel, SoftDeleteModel, AuditFieldsModel):
    """
    Generic container for SEO-related data tied to any model instance.
    """

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")
    locked = models.BooleanField(default=False)
    ai_generated = models.BooleanField(default=False)

    class Meta:
        unique_together = ("content_type", "object_id")


class Metadata(TimestampedModel):
    seo = models.OneToOneField(
        SEOModel, on_delete=models.CASCADE, related_name="metadata"
    )
    meta_title = models.CharField(max_length=255, blank=True, default="")
    meta_description = models.CharField(max_length=320, blank=True, default="")
    focus_keywords = models.JSONField(default=list, blank=True)
    canonical_url = models.URLField(blank=True, default="")
    robots_directives = models.CharField(max_length=255, blank=True, default="")
    social_title = models.CharField(max_length=255, blank=True, default="")
    social_description = models.CharField(max_length=320, blank=True, default="")
    social_image = models.URLField(blank=True, default="")
    noindex = models.BooleanField(default=False)
    nofollow = models.BooleanField(default=False)
    content_hash = models.CharField(max_length=64, blank=True, default="")
    ai_score = models.FloatField(default=0.0)
    schema_json = models.JSONField(default=dict, blank=True)
    generated_at = models.DateTimeField(null=True, blank=True)


class SchemaEntry(TimestampedModel):
    seo = models.ForeignKey(
        SEOModel, on_delete=models.CASCADE, related_name="schemas"
    )
    schema_type = models.CharField(max_length=100)
    payload = models.JSONField(default=dict, blank=True)
    locked = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)


class SitemapEntry(TimestampedModel):
    url = models.URLField(unique=True)
    lastmod = models.DateTimeField(null=True, blank=True)
    changefreq = models.CharField(max_length=20, blank=True, default="")
    priority = models.FloatField(default=0.5)
    is_active = models.BooleanField(default=True)
    last_status = models.PositiveIntegerField(null=True, blank=True)
    last_checked_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]


class Redirect(TimestampedModel):
    source = models.CharField(max_length=255, unique=True)
    target = models.CharField(max_length=255)
    is_permanent = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ["source"]


class LinkableEntity(TimestampedModel):
    """
    Registry of linkable content for internal linking.
    """

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255, blank=True, db_index=True)
    aliases = models.JSONField(default=list, blank=True)
    entity_type = models.CharField(max_length=100, blank=True, default="")
    url = models.URLField()
    keywords = models.JSONField(default=list, blank=True)
    embedding = models.BinaryField(null=True, blank=True)
    vector = models.BinaryField(null=True, blank=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        unique_together = ("content_type", "object_id")
        indexes = [models.Index(fields=["content_type", "object_id"])]

    def save(self, *args, **kwargs):
        if not self.slug:
            base = slugify(self.title)[:240]
            self.slug = base or f"entity-{self.pk or ''}"
        super().save(*args, **kwargs)


class LinkSuggestion(TimestampedModel):
    """
    Stable suggestions for internal linking. Not auto-applied unless requested.
    """

    source = models.ForeignKey(
        LinkableEntity, on_delete=models.CASCADE, related_name="suggestions_from"
    )
    target = models.ForeignKey(
        LinkableEntity, on_delete=models.CASCADE, related_name="suggestions_to"
    )
    score = models.FloatField(default=0.0)
    is_applied = models.BooleanField(default=False)
    locked = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)

    class Meta:
        unique_together = ("source", "target")


--------------------------------------------
### FILE: apps\seo\services\__init__.py
### SIZE: 71 bytes
### HASH: C133FA71C88D318B865CDDE3F29C2A482BEA0926D0D443ACA683927C14C89A10

# Namespace for SEO services (ai, internal_linking, crawlers, scoring)


--------------------------------------------
### FILE: apps\seo\services\ai\metadata.py
### SIZE: 596 bytes
### HASH: D834110B31FD2E7806F9C23C95C78484235006119F33E300AB2C9DAF0FE77772

from __future__ import annotations

from apps.core import ai_client
from apps.core.utils import feature_flags


def generate_metadata(text: str, user) -> dict:
    if not feature_flags.seo_enabled() or not feature_flags.auto_meta_enabled():
        return {}
    title = ai_client.generate_title(text, user)
    description = ai_client.generate_excerpt(text, user)
    keywords = ", ".join(ai_client.suggest_tags(text, user))
    return {
        "meta_title": title,
        "meta_description": description,
        "focus_keywords": [k.strip() for k in keywords.split(",") if k.strip()],
    }


--------------------------------------------
### FILE: apps\seo\services\ai\schema.py
### SIZE: 488 bytes
### HASH: CDF94F6962A8BFEE99E561E218FCE71697FEFB9DC29FA0A757DD31AEAEF2CC8F

from __future__ import annotations

from apps.core import ai_client
from apps.core.utils import feature_flags


def generate_schema(text: str, user) -> dict:
    """
    Placeholder: leverage AI to produce JSON-LD schema hints.
    """
    if not feature_flags.seo_enabled() or not feature_flags.auto_schema_enabled():
        return {}
    schema_text = ai_client.generate_excerpt(text, user)
    return {"@context": "https://schema.org", "@type": "Article", "description": schema_text}


--------------------------------------------
### FILE: apps\seo\services\crawlers\crawler.py
### SIZE: 320 bytes
### HASH: 5CA3CEABD24292BC68C3613E6750F0F81636139AFB6C3EFA067804B4EC233B59

from __future__ import annotations

from typing import List

from apps.seo.models import SitemapEntry


def crawl_stub(urls: List[str]):
    """
    Placeholder for internal crawler; marks URLs in sitemap.
    """
    for url in urls:
        SitemapEntry.objects.update_or_create(url=url, defaults={"is_active": True})


--------------------------------------------
### FILE: apps\seo\services\crawlers\heatmap.py
### SIZE: 854 bytes
### HASH: 9AE11F477226DD1174E0ECD7E47A8FBA1ABB88D73A7DD849E56A94BC79C73A5E

from __future__ import annotations

import logging
from typing import Dict, Iterable

from apps.seo.models import SitemapEntry

logger = logging.getLogger(__name__)


def heatmap() -> Dict[str, int]:
    """
    Produce a basic heatmap of sitemap statuses.
    """
    try:
        total = SitemapEntry.objects.count()
        errors = SitemapEntry.objects.filter(last_status__gte=400).count()
        unknown = SitemapEntry.objects.filter(last_status__isnull=True).count()
        ok = total - errors - unknown
        logger.info("seo.heatmap", extra={"event": {"total": total, "errors": errors, "unknown": unknown}})
        return {"total": total, "ok": ok, "errors": errors, "unknown": unknown}
    except Exception as exc:
        logger.warning("heatmap generation failed: %s", exc)
        return {"total": 0, "ok": 0, "errors": 0, "unknown": 0}


--------------------------------------------
### FILE: apps\seo\services\internal_linking\engine.py
### SIZE: 3015 bytes
### HASH: D8750DE5F8D4E02717E761D34FC565E304CE6828E4DBAC5465A19956ACB21034

from __future__ import annotations

from typing import List, Iterable, Optional
from collections import Counter

from django.contrib.contenttypes.models import ContentType
from django.db.models import Q

from apps.seo.models import LinkableEntity, LinkSuggestion
from apps.core.utils import feature_flags
from apps.core import ai


def refresh_linkable_entity(obj, title: str, url: str, keywords: str = ""):
    if not feature_flags.seo_enabled():
        return None
    ct = ContentType.objects.get_for_model(obj.__class__)
    defaults = {
        "title": title,
        "url": url,
        "keywords": keywords.split(",") if isinstance(keywords, str) else (keywords or []),
        "is_active": True,
    }
    # Optional embedding if enabled
    try:
        if feature_flags.auto_linking_enabled():
            vec = ai.embed_text(f"{title}\n{keywords}")
            defaults["embedding"] = vec
            defaults["vector"] = vec
    except Exception:
        pass
    entity, _ = LinkableEntity.objects.update_or_create(
        content_type=ct,
        object_id=obj.pk,
        defaults=defaults,
    )
    return entity


def _eligible_candidates(source: LinkableEntity, candidates: Iterable[LinkableEntity]) -> List[LinkableEntity]:
    seen = {source.pk}
    out: List[LinkableEntity] = []
    for c in candidates:
        if not c or c.pk in seen:
            continue
        seen.add(c.pk)
        out.append(c)
    return out


def _score_candidate(source: LinkableEntity, target: LinkableEntity) -> float:
    """
    Lightweight semantic-ish score:
    - keyword overlap (bag-of-words)
    - title overlap
    """
    src_terms = Counter((source.keywords or "").lower().split())
    tgt_terms = Counter((target.keywords or "").lower().split())
    overlap = sum((src_terms & tgt_terms).values())

    title_overlap = 0
    if source.title and target.title:
        src_title = set(source.title.lower().split())
        tgt_title = set(target.title.lower().split())
        title_overlap = len(src_title & tgt_title)

    return float(overlap + title_overlap * 0.5)


def suggest_links(source: LinkableEntity, candidates: List[LinkableEntity], limit: int = 5):
    """
    Keyword-first suggestions with stability: we do not churn locked suggestions,
    cap updates to the provided limit, and order by simple similarity scoring.
    """
    if not feature_flags.seo_enabled() or not feature_flags.auto_linking_enabled():
        return

    allowed = _eligible_candidates(source, candidates)
    LinkSuggestion.objects.filter(source=source, locked=False).delete()

    ranked = sorted(allowed, key=lambda t: _score_candidate(source, t), reverse=True)
    added = 0
    for target in ranked:
        if added >= limit:
            break
        score = _score_candidate(source, target)
        LinkSuggestion.objects.update_or_create(
            source=source,
            target=target,
            defaults={"score": score, "is_applied": False, "locked": False},
        )
        added += 1


--------------------------------------------
### FILE: apps\seo\services\readability.py
### SIZE: 834 bytes
### HASH: C0763AAEB3F16D6589E4FEA753D23FE71E0E1C8FBA0E6A5E54B070DB695D64EB

from __future__ import annotations

import logging
import re
from typing import Dict

logger = logging.getLogger(__name__)


def readability_score(text: str) -> Dict[str, float]:
    """
    Lightweight readability heuristic (Flesch-like).
    """
    try:
        sentences = max(1, text.count(".") + text.count("!") + text.count("?"))
        words = max(1, len(re.findall(r"\\w+", text)))
        syllables = max(1, len(re.findall(r"[aeiouy]+", text, re.I)))
        flesch = 206.835 - 1.015 * (words / sentences) - 84.6 * (syllables / words)
        score = round(max(0, min(100, flesch)), 1)
        logger.info("seo.readability", extra={"event": {"score": score}})
        return {"readability": score}
    except Exception as exc:
        logger.warning("readability_score failed: %s", exc)
        return {"readability": 0.0}


--------------------------------------------
### FILE: apps\seo\services\scoring\serp.py
### SIZE: 707 bytes
### HASH: 5B984CA390F4B2D931F9256E1F2774B77ABE0ADDD91BD500B93F05855C5F2D4F

from __future__ import annotations

import logging
from typing import Dict

logger = logging.getLogger(__name__)


def serp_analyze(meta_title: str, meta_description: str) -> Dict[str, float]:
    """
    Placeholder SERP analyzer that returns a simple heuristic score.
    """
    try:
        length_score = min(len(meta_title) / 60.0, 1.0)
        desc_score = min(len(meta_description) / 160.0, 1.0)
        score = round((length_score * 0.6 + desc_score * 0.4) * 100, 1)
        logger.info("seo.serp.analyze", extra={"event": {"score": score}})
        return {"serp_score": score}
    except Exception as exc:
        logger.warning("serp_analyze failed: %s", exc)
        return {"serp_score": 0.0}


--------------------------------------------
### FILE: apps\seo\signals.py
### SIZE: 734 bytes
### HASH: FE84AF1271C83E62CB016ADBB9D91AD540201B4F3A6D5991734CF6153622DF7E

from __future__ import annotations

from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.contenttypes.models import ContentType

from apps.blog.models import Post
from apps.seo.services.internal_linking.engine import refresh_linkable_entity


@receiver(post_save, sender=Post)
def sync_linkable_for_post(sender, instance: Post, **kwargs):
    """
    Keep LinkableEntity in sync for blog posts without altering links automatically.
    """
    try:
        url = instance.get_absolute_url() if hasattr(instance, "get_absolute_url") else ""
        refresh_linkable_entity(instance, title=instance.title, url=url, keywords=instance.summary or "")
    except Exception:
        return


--------------------------------------------
### FILE: apps\seo\templatetags\seo_tags.py
### SIZE: 1901 bytes
### HASH: 1B05930CD631CAFDDCCBBE1C85B196662CEFD46C7954C1F383970BC932684BE0

from __future__ import annotations

from django import template
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe
from django.contrib.contenttypes.models import ContentType

from apps.core.utils import feature_flags
from apps.site_settings.models import SiteSettings
from apps.seo.models import SEOModel, Metadata, SchemaEntry

register = template.Library()


def _seo_enabled() -> bool:
    if not feature_flags.seo_enabled():
        return False
    try:
        ss = SiteSettings.get_solo()
        return bool(getattr(ss, "seo_enabled", False))
    except Exception:
        return False


@register.simple_tag(takes_context=True)
def render_seo_meta(context, obj):
    """
    Render SEO meta/OG/JSON-LD for an object if enabled and metadata exists.
    """
    if not _seo_enabled() or obj is None:
        return ""
    try:
        ct = ContentType.objects.get_for_model(obj.__class__)
        seo_obj = SEOModel.objects.filter(content_type=ct, object_id=obj.pk).first()
    except Exception:
        seo_obj = None
    if not seo_obj or not hasattr(seo_obj, "metadata"):
        return ""
    meta: Metadata = seo_obj.metadata
    schemas = SchemaEntry.objects.filter(seo=seo_obj, locked=False)
    html = render_to_string(
        "seo/components/meta.html",
        {"meta": meta, "schemas": schemas},
        request=context.get("request"),
    )
    return mark_safe(html)


@register.simple_tag
def seo_redirect(path: str):
    """
    Returns a Redirect target if there is an active redirect for the given path.
    """
    if not feature_flags.seo_enabled():
        return None
    from apps.seo.models import Redirect  # lazy import to avoid cycles

    try:
        redirect = Redirect.objects.filter(source=path, is_active=True).first()
        return redirect.target if redirect else None
    except Exception:
        return None


--------------------------------------------
### FILE: apps\seo\tests.py
### SIZE: 939 bytes
### HASH: 1A8B308C8FF4F72F81B4EFFC761F8747E17C25A3231F5B69C7A9AE79C7983793

from __future__ import annotations

import os
import django
from django.test import TestCase, override_settings
from django.template import Context, Template

from apps.core.utils import feature_flags
from apps.site_settings.models import SiteSettings

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "gsminfinity.settings")
os.environ.setdefault("DJANGO_SECRET_KEY", "test-secret")
django.setup()


@override_settings(
    ALLOWED_HOSTS=["testserver", "localhost"],
    ROOT_URLCONF="gsminfinity.urls",
    TEMPLATES=[{"BACKEND": "django.template.backends.django.DjangoTemplates", "APP_DIRS": True}],
)
class SeoTemplateTagTests(TestCase):
    def test_render_seo_meta_respects_flag(self):
        ss = SiteSettings.get_solo()
        ss.seo_enabled = False
        ss.save()
        tpl = Template("{% load seo_tags %}{% render_seo_meta obj %}")
        out = tpl.render(Context({"obj": None}))
        self.assertEqual(out.strip(), "")


--------------------------------------------
### FILE: apps\seo\urls.py
### SIZE: 641 bytes
### HASH: F0784B69087CC0A295E37AFFABA123DD9D8DA4FDB9383F99BFC62DD35DEE7D40

from django.urls import path
from . import views

app_name = "seo"

urlpatterns = [
    path("api/metadata/", views.metadata_view, name="metadata"),
    path("api/metadata/regenerate/", views.regenerate_metadata, name="regenerate_metadata"),
    path("api/metadata/controls/", views.update_metadata_controls, name="update_metadata_controls"),
    path("api/links/apply/", views.apply_link_suggestion, name="apply_link_suggestion"),
    path("api/inspect/", views.inspect_url_view, name="inspect_url"),
    path("redirects/manage/", views.manage_redirect, name="manage_redirect"),
    path("dashboard/", views.dashboard, name="dashboard"),
]


--------------------------------------------
### FILE: apps\seo\views.py
### SIZE: 11263 bytes
### HASH: 552D7EF781431C931F7DC5F07F582B18C6EC746B529B323881907F434B505A1C

from __future__ import annotations

import logging
from django.http import JsonResponse, HttpRequest, HttpResponse
from django.shortcuts import render, redirect
from django.db.models import Q, Count
from django.views.decorators.http import require_GET, require_POST
from django.contrib.auth.decorators import user_passes_test
from django.contrib.contenttypes.models import ContentType
from django.views.decorators.csrf import csrf_exempt
import hashlib
import urllib.request
from urllib.error import HTTPError, URLError

from apps.blog.models import Post
from apps.core.utils import feature_flags
from .models import SEOModel, Metadata, SitemapEntry, Redirect, LinkableEntity, LinkSuggestion
from apps.seo.services.ai.metadata import generate_metadata
from apps.seo.services.scoring.serp import serp_analyze
from apps.seo.services.readability import readability_score
from apps.seo.services.crawlers.heatmap import heatmap

logger = logging.getLogger(__name__)


def _seo_enabled() -> bool:
    return feature_flags.seo_enabled()


def _has_seo_consent(request: HttpRequest) -> bool:
    consent = getattr(request, "consent_categories", {}) or {}
    if consent and not consent.get("functional", True):
        return False
    # If analytics category exists, require it for SEO inspection endpoints
    if "analytics" in consent and not consent.get("analytics", False):
        return False
    return True


@require_GET
def metadata_view(request: HttpRequest) -> JsonResponse:
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"items": []})
    ct_id = request.GET.get("content_type")
    obj_id = request.GET.get("object_id")
    if not ct_id or not obj_id:
        return JsonResponse({"items": []})
    try:
        ct = ContentType.objects.get_for_id(ct_id)
        seo_obj = SEOModel.objects.filter(content_type=ct, object_id=obj_id).first()
    except Exception:
        seo_obj = None
    if not seo_obj or not hasattr(seo_obj, "metadata"):
        return JsonResponse({"items": []})
    m = seo_obj.metadata
    return JsonResponse(
        {
            "title": m.title,
            "description": m.description,
            "keywords": m.keywords,
            "canonical_url": m.canonical_url,
            "og_image": m.og_image,
        }
    )


@csrf_exempt
@require_POST
def regenerate_metadata(request: HttpRequest) -> JsonResponse:
    """
    Explicit AI regeneration; respects locks and content delta.
    """
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"ok": False, "error": "seo_disabled"}, status=403)
    ct_id = request.POST.get("content_type")
    obj_id = request.POST.get("object_id")
    text = request.POST.get("text") or ""
    force = request.POST.get("force") == "1"
    lock = request.POST.get("lock") == "1"
    focus_keywords_raw = request.POST.get("focus_keywords") or ""
    if not ct_id or not obj_id or not text:
        return JsonResponse({"ok": False, "error": "missing_params"}, status=400)
    try:
        ct = ContentType.objects.get_for_id(ct_id)
        seo_obj, _ = SEOModel.objects.get_or_create(content_type=ct, object_id=obj_id)
        if seo_obj.locked and not force:
            return JsonResponse({"ok": False, "error": "locked"}, status=403)
        meta, _ = Metadata.objects.get_or_create(seo=seo_obj)
        content_hash = hashlib.sha256(text.encode("utf-8", errors="ignore")).hexdigest()
        if meta.content_hash and meta.content_hash == content_hash and not force:
            return JsonResponse({"ok": True, "skipped": True})
        data = generate_metadata(text, request.user)
        meta.title = data.get("title", "")[:255]
        meta.description = data.get("description", "")[:320]
        meta.keywords = data.get("keywords", "")
        if focus_keywords_raw:
            meta.focus_keywords = [kw.strip() for kw in focus_keywords_raw.split(",") if kw.strip()]
        meta.content_hash = content_hash
        meta.save()
        seo_obj.ai_generated = True
        seo_obj.locked = lock or seo_obj.locked
        seo_obj.save(update_fields=["ai_generated", "locked", "updated_at"])
        logger.info("SEO metadata regenerated", extra={"object_id": obj_id, "content_type": ct_id, "locked": seo_obj.locked})
        return JsonResponse(
            {
                "ok": True,
                "title": meta.title,
                "description": meta.description,
                "focus_keywords": meta.focus_keywords,
                "locked": seo_obj.locked,
            }
        )
    except Exception as exc:
        logger.error("regenerate_metadata failed", exc_info=True)
        return JsonResponse({"ok": False, "error": str(exc)}, status=400)


@csrf_exempt
@require_POST
def update_metadata_controls(request: HttpRequest) -> JsonResponse:
    """
    Lock/unlock metadata and persist focus keywords without regeneration.
    """
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"ok": False, "error": "seo_disabled"}, status=403)
    ct_id = request.POST.get("content_type")
    obj_id = request.POST.get("object_id")
    action = request.POST.get("action") or ""
    focus_keywords_raw = request.POST.get("focus_keywords") or ""
    if not ct_id or not obj_id:
        return JsonResponse({"ok": False, "error": "missing_params"}, status=400)
    try:
        ct = ContentType.objects.get_for_id(ct_id)
        seo_obj, _ = SEOModel.objects.get_or_create(content_type=ct, object_id=obj_id)
        meta, _ = Metadata.objects.get_or_create(seo=seo_obj)
        if action == "lock":
            seo_obj.locked = True
        elif action == "unlock":
            seo_obj.locked = False
        if focus_keywords_raw:
            meta.focus_keywords = [kw.strip() for kw in focus_keywords_raw.split(",") if kw.strip()]
            meta.save(update_fields=["focus_keywords", "updated_at"])
        seo_obj.save(update_fields=["locked", "updated_at"])
        return JsonResponse({"ok": True, "locked": seo_obj.locked, "focus_keywords": meta.focus_keywords})
    except Exception as exc:
        logger.error("update_metadata_controls failed", exc_info=True)
        return JsonResponse({"ok": False, "error": str(exc)}, status=400)


@csrf_exempt
@require_POST
def apply_link_suggestion(request: HttpRequest) -> JsonResponse:
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"ok": False, "error": "seo_disabled"}, status=403)
    suggestion_id = request.POST.get("id")
    lock = request.POST.get("lock") == "1"
    apply_flag = request.POST.get("apply") != "0"
    try:
        sug = LinkSuggestion.objects.get(pk=suggestion_id)
        if sug.locked and not lock:
            return JsonResponse({"ok": False, "error": "locked"}, status=403)
        sug.is_applied = apply_flag
        sug.locked = lock or sug.locked
        sug.save()
        return JsonResponse({"ok": True})
    except LinkSuggestion.DoesNotExist:
        return JsonResponse({"ok": False, "error": "not_found"}, status=404)


@require_GET
def inspect_url_view(request: HttpRequest) -> JsonResponse:
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"ok": False, "error": "seo_disabled"}, status=403)
    url = request.GET.get("url", "")
    if not url:
        return JsonResponse({"ok": False, "error": "missing_url"}, status=400)
    try:
        req = urllib.request.Request(url, method="HEAD")
        with urllib.request.urlopen(req, timeout=5) as resp:
            headers = {k: v for k, v in resp.headers.items()}
            return JsonResponse({"ok": True, "status": resp.getcode(), "headers": headers})
    except (HTTPError, URLError, Exception) as exc:
        return JsonResponse({"ok": False, "error": str(exc)}, status=400)


@csrf_exempt
@require_POST
def manage_redirect(request: HttpRequest) -> HttpResponse:
    if not _seo_enabled() or not _has_seo_consent(request):
        return JsonResponse({"ok": False, "error": "seo_disabled"}, status=403)
    action = request.POST.get("action") or "create"
    rid = request.POST.get("id")
    source = request.POST.get("source") or ""
    target = request.POST.get("target") or ""
    permanent = request.POST.get("is_permanent") == "1"
    active = request.POST.get("is_active") != "0"
    try:
        if action == "create":
            if not source or not target:
                return redirect("seo:dashboard")
            Redirect.objects.update_or_create(
                source=source,
                defaults={"target": target, "is_permanent": permanent, "is_active": active},
            )
        elif action in ("toggle_active", "toggle_permanent") and rid:
            redirect_obj = Redirect.objects.filter(pk=rid).first()
            if redirect_obj:
                if action == "toggle_active":
                    redirect_obj.is_active = not redirect_obj.is_active
                    redirect_obj.save(update_fields=["is_active"])
                else:
                    redirect_obj.is_permanent = not redirect_obj.is_permanent
                    redirect_obj.save(update_fields=["is_permanent"])
    except Exception as exc:
        logger.error("manage_redirect failed", exc_info=True)
    return redirect("seo:dashboard")


@user_passes_test(lambda u: u.is_staff or u.is_superuser or getattr(u, "has_role", lambda *r: False)("admin", "editor"))
def dashboard(request: HttpRequest) -> HttpResponse:
    suggestions = LinkSuggestion.objects.filter(is_applied=False).select_related("source", "target")[:50]
    redirects = Redirect.objects.all()[:50]
    sitemap_qs = SitemapEntry.objects.filter(is_active=True)
    sitemap_entries = sitemap_qs.order_by("-last_checked_at", "-created_at")[:50]
    link_issues = sitemap_qs.filter(last_status__gte=400).count()
    link_unknown = sitemap_qs.filter(Q(last_status__isnull=True) | Q(last_status=0)).count()
    recent_posts = Post.objects.order_by("-updated_at")[:15]
    post_ct = ContentType.objects.get_for_model(Post)
    missing_meta = Metadata.objects.filter(Q(meta_title="") | Q(meta_description="")).count()
    duplicate_titles = (
        Metadata.objects.exclude(meta_title="")
        .values("meta_title")
        .annotate(c=Count("id"))
        .filter(c__gt=1)
        .count()
    )
    serp_stats = serp_analyze(" ".join(recent_posts.values_list("seo_title", flat=True)[:1]), " ".join(recent_posts.values_list("seo_description", flat=True)[:1]))
    heatmap_stats = heatmap()
    return render(
        request,
        "seo/dashboard.html",
        {
            "seo_enabled": _seo_enabled(),
            "sitemaps": SitemapEntry.objects.count(),
            "redirects": Redirect.objects.count(),
            "entities": LinkableEntity.objects.count(),
            "suggestions": suggestions,
            "redirects_list": redirects,
            "sitemap_entries": sitemap_entries,
            "link_issues": link_issues,
            "link_unknown": link_unknown,
            "recent_posts": recent_posts,
            "post_content_type_id": post_ct.id,
            "missing_meta": missing_meta,
            "duplicate_titles": duplicate_titles,
            "serp_stats": serp_stats,
            "heatmap": heatmap_stats,
        },
    )


--------------------------------------------
### FILE: apps\site_settings\__init__.py
### SIZE: 200 bytes
### HASH: 68839FF24F95642BE97E71EF29A3BDCB6A3AB68BF827B5B3088874F55B2D8904

"""
Site settings application package.

This module intentionally does not execute any logic on import.
All behaviour lives in apps.site_settings.apps / models / signals.
"""

__all__: list[str] = []


--------------------------------------------
### FILE: apps\site_settings\admin.py
### SIZE: 9118 bytes
### HASH: 617E045B838AF96ADB744D5FFA3161A26B39D47195D12DA7C109C3C845AAC1E0

"""
apps.site_settings.admin
========================
Enterprise Admin Configuration for Site + Tenant Settings.

✔ Django 5.2 / Python 3.12
✔ Supports new branding fields (logo, dark_logo, favicon)
✔ Secure, clean fieldsets (no direct M2M inside)
✔ Through-model inlines for meta-tags & verification files
✔ Image previews inside admin
"""

from __future__ import annotations

import logging

from django.contrib import admin
from django.utils.html import format_html
from django.utils.translation import gettext_lazy as _
from import_export.admin import ExportMixin
from solo.admin import SingletonModelAdmin

from .models import (
    SiteSettings,
    TenantSiteSettings,
    VerificationFile,
    VerificationMetaTag,
)

logger = logging.getLogger(__name__)


# ------------------------------------------------------------
#  INLINE THROUGH-MODELS
# ------------------------------------------------------------
class SiteSettingsMetaTagInline(admin.TabularInline):
    model = SiteSettings.meta_tags.through
    extra = 0
    verbose_name = _("Verification Meta Tag Link")
    verbose_name_plural = _("Verification Meta Tag Links")


class SiteSettingsFileInline(admin.TabularInline):
    model = SiteSettings.verification_files.through
    extra = 0
    verbose_name = _("Verification File Link")
    verbose_name_plural = _("Verification File Links")


# ------------------------------------------------------------
#  IMAGE PREVIEW HELPERS
# ------------------------------------------------------------
def _preview(obj, field_name: str, height: int = 60):
    """Safe preview for logo, dark_logo, favicon."""
    try:
        field = getattr(obj, field_name, None)
        if not field:
            return "-"
        if not getattr(field, "url", None):
            return "-"
        return format_html(
            '<img src="{}" style="height:{}px; border-radius:6px;" />',
            field.url,
            height,
        )
    except Exception:
        return "-"


# ------------------------------------------------------------
#  SiteSettings Admin (Singleton)
# ------------------------------------------------------------
@admin.register(SiteSettings)
class SiteSettingsAdmin(ExportMixin, SingletonModelAdmin):

    list_display = (
        "site_name",
        "maintenance_mode",
        "force_https",
        "enable_signup",
        "enable_tenants",
        "enable_notifications",
        "enable_blog",
        "enable_blog_comments",
        "allow_user_blog_posts",
        "allow_user_bounty_posts",
        "seo_enabled",
        "ads_enabled",
        "require_mfa",
        "recaptcha_enabled",
    )

    search_fields = ("site_name", "site_header", "site_description")
    list_per_page = 25
    save_on_top = True

    readonly_fields = (
        "logo_preview",
        "dark_logo_preview",
        "favicon_preview",
    )

    # ----------------------
    # Fieldsets
    # ----------------------
    fieldsets = (
        (
            "🔖 Branding & Theme",
            {
                "fields": (
                    "site_name",
                    "site_header",
                    "site_description",
                    "logo",
                    "logo_preview",
                    "dark_logo",
                    "dark_logo_preview",
                    "favicon",
                    "favicon_preview",
                    "theme_profile",
                    "primary_color",
                    "secondary_color",
                ),
            },
        ),
        (
            "🌍 Locale & Internationalization",
            {
                "fields": (
                    "default_language",
                    "timezone",
                    "enable_localization",
                ),
            },
        ),
        (
            "🤖 AI Personalization",
            {
                "fields": (
                    "enable_ai_personalization",
                    "ai_theme_mode",
                    "ai_model_version",
                ),
            },
        ),
        (
            "Security & Features",
            {
                "fields": (
                    "enable_signup",
                    "enable_tenants",
                    "enable_password_reset",
                    "enable_notifications",
                    "maintenance_mode",
                    "force_https",
                ),
            },
        ),
        (
            "Content / SEO / Ads Toggles",
            {
                "fields": (
                    "enable_blog",
                    "enable_blog_comments",
                    "allow_user_blog_posts",
                    "allow_user_bounty_posts",
                    "seo_enabled",
                    "auto_meta_enabled",
                    "auto_schema_enabled",
                    "auto_linking_enabled",
                    "ads_enabled",
                    "affiliate_enabled",
                    "ad_networks_enabled",
                    "ad_aggressiveness_level",
                ),
            },
        ),
        (
            "🧠 reCAPTCHA Configuration",
            {
                "fields": (
                    "recaptcha_enabled",
                    "recaptcha_mode",
                    "recaptcha_public_key",
                    "recaptcha_private_key",
                    "recaptcha_score_threshold",
                    "recaptcha_timeout_ms",
                ),
            },
        ),
        (
            "📱 Device & MFA Policies",
            {
                "fields": (
                    "max_devices_per_user",
                    "lock_duration_minutes",
                    "fingerprint_mode",
                    "enforce_unique_device",
                    "require_mfa",
                    "mfa_totp_issuer",
                ),
            },
        ),
        (
            "📧 Email Verification",
            {
                "fields": (
                    "email_verification_code_length",
                    "email_verification_code_type",
                ),
            },
        ),
        (
            "🛡️ Rate Limiting & Robustness",
            {
                "fields": (
                    "max_login_attempts",
                    "rate_limit_window_seconds",
                    "cache_ttl_seconds",
                ),
            },
        ),
    )

    inlines = [SiteSettingsMetaTagInline, SiteSettingsFileInline]

    # ----------------------
    # Preview fields
    # ----------------------
    def logo_preview(self, obj):
        return _preview(obj, "logo")

    def dark_logo_preview(self, obj):
        return _preview(obj, "dark_logo")

    def favicon_preview(self, obj):
        return _preview(obj, "favicon")

    logo_preview.short_description = "Logo Preview"
    dark_logo_preview.short_description = "Dark Logo Preview"
    favicon_preview.short_description = "Favicon Preview"

    # ----------------------
    # Save Logger
    # ----------------------
    def save_model(self, request, obj, form, change):
        super().save_model(request, obj, form, change)
        logger.info(
            "SiteSettings updated by %s (force_https=%s, maintenance_mode=%s)",
            request.user,
            obj.force_https,
            obj.maintenance_mode,
        )


# ------------------------------------------------------------
#  TENANT SETTINGS ADMIN
# ------------------------------------------------------------
@admin.register(TenantSiteSettings)
class TenantSiteSettingsAdmin(ExportMixin, admin.ModelAdmin):

    list_display = ("site", "theme_profile", "primary_color", "secondary_color")
    search_fields = ("site__domain", "theme_profile")
    ordering = ("site",)
    list_select_related = ("site",)
    list_per_page = 50
    save_on_top = True


# ------------------------------------------------------------
#  VERIFICATION RESOURCES
# ------------------------------------------------------------
@admin.register(VerificationMetaTag)
class VerificationMetaTagAdmin(admin.ModelAdmin):
    list_display = ("provider", "name_attr", "content_attr", "created_at")
    search_fields = ("provider", "name_attr", "content_attr")
    ordering = ("-created_at",)
    readonly_fields = ("created_at",)
    save_on_top = True


@admin.register(VerificationFile)
class VerificationFileAdmin(admin.ModelAdmin):
    list_display = ("provider", "file", "uploaded_at")
    search_fields = ("provider", "file")
    ordering = ("-uploaded_at",)
    readonly_fields = ("uploaded_at",)
    save_on_top = True


# ------------------------------------------------------------
#  Admin Branding (non-project-specific)
# ------------------------------------------------------------
admin.site.site_header = _("Administration Portal")
admin.site.index_title = _("Enterprise Settings")
admin.site.site_title = _("Site Configuration")


--------------------------------------------
### FILE: apps\site_settings\apps.py
### SIZE: 775 bytes
### HASH: 434457A094C7EAADFD7085AA46E0C35E5073C67889DAAED6B5757A4D4EC6BC66

from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class SiteSettingsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.site_settings"  # full Python path
    label = "site_settings"  # short label
    verbose_name = "Site Settings"

    def ready(self):
        """
        Initialize site settings and related signals.

        - Loads signal hooks to sync database-based settings
        - Avoids circular imports during startup
        - Autodiscovers additional settings modules if needed
        """
        try:
            import apps.site_settings.signals  # noqa: F401
        except ImportError:
            pass

        autodiscover_modules("signals")

--------------------------------------------
### FILE: apps\site_settings\context_processors.py
### SIZE: 12789 bytes
### HASH: 17F72F47DB3DCF542D3F05072324DF4EF2D7BB64D57574D690EBEE2D99F0D22B

"""
Enterprise-grade Site Settings Context Processor (FINAL, SYNC-ONLY)

- 100% synchronous (no await / no sync_to_async / no async context switching)
- WSGI + ASGI safe
- ORM calls fully wrapped in defensive guards
- Never leaks exceptions into templates
- Returns consistent, normalized schema
- No recursion risk, no unsafe attributes
"""

from __future__ import annotations

import hashlib
import logging
from typing import Any, Dict, Iterable, Optional

from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.http import HttpRequest
from django.templatetags.static import static

logger = logging.getLogger(__name__)

DEFAULT_TTL_SECONDS = 300
CACHE_KEY_PREFIX = "active_site_settings"


# ---------------------------------------------------------------------
# KEY HELPERS
# ---------------------------------------------------------------------
def _safe_domain_key(domain: Optional[str]) -> str:
    """Convert domain to cache key (collision-resistant, no unsafe chars)."""
    safe = (domain or "global").strip().lower()
    digest = hashlib.sha256(safe.encode("utf-8")).hexdigest()[:16]
    return f"{CACHE_KEY_PREFIX}_{digest}"


def _iter_related(obj: Any, attr: str) -> Iterable:
    """Returns a tuple for all related items safely & consistently."""
    try:
        rel = getattr(obj, attr, None)
        if rel is None:
            return ()
        if hasattr(rel, "all"):
            # Execute ORM query defensively
            return tuple(rel.all())
        if isinstance(rel, (list, tuple, set)):
            return tuple(rel)
        return (rel,)
    except Exception:
        # Never break template rendering due to ORM lookup failure
        return ()


def _file_url_or_default(file_field, default_static_path: str) -> str:
    """Safe URL resolver for file fields."""
    try:
        if file_field and getattr(file_field, "url", None):
            url = file_field.url
            if isinstance(url, str) and url.strip():
                return url
    except Exception:
        pass
    return static(default_static_path)


# ---------------------------------------------------------------------
# SERIALIZER (pure sync, full defensive)
# ---------------------------------------------------------------------
def _safe_defaults() -> Dict[str, Any]:
    """Central default payload (no recursion)."""
    return {
        "id": None,
        "site_domain": "global",
        "site_name": "Site",
        "site_header": "Admin",
        "site_description": "",
        "logo": static("img/default-logo.svg"),
        "dark_logo": static("img/default-logo-dark.svg"),
        "favicon": static("img/default-favicon.svg"),
        "theme": "default",
        "primary_color": "#0d6efd",
        "secondary_color": "#6c757d",
        "enable_signup": True,
        "enable_notifications": True,
        "maintenance_mode": False,
        "force_https": False,
        "recaptcha_enabled": False,
        # Feature toggles (ads/seo)
        "seo_enabled": False,
        "auto_meta_enabled": False,
        "auto_schema_enabled": False,
        "auto_linking_enabled": False,
        "ads_enabled": False,
        "affiliate_enabled": False,
        "ad_networks_enabled": False,
        "ad_aggressiveness_level": "balanced",
        # Feature toggles (admin controlled)
        "enable_tenants": False,
        "enable_blog": False,
        "enable_blog_comments": False,
        "cache_ttl_seconds": DEFAULT_TTL_SECONDS,
        "meta_tags": [],
        "verification_files": [],
    }


def _serialize(obj: Any) -> Dict[str, Any]:
    """Convert ORM object to dict (fully isolated, exception-proof)."""

    if obj is None:
        return _safe_defaults()

    try:
        # domain fallback logic (tenant site → instance → global)
        site_domain = (
            getattr(getattr(obj, "site", None), "domain", None)
            or getattr(obj, "site_domain", None)
            or "global"
        )

        # META TAGS
        meta_tags = []
        for m in _iter_related(obj, "meta_tags"):
            name = getattr(m, "name", None) or getattr(m, "name_attr", None)
            content = getattr(m, "content", None) or getattr(m, "content_attr", None)
            if isinstance(name, str) and name.strip():
                meta_tags.append(
                    {
                        "name": name.strip(),
                        "content": content or "",
                    }
                )

        # VERIFICATION FILES
        verification_files = []
        for f in _iter_related(obj, "verification_files"):
            file_field = getattr(f, "file", None)
            raw_name = (
                getattr(file_field, "name", None) or getattr(f, "filename", None) or ""
            )
            raw_url = getattr(file_field, "url", None) or ""

            filename = raw_name if isinstance(raw_name, str) else ""
            url = raw_url if isinstance(raw_url, str) else ""

            if not url.strip():
                url = static("img/default-verification.txt")

            verification_files.append(
                {
                    "filename": filename,
                    "url": url,
                    "provider": getattr(f, "provider", "") or "",
                }
            )

        ttl = getattr(obj, "cache_ttl_seconds", DEFAULT_TTL_SECONDS)
        try:
            ttl = int(ttl)
        except Exception:
            ttl = DEFAULT_TTL_SECONDS

        return {
            "id": getattr(obj, "id", None),
            "site_domain": site_domain,
            "site_name": getattr(obj, "site_name", "Site"),
            "site_header": getattr(obj, "site_header", "Admin"),
            "site_description": getattr(obj, "site_description", "") or "",
            "logo": _file_url_or_default(
                getattr(obj, "logo", None), "img/default-logo.svg"
            ),
            "dark_logo": _file_url_or_default(
                getattr(obj, "dark_logo", None), "img/default-logo-dark.svg"
            ),
            "favicon": _file_url_or_default(
                getattr(obj, "favicon", None), "img/default-favicon.svg"
            ),
            "theme": getattr(obj, "theme", "default"),
            "primary_color": getattr(obj, "primary_color", "#0d6efd"),
            "secondary_color": getattr(obj, "secondary_color", "#6c757d"),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "enable_notifications": bool(getattr(obj, "enable_notifications", True)),
            "maintenance_mode": bool(getattr(obj, "maintenance_mode", False)),
            "force_https": bool(getattr(obj, "force_https", False)),
            "recaptcha_enabled": bool(getattr(obj, "recaptcha_enabled", False)),
            # Feature toggles (admin controlled)
            "enable_tenants": bool(getattr(obj, "enable_tenants", False)),
            "enable_blog": bool(getattr(obj, "enable_blog", False)),
            "enable_blog_comments": bool(
                getattr(obj, "enable_blog_comments", False)
            ),
            # Ads/SEO toggles (for template gating)
            "seo_enabled": bool(getattr(obj, "seo_enabled", False)),
            "auto_meta_enabled": bool(getattr(obj, "auto_meta_enabled", False)),
            "auto_schema_enabled": bool(getattr(obj, "auto_schema_enabled", False)),
            "auto_linking_enabled": bool(getattr(obj, "auto_linking_enabled", False)),
            "ads_enabled": bool(getattr(obj, "ads_enabled", False)),
            "affiliate_enabled": bool(getattr(obj, "affiliate_enabled", False)),
            "ad_networks_enabled": bool(getattr(obj, "ad_networks_enabled", False)),
            "ad_aggressiveness_level": getattr(
                obj, "ad_aggressiveness_level", "balanced"
            )
            or "balanced",
            "cache_ttl_seconds": ttl,
            "meta_tags": meta_tags,
            "verification_files": verification_files,
        }

    except Exception:
        logger.error("_serialize failed → defaults used", exc_info=True)
        return _safe_defaults()


# ---------------------------------------------------------------------
# ORM LOADER (100% synchronous)
# ---------------------------------------------------------------------
def _load_sync(site):
    """Loads tenant → global settings in strict sync mode."""
    try:
        # Lazy Import
        from apps.site_settings import models as m
    except Exception:
        logger.error("Import failure: apps.site_settings missing", exc_info=True)
        return None

    try:
        # Tenant-level lookup (safe)
        if site and hasattr(site, "id"):
            try:
                t = (
                    m.TenantSiteSettings.objects.select_related("site")
                    .prefetch_related("meta_tags", "verification_files")
                    .filter(site=site)
                    .first()
                )
                if t:
                    return t
            except Exception:
                pass

        # Global singleton
        try:
            # Use prefetch on global singleton for consistency
            qs = m.SiteSettings.objects.prefetch_related("meta_tags", "verification_files")

            if hasattr(m.SiteSettings, "get_solo"):
                return m.SiteSettings.get_solo()
            
            # Fallback to first record on prefetched queryset
            return qs.first()
            
        except Exception:
            # Fallback for error during get_solo/first()
            return None


    except Exception:
        logger.debug("_load_sync failed → None")
        return None


# ---------------------------------------------------------------------
# MAIN CONTEXT PROCESSOR (FULLY SYNC, FULLY SAFE)
# ---------------------------------------------------------------------
def site_settings(request: HttpRequest) -> Dict[str, Any]:
    try:
        # 1. Determine Auth status (Request-specific, cannot be cached with site settings)
        is_authenticated = False
        try:
            user = getattr(request, 'user', None)
            if user is not None and getattr(user, 'is_authenticated', False):
                is_authenticated = True
        except Exception:
            pass
        # --------------------------------------------------------------------

        try:
            site = get_current_site(request)
            domain = (
                getattr(site, "domain", None) or f"id-{getattr(site, 'id', 'global')}"
            )
        except Exception:
            site = None
            domain = "global"

        cache_key = _safe_domain_key(domain)

        # Cache hit
        try:
            cached = cache.get(cache_key)
            if isinstance(cached, dict):
                # Inject request-specific context (auth status)
                return {
                    "site_settings": cached,
                    "settings": cached,
                    "meta_tags": cached.get("meta_tags", []),
                    "verification_files": cached.get("verification_files", []),
                    "auth_is_authenticated": is_authenticated,  # 🔥 FIXED: Non-cached variable injected
                }
        except Exception:
            pass

        # Load ORM → serialize
        raw_obj = _load_sync(site)
        payload = _serialize(raw_obj)

        # Cache write
        try:
            cache.set(cache_key, payload, timeout=payload["cache_ttl_seconds"])
        except Exception:
            pass

        # Final Return
        # Inject request-specific context (auth status)
        return {
            "site_settings": payload,
            "settings": payload,
            "meta_tags": payload.get("meta_tags", []),
            "verification_files": payload.get("verification_files", []),
            "auth_is_authenticated": is_authenticated,  # 🔥 FIXED: Non-cached variable injected
        }

    except Exception:
        logger.error("site_settings processor fatal → defaults", exc_info=True)
        payload = _safe_defaults()
        # Ensure 'auth_is_authenticated' is returned even on fatal failure
        return {
            "site_settings": payload,
            "settings": payload,
            "meta_tags": [],
            "verification_files": [],
            "auth_is_authenticated": False,  # 🔥 FIXED: Non-cached variable injected
        }


# Alias (keeps backwards compatibility)
def global_settings(request: HttpRequest) -> Dict[str, Any]:
    return site_settings(request)


--------------------------------------------
### FILE: apps\site_settings\management\commands\clear_site_settings_cache.py
### SIZE: 382 bytes
### HASH: 79B9EFE6F6C3595E7ECACA31A3C67C2C99F9AD2CC69738A34BCAAF4E1CDA5125

from apps.site_settings.signals import clear_site_settings_cache
from django.core.management.base import BaseCommand


class Command(BaseCommand):
    help = "Clear site settings caches (singleton and per-site keys)."

    def handle(self, *args, **options):
        clear_site_settings_cache()
        self.stdout.write(self.style.SUCCESS("Site settings caches cleared."))

--------------------------------------------
### FILE: apps\site_settings\models.py
### SIZE: 16469 bytes
### HASH: A3CA27DF9BA187A7455523700564532DFF7B21B3FEF43656D8C6725DBA4F7B3E

"""
Enterprise-grade Site & Tenant Settings

✓ Django 5.2 / Python 3.12
✓ Admin-uploadable branding assets (logo, dark logo, favicon)
✓ Generic, non-branded defaults
✓ Hardened validation (colors, file uploads, limits)
✓ Fully safe file URL helpers (static() fallback)
✓ Strict ManyToMany consistency
✓ Tenant-aware
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, Optional

from django.contrib.sites.models import Site
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator, RegexValidator
from django.db import models
from django.templatetags.static import static
from solo.models import SingletonModel

logger = logging.getLogger(__name__)

# =====================================================================
# GLOBAL CONSTANTS
# =====================================================================
_ALLOWED_VERIFICATION_EXTENSIONS = {".txt", ".html", ".xml", ".json"}
_MAX_VERIFICATION_FILE_BYTES = 1 * 1024 * 1024  # 1 MiB

_HEX_COLOR_VALIDATOR = RegexValidator(
    regex=r"^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
    message="Enter a valid hex color like #0d6efd",
)


# =====================================================================
# GLOBAL / DEFAULT SITE SETTINGS (SINGLETON)
# =====================================================================
class SiteSettings(SingletonModel):
    """
    Global site-wide configuration (non-branded, fully generic).
    """

    # ------------------------------------------------------------------
    # Branding – MUST remain generic (no “GSM” or “Infinity”!)
    # ------------------------------------------------------------------
    site_name = models.CharField(max_length=100, default="Site")
    site_header = models.CharField(max_length=100, default="Admin")
    site_description = models.TextField(blank=True, default="")

    logo = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Primary site logo (SVG/PNG)",
    )
    dark_logo = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Dark mode logo",
    )
    favicon = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Favicon (PNG/ICO/SVG)",
    )

    # ------------------------------------------------------------------
    # Theme
    # ------------------------------------------------------------------
    theme_profile = models.CharField(max_length=50, blank=True, null=True)

    primary_color = models.CharField(
        max_length=7,
        blank=True,
        null=True,
        validators=[_HEX_COLOR_VALIDATOR],
    )
    secondary_color = models.CharField(
        max_length=7,
        blank=True,
        null=True,
        validators=[_HEX_COLOR_VALIDATOR],
    )

    # ------------------------------------------------------------------
    # Localization
    # ------------------------------------------------------------------
    default_language = models.CharField(max_length=10, default="en")
    timezone = models.CharField(max_length=50, default="UTC")
    enable_localization = models.BooleanField(default=False)

    # ------------------------------------------------------------------
    # AI Personalization
    # ------------------------------------------------------------------
    enable_ai_personalization = models.BooleanField(default=False)
    ai_theme_mode = models.CharField(
        max_length=20,
        choices=[("light", "Light"), ("dark", "Dark"), ("auto", "Auto")],
        default="auto",
    )
    ai_model_version = models.CharField(max_length=20, blank=True, null=True)

    # ------------------------------------------------------------------
    # Security & Features
    # ------------------------------------------------------------------
    enable_signup = models.BooleanField(default=True)
    enable_password_reset = models.BooleanField(default=True)
    enable_notifications = models.BooleanField(default=True)
    enable_tenants = models.BooleanField(
        default=False,
        help_text="Enable public tenants listing when true.",
    )
    enable_blog = models.BooleanField(
        default=True,
        help_text="Enable public blog views.",
    )
    enable_blog_comments = models.BooleanField(
        default=True,
        help_text="Enable comments on blog posts.",
    )
    allow_user_blog_posts = models.BooleanField(
        default=False,
        help_text="When on, authenticated users (non-admin) can create blog posts.",
    )
    allow_user_bounty_posts = models.BooleanField(
        default=False,
        help_text="When on, authenticated users can create bounty posts (tagged 'bounty').",
    )
    # ------------------------------------------------------------------
    # SEO / ADS Toggles (admin controlled)
    # ------------------------------------------------------------------
    seo_enabled = models.BooleanField(default=True)
    auto_meta_enabled = models.BooleanField(default=False)
    auto_schema_enabled = models.BooleanField(default=False)
    auto_linking_enabled = models.BooleanField(default=False)

    ads_enabled = models.BooleanField(default=False)
    affiliate_enabled = models.BooleanField(default=False)
    ad_networks_enabled = models.BooleanField(default=False)
    ad_aggressiveness_level = models.CharField(
        max_length=20,
        choices=[
            ("minimal", "Minimal"),
            ("balanced", "Balanced"),
            ("aggressive", "Aggressive"),
        ],
        default="balanced",
    )
    maintenance_mode = models.BooleanField(default=False)

    force_https = models.BooleanField(
        default=False,
        help_text="Enable only if TLS is enforced by reverse proxy",
    )

    # ------------------------------------------------------------------
    # reCAPTCHA
    # ------------------------------------------------------------------
    recaptcha_enabled = models.BooleanField(default=False)
    recaptcha_mode = models.CharField(
        max_length=20,
        choices=[("v2", "v2"), ("v3", "v3")],
        default="v2",
    )
    recaptcha_public_key = models.CharField(max_length=100, blank=True, null=True)
    recaptcha_private_key = models.CharField(max_length=100, blank=True, null=True)

    recaptcha_score_threshold = models.FloatField(
        default=0.5,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
    )
    recaptcha_timeout_ms = models.PositiveIntegerField(default=3000)

    # ------------------------------------------------------------------
    # MFA / Device Security
    # ------------------------------------------------------------------
    max_devices_per_user = models.PositiveIntegerField(default=3)
    lock_duration_minutes = models.PositiveIntegerField(default=15)
    fingerprint_mode = models.CharField(
        max_length=20,
        choices=[("strict", "Strict"), ("lenient", "Lenient")],
        default="strict",
    )
    enforce_unique_device = models.BooleanField(default=True)
    require_mfa = models.BooleanField(default=False)

    mfa_totp_issuer = models.CharField(max_length=50, default="Site")

    # ------------------------------------------------------------------
    # Email Verification
    # ------------------------------------------------------------------
    email_verification_code_length = models.PositiveIntegerField(
        default=6,
        validators=[MinValueValidator(4), MaxValueValidator(12)],
    )
    email_verification_code_type = models.CharField(
        max_length=20,
        choices=[("numeric", "Numeric"), ("alphanumeric", "Alphanumeric")],
        default="alphanumeric",
    )

    # ------------------------------------------------------------------
    # Rate limiting
    # ------------------------------------------------------------------
    max_login_attempts = models.PositiveIntegerField(default=5)
    rate_limit_window_seconds = models.PositiveIntegerField(default=300)

    # Cache TTL (consumed by the context processor)
    cache_ttl_seconds = models.PositiveIntegerField(default=600)

    # ------------------------------------------------------------------
    # Meta Tags & Verification Files
    # ------------------------------------------------------------------
    meta_tags = models.ManyToManyField(
        "VerificationMetaTag",
        through="SiteSettingsMetaTagLink",
        blank=True,
    )
    verification_files = models.ManyToManyField(
        "VerificationFile",
        through="SiteSettingsVerificationFileLink",
        blank=True,
    )

    class Meta:
        verbose_name = "Site Settings"
        verbose_name_plural = "Site Settings"

    def __str__(self) -> str:
        return self.site_name or "Site Settings"

    # =================================================================
    # SAFE FILE URL HELPERS (always static fallback)
    # =================================================================
    def _safe_file_url(self, field, fallback: str) -> str:
        try:
            if field and getattr(field, "url", None):
                url = field.url
                if isinstance(url, str) and url.strip():
                    return url
        except Exception:
            pass
        return static(fallback)

    @property
    def logo_url(self) -> str:
        return self._safe_file_url(self.logo, "img/default-logo.svg")

    @property
    def dark_logo_url(self) -> str:
        # Try dark → fallback to normal → fallback to static
        url = self._safe_file_url(self.dark_logo, "")
        if url:
            return url
        url = self._safe_file_url(self.logo, "")
        if url:
            return url
        return static("img/default-logo-dark.svg")

    @property
    def favicon_url(self) -> str:
        return self._safe_file_url(self.favicon, "img/default-favicon.svg")

    # =================================================================
    # VALIDATION
    # =================================================================
    def clean(self):
        errors = {}

        for name, val in [
            ("primary_color", self.primary_color),
            ("secondary_color", self.secondary_color),
        ]:
            if val:
                try:
                    _HEX_COLOR_VALIDATOR(val)
                except ValidationError as exc:
                    errors[name] = exc.messages

        if errors:
            raise ValidationError(errors)

    # =================================================================
    # FRONTEND CONFIG HELPERS
    # =================================================================
    def get_theme(self) -> dict[str, Any]:
        return {
            "profile": self.theme_profile or "default",
            "primary_color": self.primary_color or "#0d6efd",
            "secondary_color": self.secondary_color or "#6c757d",
            "ai_mode": self.ai_theme_mode,
        }

    def recaptcha_config(self) -> dict[str, Any]:
        return {
            "enabled": bool(self.recaptcha_enabled),
            "mode": self.recaptcha_mode,
            "public_key": self.recaptcha_public_key or "",
            "threshold": float(self.recaptcha_score_threshold),
            "timeout": int(self.recaptcha_timeout_ms),
        }


# =====================================================================
# META TAGS
# =====================================================================
class VerificationMetaTag(models.Model):
    provider = models.CharField(max_length=50, db_index=True)
    name_attr = models.CharField(max_length=100)
    content_attr = models.CharField(max_length=255)
    description = models.TextField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]
        indexes = [models.Index(fields=["provider", "name_attr"], name="ver_meta_idx")]

    def __str__(self):
        return f"{self.provider}: {self.name_attr}"


# =====================================================================
# VERIFICATION FILES (SAFE)
# =====================================================================
class VerificationFile(models.Model):
    provider = models.CharField(max_length=50, db_index=True)
    file = models.FileField(upload_to="verification/")
    description = models.TextField(blank=True, default="")
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-uploaded_at"]
        indexes = [models.Index(fields=["provider"], name="ver_file_idx")]

    def __str__(self):
        name = getattr(self.file, "name", None)
        return f"{self.provider}: {name or '(invalid file)'}"

    # SAFE VALIDATION
    def clean(self):
        errors = {}

        # extension check
        try:
            ext = Path(self.file.name).suffix.lower()
            if ext not in _ALLOWED_VERIFICATION_EXTENSIONS:
                errors.setdefault("file", []).append(f"Unsupported extension: {ext}")
        except Exception:
            pass

        # size check
        try:
            if self.file.size > _MAX_VERIFICATION_FILE_BYTES:
                errors.setdefault("file", []).append(
                    f"File exceeds {_MAX_VERIFICATION_FILE_BYTES} bytes"
                )
        except Exception:
            pass

        if errors:
            raise ValidationError(errors)

    def save(self, *a, **kw):
        self.full_clean()
        return super().save(*a, **kw)


# =====================================================================
# THROUGH MODELS
# =====================================================================
class SiteSettingsMetaTagLink(models.Model):
    site_settings = models.ForeignKey(
        SiteSettings, on_delete=models.CASCADE, related_name="meta_tag_links"
    )
    meta_tag = models.ForeignKey(
        VerificationMetaTag, on_delete=models.CASCADE, related_name="site_links"
    )
    linked_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("site_settings", "meta_tag")
        indexes = [
            models.Index(
                fields=["site_settings", "meta_tag"], name="site_meta_link_idx"
            )
        ]


class SiteSettingsVerificationFileLink(models.Model):
    site_settings = models.ForeignKey(
        SiteSettings, on_delete=models.CASCADE, related_name="verification_file_links"
    )
    verification_file = models.ForeignKey(
        VerificationFile, on_delete=models.CASCADE, related_name="site_links"
    )
    linked_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("site_settings", "verification_file")
        indexes = [
            models.Index(
                fields=["site_settings", "verification_file"], name="site_file_link_idx"
            )
        ]


# =====================================================================
# TENANT SETTINGS
# =====================================================================
class TenantSiteSettings(models.Model):
    site = models.OneToOneField(
        Site, on_delete=models.CASCADE, related_name="tenant_settings"
    )

    theme_profile = models.CharField(max_length=50, blank=True, null=True)
    primary_color = models.CharField(
        max_length=7, blank=True, null=True, validators=[_HEX_COLOR_VALIDATOR]
    )
    secondary_color = models.CharField(
        max_length=7, blank=True, null=True, validators=[_HEX_COLOR_VALIDATOR]
    )

    meta_tags = models.ManyToManyField(VerificationMetaTag, blank=True)
    verification_files = models.ManyToManyField(VerificationFile, blank=True)

    class Meta:
        verbose_name = "Tenant Site Settings"

    def __str__(self):
        return f"Tenant settings for {getattr(self.site, 'domain', 'unknown')}"

    def get_colors(self) -> dict[str, str]:
        return {
            "primary": self.primary_color or "#0d6efd",
            "secondary": self.secondary_color or "#6c757d",
        }


--------------------------------------------
### FILE: apps\site_settings\signals.py
### SIZE: 1462 bytes
### HASH: 8F3B6DE19D4934F12A7177F57D58C75FE5B203986344359EC2B91901D27CFE46

from django.contrib.sites.models import Site
from django.core.cache import cache
from django.db.models.signals import post_delete, post_save
from django.dispatch import receiver

from .models import (
    SiteSettings,
    TenantSiteSettings,
    VerificationFile,
    VerificationMetaTag,
)
from apps.core.utils import feature_flags


def clear_site_settings_cache():
    """
    Invalidate all site settings caches.

    - Per-site caches use 'site_settings_<site_id>'.
    - Called whenever SiteSettings, TenantSiteSettings, or related verification
      resources are saved or deleted.
    """
    try:
        for site_id in Site.objects.values_list("id", flat=True):
            cache.delete(f"site_settings_{site_id}")
    except Exception:
        # During migrations or initial setup, Site table may not exist yet.
        pass


@receiver(post_save, sender=SiteSettings)
@receiver(post_delete, sender=SiteSettings)
@receiver(post_save, sender=VerificationMetaTag)
@receiver(post_delete, sender=VerificationMetaTag)
@receiver(post_save, sender=VerificationFile)
@receiver(post_delete, sender=VerificationFile)
@receiver(post_save, sender=TenantSiteSettings)
@receiver(post_delete, sender=TenantSiteSettings)
def invalidate_site_settings_cache(sender, **kwargs):
    """
    Signal handler to clear cached site settings whenever relevant models change.
    """
    clear_site_settings_cache()
    feature_flags.reset_cache()


--------------------------------------------
### FILE: apps\site_settings\tests.py
### SIZE: 61 bytes
### HASH: 16BD2BFAA5A5193DBE66207AF62D6B157D55F883C23F32F344103BCF9BB7C506

from django.test import TestCase

# Create your tests here.

--------------------------------------------
### FILE: apps\site_settings\urls.py
### SIZE: 1927 bytes
### HASH: 6B3A48C3B2566A9F82D2CED042446324EC459C1F7D278FBE2664D2C2E352A421

"""
apps.site_settings.urls
========================
Unified routing for GSMInfinity Site Settings module.

✓ Django 5.2+ Ready
✓ Namespaced under `site_settings`
✓ Safe, cache-friendly routing
✓ Aligned with actual available view functions
✓ No duplication, no dead routes
"""

from django.urls import path

from . import views

app_name = "site_settings"


urlpatterns = [
    # ---------------------------------------------------------------------
    # 🌐 Public Diagnostic / Admin-facing HTML View
    # ---------------------------------------------------------------------
    path(
        "",
        views.site_settings_view,
        name="site_settings",
    ),  # Admin diagnostic readable settings page
    # ---------------------------------------------------------------------
    # 🔧 JSON API for Frontend Bootstrapping
    # ---------------------------------------------------------------------
    path(
        "info/",
        views.settings_info,
        name="settings_info",
    ),
    # ---------------------------------------------------------------------
    # 🔐 Domain Verification Files (Google / Apple / Facebook)
    # ---------------------------------------------------------------------
    path(
        "verification/<str:filename>/",
        views.verification_file,
        name="verification_file",
    ),
    # ---------------------------------------------------------------------
    # 📜 Public Policy & Legal Pages (GDPR Compliant)
    # ---------------------------------------------------------------------
    path(
        "privacy/",
        views.privacy_policy,
        name="privacy_policy",
    ),
    path(
        "terms/",
        views.terms_of_service,
        name="terms_of_service",
    ),
    path(
        "cookies/",
        views.cookies_policy,
        name="cookies_policy",
    ),
]

--------------------------------------------
### FILE: apps\site_settings\views.py
### SIZE: 12157 bytes
### HASH: 809991DCED047FDF55A6964C6B39C19C5708B34AA9BF2D5EE4FE5F2EEBBAEAD3

"""
apps.site_settings.views
========================
Enterprise-grade Views for GSMInfinity Site & Tenant Settings.

✓ Django 5.2+ / Python 3.12+
✓ Zero deprecated APIs
✓ Stable, import-safe, drop-in replacement
✓ Tenant-aware settings resolution
✓ Safe verification file serving
✓ JSON bootstrap for frontend
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, Dict, Optional

from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.http import Http404, HttpRequest, HttpResponse, JsonResponse
from django.shortcuts import redirect, render
from django.utils.functional import SimpleLazyObject
from django.views.decorators.cache import cache_page
from django.views.decorators.http import require_GET
from django.views.decorators.vary import vary_on_headers

from .models import SiteSettings, TenantSiteSettings

log = logging.getLogger(__name__)


# =====================================================================================
# INTERNAL: SETTINGS SNAPSHOT SERIALIZER (stable & safe)
# =====================================================================================


def _settings_snapshot(obj: Any) -> Dict[str, Any]:
    """
    Convert a SiteSettings or TenantSiteSettings instance into a pure dict.
    Completely defensive → never throws exceptions.
    """
    try:
        payload = {
            "site_name": getattr(obj, "site_name", "GSMInfinity"),
            "site_header": getattr(obj, "site_header", ""),
            "site_description": getattr(obj, "site_description", ""),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "enable_password_reset": bool(getattr(obj, "enable_password_reset", True)),
            "recaptcha_enabled": bool(getattr(obj, "recaptcha_enabled", False)),
            "require_mfa": bool(getattr(obj, "require_mfa", False)),
            "max_login_attempts": int(getattr(obj, "max_login_attempts", 5)),
            "rate_limit_window_seconds": int(
                getattr(obj, "rate_limit_window_seconds", 300)
            ),
            "enable_tenants": bool(getattr(obj, "enable_tenants", False)),
            "enable_blog": bool(getattr(obj, "enable_blog", True)),
            "enable_blog_comments": bool(
                getattr(obj, "enable_blog_comments", True)
            ),
            # Branding / theme keys used by base.html and JS bootstrap
            "primary_color": getattr(obj, "primary_color", "#0d6efd"),
            "secondary_color": getattr(obj, "secondary_color", "#6c757d"),
            "logo": (
                getattr(obj, "logo", None).url if getattr(obj, "logo", None) else None
            ),
            "dark_logo": (
                getattr(obj, "dark_logo", None).url
                if getattr(obj, "dark_logo", None)
                else None
            ),
            "favicon": (
                getattr(obj, "favicon", None).url
                if getattr(obj, "favicon", None)
                else None
            ),
            "meta_tags": [],
            "verification_files": [],
        }

        # -------------------------
        # META TAGS
        # -------------------------
        meta = getattr(obj, "meta_tags", None)
        if meta:
            try:
                if hasattr(meta, "values"):
                    payload["meta_tags"] = list(meta.values("name", "content"))
                else:
                    payload["meta_tags"] = [
                        {
                            "name": getattr(m, "name", ""),
                            "content": getattr(m, "content", ""),
                        }
                        for m in meta
                    ]
            except Exception:
                log.debug("Meta tag serialization failed", exc_info=True)

        # -------------------------
        # VERIFICATION FILES
        # -------------------------
        vfiles = getattr(obj, "verification_files", None)
        if vfiles:
            try:
                if hasattr(vfiles, "values"):
                    payload["verification_files"] = list(vfiles.values("id", "file"))
                else:
                    out = []
                    for vf in vfiles:
                        f = getattr(vf, "file", None)
                        out.append(
                            {
                                "id": getattr(vf, "id", None),
                                "file": getattr(f, "name", None),
                                "url": getattr(f, "url", None),
                            }
                        )
                    payload["verification_files"] = out
            except Exception:
                log.debug("Verification file serialization failed", exc_info=True)

        return payload

    except Exception as exc:
        log.exception("settings_snapshot fallback triggered: %s", exc)
        return {
            "site_name": "GSMInfinity",
            "site_header": "",
            "site_description": "",
            "enable_signup": True,
            "enable_password_reset": True,
            "recaptcha_enabled": False,
            "require_mfa": False,
            "max_login_attempts": 5,
            "rate_limit_window_seconds": 300,
            "primary_color": "#0d6efd",
            "secondary_color": "#6c757d",
            "logo": None,
            "dark_logo": None,
            "favicon": None,
            "meta_tags": [],
            "verification_files": [],
        }


# =====================================================================================
# INTERNAL: TENANT-AWARE SETTINGS RESOLVER (stable)
# =====================================================================================


def _get_settings(request: Optional[HttpRequest] = None) -> Dict[str, Any]:
    """
    Return final effective settings (tenant → global).
    Fully defensive: never raises, always returns stable dict.
    """

    try:
        if request:
            try:
                domain = get_current_site(request).domain
            except Exception:
                domain = request.get_host()
        else:
            domain = "global"

        cache_key = f"active_site_settings::{domain}"
        cached = cache.get(cache_key)
        if cached:
            return cached

        obj = None

        # Tenant overrides (if available)
        if request:
            try:
                site = get_current_site(request)
                obj = (
                    TenantSiteSettings.objects.select_related("site")
                    .prefetch_related("meta_tags", "verification_files")
                    .filter(site=site)
                    .first()
                )
            except Exception:
                obj = None

        # Global fallback
        if obj is None:
            try:
                obj = SiteSettings.get_solo()
            except Exception:
                obj = None

        snapshot = _settings_snapshot(obj)
        cache.set(cache_key, snapshot, timeout=300)
        return snapshot

    except Exception as exc:
        log.exception("_get_settings FAIL: %s", exc)
        fallback = _settings_snapshot(object())
        cache.set("active_site_settings::fallback", fallback, timeout=60)
        return fallback


# =====================================================================================
# PUBLIC JSON API
# =====================================================================================


@require_GET
@vary_on_headers("Host")
@cache_page(60)
def settings_info(request: HttpRequest) -> JsonResponse:
    """Return JSON bootstrap settings for frontend."""
    s = _get_settings(request)

    try:
        domain = get_current_site(request).domain
    except Exception:
        domain = request.get_host()

    return JsonResponse(
        {
            "site_name": s.get("site_name", "GSMInfinity"),
            "site_header": s.get("site_header", ""),
            "site_description": s.get("site_description", ""),
            "site_domain": domain,
            "enable_signup": s.get("enable_signup", True),
            "enable_password_reset": s.get("enable_password_reset", True),
            "recaptcha_enabled": s.get("recaptcha_enabled", False),
            "require_mfa": s.get("require_mfa", False),
            "max_login_attempts": s.get("max_login_attempts", 5),
            "rate_limit_window_seconds": s.get("rate_limit_window_seconds", 300),
        },
        json_dumps_params={"indent": 2},
    )


# ⭐⭐⭐ CRITICAL: URL COMPATIBILITY ALIAS ⭐⭐⭐
# Your project references views.info → so we alias it.
info = settings_info


# =====================================================================================
# ADMIN DIAGNOSTIC VIEW
# =====================================================================================


@require_GET
@vary_on_headers("Host")
@cache_page(300)
def site_settings_view(request: HttpRequest) -> HttpResponse:
    """Visible to staff/admin only — shows full active settings."""
    s = SimpleLazyObject(lambda: _get_settings(request))
    return render(
        request,
        "site_settings/detail.html",
        {
            "site_settings": s,
            "meta_tags": s.get("meta_tags", []),
            "verification_files": s.get("verification_files", []),
        },
    )


# =====================================================================================
# PUBLIC — POLICY PAGES
# =====================================================================================


@require_GET
@vary_on_headers("Host")
@cache_page(600)
def privacy_policy(request: HttpRequest) -> HttpResponse:
    return render(
        request,
        "site_settings/privacy.html",
        {"site_settings": _get_settings(request)},
    )


@require_GET
@vary_on_headers("Host")
@cache_page(600)
def terms_of_service(request: HttpRequest) -> HttpResponse:
    return render(
        request,
        "site_settings/terms.html",
        {"site_settings": _get_settings(request)},
    )


@require_GET
@vary_on_headers("Host")
@cache_page(600)
def cookies_policy(request: HttpRequest) -> HttpResponse:
    """Cookies policy view — commonly used from consent app."""
    return render(
        request,
        "site_settings/cookies.html",
        {"site_settings": _get_settings(request)},
    )


# =====================================================================================
# PUBLIC — VERIFICATION FILE SERVING
# =====================================================================================


@require_GET
def verification_file(request: HttpRequest, filename: str) -> HttpResponse:
    """
    Serve Google/Facebook/Apple domain verification files safely.

    Ensures:
    - no directory traversal
    - only .txt / .html allowed
    - tenant overrides supported
    - secure redirect to storage URL
    """

    safe = Path(filename).name  # prevent traversal
    allowed_ext = {".html", ".txt"}

    s = _get_settings(request)
    vfiles = s.get("verification_files", [])

    match = None

    for entry in vfiles:
        try:
            if isinstance(entry, dict):
                name = (entry.get("file") or "").lower()
                url = entry.get("url")
            else:
                name = str(entry).lower()
                url = None

            if name.endswith(safe.lower()):
                match = {"name": name, "url": url}
                break

        except Exception:
            continue

    if not match:
        raise Http404("Verification file not found")

    if not any(match["name"].endswith(ext) for ext in allowed_ext):
        raise Http404("Invalid verification file type")

    if match.get("url"):
        return redirect(match["url"])

    raise Http404("Verification file has no storage URL")


--------------------------------------------
### FILE: apps\tags\__init__.py
### SIZE: 16 bytes
### HASH: 593CE5DE23A74F92C03B67A68C8B2A638D060F5F60F9F16A8AF62E4399F8EB29

# tags app init


--------------------------------------------
### FILE: apps\tags\admin.py
### SIZE: 373 bytes
### HASH: E491DE480EB1711E09E197FC517ECE778D3B1C85BD7A611B08E3E115991D2863

from django.contrib import admin

from .models import Tag


@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = ("name", "slug", "usage_count", "is_active", "is_deleted")
    list_filter = ("is_active", "is_deleted")
    search_fields = ("name", "slug", "synonyms")
    prepopulated_fields = {"slug": ("name",)}
    readonly_fields = ("usage_count",)


--------------------------------------------
### FILE: apps\tags\apps.py
### SIZE: 171 bytes
### HASH: ECCAF46E61ED8B94BD588085D638F07C5EDD4CC31B2DBCD99AA0E680615AB945

from django.apps import AppConfig


class TagsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.tags"
    verbose_name = "Tags"


--------------------------------------------
### FILE: apps\tags\models.py
### SIZE: 1586 bytes
### HASH: 4EBEFF905A5AF3040C50E8C6162EFBD01D22953B77A32FC5FC8823BCEC49AB02

from __future__ import annotations

from django.db import models
from django.utils.text import slugify
from apps.core.models import TimestampedModel, SoftDeleteModel


class Tag(TimestampedModel, SoftDeleteModel):
    name = models.CharField(max_length=64, unique=True, help_text="Use concise, reusable names.")
    normalized_name = models.CharField(max_length=64, blank=True)
    slug = models.SlugField(max_length=80, unique=True, blank=True)
    description = models.TextField(blank=True, default="", help_text="Explain when to use this tag.")
    synonyms = models.JSONField(default=list, blank=True, help_text="Comma-separated alternatives users might search.")
    usage_count = models.PositiveIntegerField(default=0)
    co_occurrence = models.JSONField(default=dict, blank=True)
    is_active = models.BooleanField(default=True)
    ai_suggested = models.BooleanField(default=False, help_text="True if suggested by AI and not yet curated.")
    usage_count = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ["name"]

    def __str__(self) -> str:
        return self.name

    def save(self, *args, **kwargs):
        if not self.normalized_name:
            self.normalized_name = self.name.lower().strip()
        if not self.slug:
            base = slugify(self.name)[:75]
            candidate = base
            idx = 1
            while Tag.objects.filter(slug=candidate).exclude(pk=self.pk).exists():
                candidate = f"{base}-{idx}"
                idx += 1
            self.slug = candidate
        super().save(*args, **kwargs)


--------------------------------------------
### FILE: apps\tags\urls.py
### SIZE: 413 bytes
### HASH: 1D8E008E54EF2DCE9FB7C061DC47DB7B69EBCE6CB972F2323590918FA189721E

from django.urls import path

from . import views

app_name = "tags"

urlpatterns = [
    path("search/", views.search, name="search"),
    path("suggest/", views.suggest_tags, name="suggest"),
    path("merge/", views.merge_tags, name="merge"),
    path("analytics/", views.tag_analytics, name="analytics"),
    path("", views.tag_list, name="list"),
    path("<slug:slug>/", views.tag_detail, name="detail"),
]


--------------------------------------------
### FILE: apps\tags\views.py
### SIZE: 4599 bytes
### HASH: D0B4FC092C03BC1D7EAD54BE73DC23ACC2972DB07A4989941E9EBA7056084E8F

from __future__ import annotations

from django.http import JsonResponse, Http404, HttpRequest, HttpResponse
from django.views.decorators.http import require_GET, require_POST
from django.db.models import Q
from django.shortcuts import render, get_object_or_404
from django.core.paginator import Paginator
from django.contrib.auth.decorators import login_required

from .models import Tag
from apps.blog.models import Post, PostStatus
from django.template.loader import render_to_string
from django.utils import timezone
from apps.core import ai_client


@require_GET
def search(request):
    """
    Tag autocomplete/search endpoint.
    """
    q = request.GET.get("q", "").strip()
    qs = Tag.objects.filter(is_active=True, is_deleted=False)
    if q:
        qs = qs.filter(Q(name__icontains=q) | Q(normalized_name__icontains=q))
    qs = qs.order_by("-usage_count", "name")[:20]
    items = [
        {
            "name": t.name,
            "slug": t.slug,
            "usage_count": t.usage_count,
            "synonyms": t.synonyms,
            "description": t.description,
        }
        for t in qs
    ]
    return JsonResponse({"items": items})


def tag_list(request: HttpRequest) -> HttpResponse:
    tags = Tag.objects.filter(is_active=True, is_deleted=False).order_by("-usage_count", "name")
    return render(request, "tags/list.html", {"tags": tags})


def tag_detail(request: HttpRequest, slug: str) -> HttpResponse:
    tag = get_object_or_404(Tag, slug=slug, is_deleted=False)
    now_ts = timezone.now()
    posts = (
        Post.objects.filter(tags=tag, status=PostStatus.PUBLISHED, publish_at__lte=now_ts)
        .select_related("author", "category")
        .prefetch_related("tags")
        .order_by("-published_at")
    )
    paginator = Paginator(posts, 10)
    page_obj = paginator.get_page(request.GET.get("page") or 1)
    trending_tags = Tag.objects.order_by("-usage_count")[:10]
    trending_tags = trending_tags.filter(is_deleted=False)
    latest = (
        Post.objects.filter(status=PostStatus.PUBLISHED, publish_at__lte=now_ts)
        .order_by("-published_at")[:5]
    )
    trending_tags_html = render_to_string(
        "components/tag_badges.html", {"tags": trending_tags}
    )
    latest_widget_html = render_to_string(
        "blog/partials/latest_widget.html", {"posts": latest}
    )
    return render(
        request,
        "tags/detail.html",
        {
            "tag": tag,
            "posts": page_obj.object_list,
            "page_obj": page_obj,
            "trending_tags_html": trending_tags_html,
            "latest_widget_html": latest_widget_html,
        },
    )


@login_required
@require_POST
def merge_tags(request: HttpRequest) -> JsonResponse:
    """
    Simple admin/staff merge: expects source_slug -> target_slug, reassign posts, delete source.
    """
    if not (request.user.is_staff or request.user.is_superuser):
        return JsonResponse({"ok": False, "error": "forbidden"}, status=403)
    source_slug = request.POST.get("source")
    target_slug = request.POST.get("target")
    if not source_slug or not target_slug or source_slug == target_slug:
        return JsonResponse({"ok": False, "error": "invalid"}, status=400)
    source = get_object_or_404(Tag, slug=source_slug, is_deleted=False)
    target = get_object_or_404(Tag, slug=target_slug, is_deleted=False)
    posts = Post.objects.filter(tags=source)
    for p in posts:
        p.tags.add(target)
        p.tags.remove(source)
    source.is_deleted = True
    source.is_active = False
    source.save(update_fields=["is_deleted", "is_active"])
    target.usage_count = target.posts.count()
    target.save(update_fields=["usage_count"])
    return JsonResponse({"ok": True, "merged": source_slug, "into": target_slug})


def tag_analytics(request: HttpRequest) -> HttpResponse:
    tags = Tag.objects.order_by("-usage_count", "name")[:50]
    data = [{"name": t.name, "usage": t.usage_count} for t in tags]
    return JsonResponse({"items": data})


@require_POST
def suggest_tags(request: HttpRequest) -> JsonResponse:
    """
    AI tag suggestions endpoint; requires explicit acceptance on the client.
    """
    text = (request.POST.get("text") or "").strip()
    if not text:
        return JsonResponse({"ok": False, "error": "empty"}, status=400)
    try:
        suggestions = ai_client.suggest_tags(text, request.user if request.user.is_authenticated else None)
        return JsonResponse({"ok": True, "suggestions": suggestions})
    except Exception:
        return JsonResponse({"ok": False, "error": "failed"}, status=500)


--------------------------------------------
### FILE: apps\users\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855

System.Object[]

--------------------------------------------
### FILE: apps\users\adapters.py
### SIZE: 5026 bytes
### HASH: 5DD063FCA63893F667C328EA4336ECEE9B2745677C55E8B2FCCA39EF851D2F03

"""
Enterprise-grade Account & Social Adapters for GSMInfinity.
Integrates OAuth onboarding, trusted social email verification, and safe redirects.
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from allauth.account.adapter import DefaultAccountAdapter
from allauth.socialaccount.adapter import DefaultSocialAccountAdapter
from allauth.socialaccount.models import SocialLogin
from django.conf import settings
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.http import HttpRequest
from django.urls import NoReverseMatch, reverse
from django.utils.translation import gettext_lazy as _

logger = logging.getLogger(__name__)


def _safe_reverse(name: str, default: str = "/") -> str:
    """Best-effort reverse that never raises; used for login/onboarding redirects."""
    try:
        return reverse(name)
    except NoReverseMatch:
        logger.warning("reverse(%s) failed - fallback=%s", name, default)
        return default
    except Exception as exc:
        logger.exception("reverse(%s) unexpected error: %s", name, exc)
        return default


class CustomAccountAdapter(DefaultAccountAdapter):
    """Account adapter with hardened password rules and trusted social email."""

    def is_open_for_signup(self, request: Optional[HttpRequest]) -> bool:
        try:
            from apps.site_settings.models import SiteSettings  # type: ignore

            settings_obj = SiteSettings.get_solo()
            return bool(getattr(settings_obj, "enable_signup", True))
        except Exception as exc:
            logger.warning("Signup availability check failed: %s", exc)
            return True

    def clean_password(self, password: str, user: Optional[Any] = None) -> str:
        if not isinstance(password, str):
            raise ValidationError(_("Invalid password format."))
        if len(password) < 8:
            raise ValidationError(_("Password must be at least 8 characters long."))
        if password.isdigit():
            raise ValidationError(_("Password cannot be entirely numeric."))
        return super().clean_password(password, user)

    def is_email_verified(self, user):
        try:
            social = getattr(user, "socialaccount_set", None)
            if social and social.first():
                return True
        except Exception:
            pass
        return super().is_email_verified(user)

    def get_login_redirect_url(self, request: HttpRequest) -> str:
        try:
            user = getattr(request, "user", None)
            if user and getattr(user, "email_verified_at", None) is None:
                verification_required = False
                if getattr(user, "manual_signup", False):
                    verification_required = True
                elif (
                    getattr(settings, "ACCOUNT_EMAIL_VERIFICATION", "optional")
                    == "mandatory"
                ):
                    verification_required = True

                if verification_required:
                    try:
                        messages.info(request, _("Please verify your email to continue."))
                    except Exception:
                        pass
                    return _safe_reverse("users:verify_email", default="/")
        except Exception as exc:
            logger.exception("Login redirect evaluation failed: %s", exc)
        return _safe_reverse("users:dashboard", default="/")

    def get_signup_redirect_url(self, request: HttpRequest) -> str:
        return _safe_reverse("users:tell_us_about_you", default="/users/profile/")


class CustomSocialAccountAdapter(DefaultSocialAccountAdapter):
    """Social adapter that trusts provider email and defers completion to onboarding."""

    def get_connect_redirect_url(self, request: HttpRequest, socialaccount) -> str:
        logger.debug(
            "Social connect redirect (provider=%s)",
            getattr(socialaccount, "provider", None),
        )
        return _safe_reverse("users:tell_us_about_you", default="/users/profile/")

    def get_signup_redirect_url(self, request: HttpRequest) -> str:
        logger.debug("Social signup redirect -> users:tell_us_about_you")
        return _safe_reverse("users:tell_us_about_you", default="/users/profile/")

    def pre_social_login(self, request: HttpRequest, sociallogin: SocialLogin) -> None:
        """
        Keep minimal: if the user is already fully onboarded, do nothing.
        Otherwise, let EnforceProfileCompletionMiddleware drive them to the
        tell-us-about-you flow.
        """
        try:
            user = getattr(sociallogin, "user", None)
            if user and getattr(user, "id", None) and getattr(
                user, "profile_completed", False
            ):
                return
            logger.debug("pre_social_login: social login requires onboarding.")
        except Exception as exc:
            logger.exception("pre_social_login fatal error: %s", exc)
            return


--------------------------------------------
### FILE: apps\users\admin.py
### SIZE: 13092 bytes
### HASH: 44B0CAE20CC92CFA629399AA2A63A31C1B6E9BCA28819A1475387B88CA30ADC1

# apps/users/admin.py
"""
apps.users.admin
================
Enterprise admin interfaces for user-related models in GSMInfinity.

Features:
- Robust CustomUser admin
- Inline DeviceFingerprint management (read-only)
- Notification + Announcement dashboards
- Bulk admin actions
- Export support (import_export) when installed
- Does NOT break when import_export is absent
- ZERO silent errors
- Django 5.x compatible

IMPORTANT FIX:
--------------
ExportMixin **does not subclass ModelAdmin**, so we must ALWAYS
wrap it inside a ModelAdmin subclass to avoid:

    ValueError: Wrapped class must subclass ModelAdmin.

This file includes a safe BaseAdminClass that prevents the crash
while preserving your export features.
"""

from __future__ import annotations

import logging
from typing import Iterable, Optional

from django.contrib import admin, messages
from django.db.models import QuerySet
from django.http import HttpRequest
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.conf import settings

logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------
# Optional import_export integration — fixed so it never breaks admin
# --------------------------------------------------------------------------
try:
    from import_export.admin import ExportMixin  # type: ignore

    _HAS_IMPORT_EXPORT = True
except Exception:
    ExportMixin = None
    _HAS_IMPORT_EXPORT = False


# --------------------------------------------------------------------------
# MODELS (exactly as present in your models.py)
# --------------------------------------------------------------------------
from .models import Announcement, CustomUser, DeviceFingerprint, Notification

# ==========================================================================
# FIXED BASE ADMIN CLASS
# ==========================================================================
"""
Your earlier file used `BaseAdminClass = ExportMixin`, which FAILS because
ExportMixin does NOT inherit from admin.ModelAdmin.

THE FIX:
    If import_export is available:
        class BaseAdminClass(ExportMixin, admin.ModelAdmin)
    else:
        class BaseAdminClass(admin.ModelAdmin)

This guarantees that @admin.register(...) always receives a ModelAdmin subclass.
"""

if _HAS_IMPORT_EXPORT and ExportMixin:

    class BaseAdminClass(ExportMixin, admin.ModelAdmin):
        """Safe hybrid admin class."""

        pass

else:

    class BaseAdminClass(admin.ModelAdmin):
        """Fallback admin when import_export is not installed."""

        pass


# ==========================================================================
# DeviceFingerprint Inline (read-only)
# ==========================================================================
class DeviceFingerprintInline(admin.TabularInline):
    """Read-only inline for a user's registered device fingerprints."""

    model = DeviceFingerprint
    extra = 0
    can_delete = False
    show_change_link = True
    ordering = ("-last_used_at",)

    readonly_fields = (
        "fingerprint_hash",
        "os_info",
        "browser_info",
        "motherboard_id",
        "registered_at",
        "last_used_at",
        "is_active",
    )
    fields = readonly_fields

    verbose_name = _("Registered Device")
    verbose_name_plural = _("Registered Devices")

    def has_add_permission(self, request: HttpRequest, obj=None) -> bool:
        return False


# ==========================================================================
# CustomUser Admin
# ==========================================================================
@admin.register(CustomUser)
class CustomUserAdmin(BaseAdminClass):
    """Enterprise-grade admin for CustomUser."""

    list_display = (
        "email",
        "username",
        "full_name",
        "is_active",
        "is_staff",
        "is_superuser",
        "credits",
        "signup_method",
        "date_joined",
    )

    search_fields = (
        "email",
        "username",
        "full_name",
        "phone",
        "referral_code",
    )

    list_filter = (
        "is_active",
        "is_staff",
        "is_superuser",
        "signup_method",
    )

    readonly_fields = (
        "referral_code",
        "date_joined",
        "last_unlock",
    )

    ordering = ("-date_joined",)
    inlines = [DeviceFingerprintInline]
    save_on_top = True

    list_select_related = ()

    fieldsets = (
        (_("Authentication"), {"fields": ("email", "username", "password")}),
        (_("Personal Info"), {"fields": ("full_name", "phone", "referral_code")}),
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                )
            },
        ),
        (
            _("Additional Info"),
            {
                "fields": (
                    "credits",
                    "signup_method",
                    "last_unlock",
                    "date_joined",
                )
            },
        ),
    )

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        qs = super().get_queryset(request)
        try:
            return qs.prefetch_related("groups")
        except Exception:
            logger.debug("CustomUserAdmin.get_queryset prefetch failed", exc_info=True)
            return qs

    # ------------------------------------------------------------------
    # Admin action: mark selected users as email verified
    # ------------------------------------------------------------------
    @admin.action(description="Mark selected users as email verified (set now)")
    def mark_email_verified(self, request: HttpRequest, queryset: QuerySet) -> None:
        updated = (
            queryset.filter(email_verified_at__isnull=True)
            .update(email_verified_at=timezone.now())
        )
        # Sync allauth EmailAddress if installed
        try:
            from allauth.account.models import EmailAddress

            EmailAddress.objects.filter(user__in=queryset).update(
                verified=True, primary=True
            )
        except Exception:
            logger.debug("EmailAddress sync skipped or failed", exc_info=True)

        if updated:
            self.message_user(
                request, _(f"{updated} user(s) marked as verified."), messages.SUCCESS
            )
        else:
            self.message_user(request, _("No users updated."), messages.INFO)

    actions = ["mark_email_verified"]


# ==========================================================================
# DeviceFingerprint Admin
# ==========================================================================
@admin.register(DeviceFingerprint)
class DeviceFingerprintAdmin(BaseAdminClass):
    """Admin interface for device fingerprints."""

    list_display = (
        "user_display",
        "fingerprint_hash_short",
        "os_info",
        "browser_info",
        "last_used_at",
        "is_active",
    )

    list_filter = ("is_active", "os_info", "browser_info")

    search_fields = (
        "fingerprint_hash",
        "user__email",
        "user__username",
        "browser_info",
    )

    readonly_fields = ("registered_at", "last_used_at")
    ordering = ("-last_used_at",)
    list_select_related = ("user",)

    save_on_top = True

    @admin.display(description=_("User"))
    def user_display(self, obj: DeviceFingerprint) -> str:
        return (
            getattr(obj.user, "email", None)
            or getattr(obj.user, "username", None)
            or f"User #{obj.user_id}"
        )

    @admin.display(description=_("Fingerprint"))
    def fingerprint_hash_short(self, obj: DeviceFingerprint) -> str:
        if not obj.fingerprint_hash:
            return "—"
        return f"{obj.fingerprint_hash[:16]}…"


# ==========================================================================
# Notification Admin
# ==========================================================================
@admin.register(Notification)
class NotificationAdmin(BaseAdminClass):
    """Admin interface for Notifications."""

    list_display = (
        "recipient_display",
        "title",
        "priority",
        "channel",
        "is_read",
        "created_at",
        "read_at",
    )

    list_filter = ("priority", "channel", "is_read", "created_at")
    search_fields = ("title", "message", "recipient__email", "recipient__username")
    ordering = ("-created_at",)
    readonly_fields = ("created_at", "read_at")
    list_select_related = ("recipient",)
    save_on_top = True

    actions = ["mark_selected_read"]

    if _HAS_IMPORT_EXPORT:
        actions.append("export_selected_as_csv")

    @admin.display(description=_("Recipient"))
    def recipient_display(self, obj: Notification) -> str:
        return (
            getattr(obj.recipient, "email", None)
            or getattr(obj.recipient, "username", None)
            or "Anonymous"
        )

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        qs = super().get_queryset(request)
        try:
            return qs.select_related("recipient")
        except Exception:
            logger.debug("NotificationAdmin.get_queryset failed", exc_info=True)
            return qs

    def mark_selected_read(self, request: HttpRequest, queryset: QuerySet):
        try:
            updated = queryset.filter(is_read=False).update(is_read=True)
            self.message_user(request, _("%d notifications marked as read.") % updated)
        except Exception as exc:
            logger.exception("Failed to mark notifications read: %s", exc)
            self.message_user(
                request,
                _("Failed to mark notifications as read."),
                level=messages.ERROR,
            )

    def export_selected_as_csv(self, request: HttpRequest, queryset: QuerySet):
        self.message_user(
            request, _("Use the Export button above to export notifications.")
        )


# ==========================================================================
# Announcement Admin
# ==========================================================================
@admin.register(Announcement)
class AnnouncementAdmin(BaseAdminClass):
    """Admin for announcements."""

    list_display = (
        "title",
        "audience",
        "is_global",
        "created_by_display",
        "start_at",
        "expires_at",
        "is_active_display",
    )

    search_fields = ("title", "message")
    list_filter = ("audience", "is_global", "expires_at")
    readonly_fields = ("created_by",)
    ordering = ("-start_at",)
    save_on_top = True
    actions = ["publish_selected", "unpublish_selected"]

    def save_model(self, request, obj, form, change):
        if not change and not obj.created_by:
            obj.created_by = request.user
        super().save_model(request, obj, form, change)

    @admin.display(description=_("Created By"))
    def created_by_display(self, obj: Announcement):
        return (
            getattr(obj.created_by, "email", None)
            or getattr(obj.created_by, "username", None)
            or "—"
        )

    @admin.display(description=_("Active?"))
    def is_active_display(self, obj: Announcement):
        try:
            return "✅" if obj.is_active else "❌"
        except Exception:
            return "—"

    def publish_selected(self, request, queryset):
        try:
            count = queryset.update(is_active=True)
            self.message_user(request, _("%d announcements published.") % count)
        except Exception:
            logger.exception("Failed to publish announcements")
            self.message_user(
                request, _("Failed to publish announcements."), level=messages.ERROR
            )

    def unpublish_selected(self, request, queryset):
        try:
            count = queryset.update(is_active=False)
            self.message_user(request, _("%d announcements unpublished.") % count)
        except Exception:
            logger.exception("Failed to unpublish announcements")
            self.message_user(
                request, _("Failed to unpublish announcements."), level=messages.ERROR
            )


# ==========================================================================
# Admin Branding
# ==========================================================================
admin.site.site_header = _("GSMInfinity Administration")
admin.site.index_title = _("Enterprise Control Panel")
admin.site.site_title = _("GSMInfinity Admin Portal")


--------------------------------------------
### FILE: apps\users\api.py
### SIZE: 873 bytes
### HASH: 7BB2D84CAF5E11669BDB4BA0A8F20D9A0E2E82B82D54B02F9944F3E192CF2A4F

from __future__ import annotations

from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpRequest

from .models import Notification


@login_required
def notifications_unread_json(request: HttpRequest) -> JsonResponse:
    """
    Lightweight JSON endpoint for unread notifications.
    Returns up to 20 most recent unread items for header dropdowns.
    """
    qs = (
        Notification.objects.filter(recipient=request.user, is_read=False)
        .order_by("-created_at")[:20]
    )
    items = [
        {
            "id": n.id,
            "title": n.title,
            "message": n.message,
            "priority": n.priority,
            "channel": n.channel,
            "created_at": n.created_at.isoformat() if n.created_at else None,
        }
        for n in qs
    ]
    return JsonResponse({"items": items})


--------------------------------------------
### FILE: apps\users\apps.py
### SIZE: 3158 bytes
### HASH: 0B0BFFCBD5D85B5F5C695A4A325B16B7A1D5CAD6AF818E385CFB6244FA30B274

"""
apps.users.apps
================
Application configuration for GSMInfinity's Users module.

✅ Responsibilities:
- Auto-register user signals (login, signup, profile creation)
- Integrate cleanly with django-allauth adapters/forms
- Async-safe startup; ORM import-guarded
- Autodiscover any "signals" submodules across installed apps
- Zero deprecations for Django 5.2 LTS + allauth 0.65.13
"""

from __future__ import annotations

import logging

from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class UsersConfig(AppConfig):
    """
    Enterprise-grade AppConfig for user management.

    Loads signals and cross-app hooks exactly once per process.
    Safe during migrations, tests, shell, or async contexts.
    """

    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.users"
    label = "users"
    verbose_name = "User Management"

    def ready(self) -> None:
        """
        Initialization hook executed when Django finishes app loading.

        Tasks performed:
        1️⃣  Import this app's local signals safely.
        2️⃣  Autodiscover any `signals.py` modules across installed apps.
        3️⃣  Provide extension hook for future warm-ups or audits.
        """
        logger = logging.getLogger(__name__)

        # ---------------------------------------------------------------
        # 1️⃣ Import local signal handlers (safe guarded)
        # ---------------------------------------------------------------
        try:
            import apps.users.signals  # noqa: F401

            logger.debug("UsersConfig → signals imported successfully.")
        except ImportError as exc:
            # Signal import errors should never break app startup.
            logger.warning("UsersConfig: unable to import signals (%s)", exc)
        except Exception as exc:
            logger.exception("UsersConfig: unexpected error loading signals → %s", exc)

        # ---------------------------------------------------------------
        # 2️⃣ Autodiscover cross-app signal modules (optional)
        # ---------------------------------------------------------------
        try:
            autodiscover_modules("signals")
            logger.debug("UsersConfig → autodiscovered 'signals' modules across apps.")
        except Exception as exc:
            # Do not fail on autodiscovery — some apps may not have signals.
            logger.debug(
                "UsersConfig: autodiscover_modules('signals') failed → %s", exc
            )

        # ---------------------------------------------------------------
        # 3️⃣ Future-proof extension hook (keep light)
        # ---------------------------------------------------------------
        # Example future tasks:
        #   - Warm up cache for active devices
        #   - Schedule initial audit tasks
        #   - Load feature-flag toggles
        #
        # Must remain non-blocking and ORM-safe.
        logger.debug("UsersConfig.ready() completed successfully.")
        return

--------------------------------------------
### FILE: apps\users\auth_backends.py
### SIZE: 5040 bytes
### HASH: 5DF9C55512D249A9E28691C22FCE678150F57ADA64FF3AAB52C356AB6A496542

# apps/users/auth_backends.py
"""
Enterprise-grade multi-identifier authentication backend for GSMInfinity.

✅ Login via email, username, or phone (case-insensitive)
✅ Compatible with django-allauth and Django admin
✅ Safe against enumeration and timing leaks
✅ RFC 7613 Unicode normalization (casefold)
✅ Structured logging and exception safety
✅ Lazy model resolution to avoid import-time circulars
"""

from __future__ import annotations

import logging
from typing import Any, Optional, Sequence

from django.contrib.auth import get_user_model
from django.contrib.auth.backends import ModelBackend
from django.core.exceptions import MultipleObjectsReturned
from django.db.models import Q

logger = logging.getLogger(__name__)


class MultiFieldAuthBackend(ModelBackend):
    """
    Authenticate users by email, username, or phone number.

    Compatible with Django admin, django-allauth, and session auth.
    """

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    @staticmethod
    def _normalize_identifier(identifier: str) -> str:
        """
        Normalize user identifier to lowercase and strip whitespace.

        Uses str.casefold() for Unicode-safe comparisons (RFC 7613).
        """
        return str(identifier or "").strip().casefold()

    # ------------------------------------------------------------------
    # Authentication
    # ------------------------------------------------------------------
    def authenticate(
        self,
        request=None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs,
    ) -> Optional[Any]:
        """
        Authenticate using email, username, or phone.
        Returns user instance or None.
        """
        if not username or password is None:
            logger.debug("Authentication attempt missing credentials.")
            return None

        identifier = self._normalize_identifier(username)
        UserModel = get_user_model()
        user = None

        try:
            # Filter by any accepted identifier (case-insensitive)
            qs = UserModel.objects.filter(
                Q(email__iexact=identifier)
                | Q(username__iexact=identifier)
                | Q(phone__iexact=identifier)
            ).distinct()

            # Load at most two rows to detect duplicates cheaply
            candidates: Sequence[UserModel] = list(qs[:2])

            if not candidates:
                # Perform dummy hash work to equalize timing and mitigate enumeration
                try:
                    dummy = UserModel()
                    dummy.set_password(password)
                    dummy.check_password(password)
                except Exception:
                    # best-effort only; never raise
                    pass
                logger.debug("No user found for identifier=%s", identifier)
                return None

            if len(candidates) > 1:
                logger.warning("Multiple accounts share identifier=%s", identifier)

            user = candidates[0]

        except MultipleObjectsReturned:
            logger.warning("Duplicate users detected for identifier=%s", identifier)
            return None
        except Exception as exc:
            logger.exception(
                "User lookup failed for identifier=%s → %s", identifier, exc
            )
            return None

        # Verify password in timing-safe manner
        try:
            if (
                user
                and user.check_password(password)
                and self.user_can_authenticate(user)
            ):
                logger.info(
                    "User %s authenticated successfully",
                    getattr(user, "email", user.pk),
                )
                return user
            else:
                logger.debug(
                    "Invalid credentials or inactive account for %s", identifier
                )
        except Exception as exc:
            logger.exception(
                "Password verification failed for %s → %s", identifier, exc
            )

        return None

    # ------------------------------------------------------------------
    # User Retrieval
    # ------------------------------------------------------------------
    def get_user(self, user_id: Any) -> Optional[Any]:
        """
        Retrieve user safely for session authentication.
        """
        UserModel = get_user_model()
        try:
            return UserModel.objects.get(pk=user_id)
        except UserModel.DoesNotExist:
            logger.debug("get_user: User not found id=%s", user_id)
            return None
        except Exception as exc:
            logger.exception("get_user failed for id=%s → %s", user_id, exc)
            return None

--------------------------------------------
### FILE: apps\users\backends.py
### SIZE: 467 bytes
### HASH: EA05FFAA2F6F72194FA586EDE69D8BBFE8CE540E9BCD02CDDB71DFD06D70166E

"""
apps.users.backends
-------------------
Import shim for backward and settings compatibility.
Delegates to apps.users.auth_backends.MultiFieldAuthBackend.
"""

from __future__ import annotations

import sys
from importlib import import_module

module = import_module("apps.users.auth_backends")

# expose all public names (safe passthrough)
globals().update(module.__dict__)

# ensure dotted-path import consistency
sys.modules[__name__] = module

--------------------------------------------
### FILE: apps\users\context_processors.py
### SIZE: 477 bytes
### HASH: 8E0CA3FFC97AC1514281BB273FCC85A4DF4262BA5B5B72C1A04CA507017FD368

"""
Lightweight user context processors.
"""


def auth_status(request):
    """
    Inject a stable auth flag used by templates/JS toggles.
    """
    try:
        is_auth = bool(getattr(request, "user", None) and request.user.is_authenticated)
    except Exception:
        is_auth = False
    return {"auth_is_authenticated": is_auth}


# Backward compatibility for any legacy usage
def user_context(request):
    return {"is_authenticated": request.user.is_authenticated}


--------------------------------------------
### FILE: apps\users\forms.py
### SIZE: 11054 bytes
### HASH: 69DE3581DE04D8B31C2C2EA1999DC3B84F35B6D178EA9C6D6FE646F9355996A7

"""
GSMInfinity - Custom Allauth Signup & Onboarding Forms
------------------------------------------------------
✅ Compatible with django-allauth ≥ 0.65.13 and Django 5.2 LTS
✅ Prevents circular imports during startup
✅ Implements required `signup(self, request, user)` API
✅ Enforces enterprise-grade validation and password policy
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from django import forms
from django.contrib.auth import get_user_model, password_validation
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from django.utils.module_loading import import_string
from django.utils.translation import gettext_lazy as _

logger = logging.getLogger(__name__)
User = get_user_model()


class CustomSignupForm(forms.Form):
    """
    Enterprise-grade wrapper around django-allauth's signup system.
    Lazy-loads allauth internals only when required to avoid circular imports.
    """

    email = forms.EmailField(
        max_length=255,
        label=_("Email address"),
        widget=forms.EmailInput(
            attrs={
                "autocomplete": "email",
                "placeholder": _("Email"),
                "class": "form-control",
            }
        ),
    )

    username = forms.CharField(
        max_length=150,
        label=_("Username"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "username",
                "placeholder": _("Username"),
                "class": "form-control",
            }
        ),
    )

    password1 = forms.CharField(
        label=_("Password"),
        strip=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Password"),
                "class": "form-control",
            }
        ),
    )

    password2 = forms.CharField(
        label=_("Confirm password"),
        strip=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Confirm password"),
                "class": "form-control",
            }
        ),
    )

    referral_code = forms.CharField(
        max_length=12,
        required=False,
        label=_("Referral code (optional)"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "off",
                "placeholder": _("Referral code"),
                "class": "form-control",
            }
        ),
    )

    def __init__(self, *args, **kwargs):
        self.request = kwargs.pop("request", None)
        super().__init__(*args, **kwargs)
        # Prefill referral from ?ref=CODE if present
        try:
            if self.request and self.request.GET.get("ref"):
                code = (self.request.GET.get("ref") or "").strip().upper()[:12]
                if code:
                    self.initial.setdefault("referral_code", code)
        except Exception:
            pass

    @property
    def base_form_class(self):
        """Load django-allauth's internal SignupForm lazily."""
        return import_string("allauth.account.forms.SignupForm")

    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip().casefold()
        if not email or "@" not in email:
            raise ValidationError(_("Enter a valid email address."))
        if User.objects.filter(email__iexact=email).exists():
            raise ValidationError(_("A user with this email already exists."))
        return email

    def clean_username(self) -> str:
        username = (self.cleaned_data.get("username") or "").strip()
        if len(username) < 3:
            raise ValidationError(_("Username must be at least 3 characters long."))
        if User.objects.filter(username__iexact=username).exists():
            raise ValidationError(_("This username is already taken."))
        return username

    def clean_password1(self) -> str:
        password = self.cleaned_data.get("password1") or ""
        if len(password) < 8:
            raise ValidationError(_("Password must be at least 8 characters long."))
        try:
            password_validation.validate_password(password)
        except ValidationError as e:
            raise ValidationError(e.messages)
        return password

    def clean(self) -> dict[str, Any]:
        cleaned = super().clean()
        pwd1, pwd2 = cleaned.get("password1"), cleaned.get("password2")
        if pwd1 and pwd2 and pwd1 != pwd2:
            raise ValidationError(_("Passwords do not match."))
        return cleaned

    def clean_referral_code(self) -> str:
        code = (self.cleaned_data.get("referral_code") or "").strip().upper()
        if not code:
            return ""
        try:
            from apps.users.models import CustomUser  # local import

            exists = CustomUser.objects.filter(referral_code__iexact=code).exists()
            if not exists:
                raise ValidationError(_("Invalid referral code."))
        except ValidationError:
            raise
        except Exception as exc:
            logger.debug("Referral code lookup failed: %s", exc)
        return code

    def signup(self, request, user):
        """
        Called automatically by allauth after successful form validation.
        Populates and saves the user instance using GSMInfinity logic.
        """
        user.username = self.cleaned_data.get("username")
        user.email = self.cleaned_data.get("email")

        if hasattr(user, "generate_verification_code"):
            try:
                user.verification_code = user.generate_verification_code()
                logger.debug("Generated verification code for %s", user.email)
            except Exception as exc:
                logger.warning("Verification code generation failed for %s: %s", user.email, exc)

        password = self.cleaned_data.get("password1")
        user.set_password(password)

        if hasattr(user, "is_active") and user.is_active is False:
            user.is_active = True

        if hasattr(user, "manual_signup"):
            user.manual_signup = True
        if hasattr(user, "signup_method"):
            user.signup_method = "manual"

        # Attach referral if provided
        ref_code = (self.cleaned_data.get("referral_code") or "").strip().upper()
        if ref_code and hasattr(user, "referred_by"):
            from apps.users.models import CustomUser  # local import

            referrer = CustomUser.objects.filter(referral_code__iexact=ref_code).first()
            if referrer and referrer != user:
                user.referred_by = referrer

        user.save()
        logger.info("New user created via signup: %s", user.email)
        return user

    def save(self, request):
        user = User()
        return self.signup(request, user)

    def try_save(self, request):
        return self.save(request)


class TellUsAboutYouForm(forms.Form):
    """
    Shared onboarding form for both social and manual signups.
    Requires username + full name.
    Requires password only if the user does not yet have one (typical for social signups).
    """

    username = forms.CharField(
        max_length=150,
        label=_("Username"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "username",
                "placeholder": _("Choose a username"),
                "class": "form-control",
            }
        ),
    )

    full_name = forms.CharField(
        max_length=150,
        label=_("Full name"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "name",
                "placeholder": _("Your full name"),
                "class": "form-control",
            }
        ),
    )

    password1 = forms.CharField(
        label=_("Password"),
        required=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Create a password"),
                "class": "form-control",
            }
        ),
    )

    password2 = forms.CharField(
        label=_("Confirm password"),
        required=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Confirm password"),
                "class": "form-control",
            }
        ),
    )

    referral_code = forms.CharField(
        max_length=12,
        required=False,
        label=_("Referral code (optional)"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "off",
                "placeholder": _("Referral code"),
                "class": "form-control",
            }
        ),
    )

    def __init__(self, *args, user=None, request=None, **kwargs):
        self.user = user
        self.request = request
        super().__init__(*args, **kwargs)

        # Require password only if user has no usable password (typical for social)
        self.require_password = bool(user and not user.has_usable_password())
        if self.require_password:
            self.fields["password1"].required = True
            self.fields["password2"].required = True

    def clean_username(self):
        username = (self.cleaned_data.get("username") or "").strip()
        if not username:
            raise ValidationError(_("Username is required."))

        UserModel = get_user_model()
        qs = UserModel.objects.filter(username__iexact=username)
        if self.user and self.user.pk:
            qs = qs.exclude(pk=self.user.pk)
        if qs.exists():
            raise ValidationError(_("This username is already taken."))
        return username

    def clean(self):
        cleaned = super().clean()
        p1 = cleaned.get("password1") or ""
        p2 = cleaned.get("password2") or ""

        if self.require_password:
            if not p1 or not p2:
                raise ValidationError(_("Password is required."))
            if p1 != p2:
                raise ValidationError(_("Passwords do not match."))
            validate_password(p1, self.user)

        return cleaned

    def clean_referral_code(self):
        code = (self.cleaned_data.get("referral_code") or "").strip().upper()
        if not code:
            return ""
        try:
            from apps.users.models import CustomUser  # local import

            exists = CustomUser.objects.filter(referral_code__iexact=code).exists()
            if not exists:
                raise ValidationError(_("Invalid referral code."))
        except ValidationError:
            raise
        except Exception as exc:
            logger.debug("Referral lookup failed in onboarding: %s", exc)
        return code


# ----------------------------------------------------------------------
# Legacy Social onboarding form (kept for compatibility)
# ----------------------------------------------------------------------


--------------------------------------------
### FILE: apps\users\mfa.py
### SIZE: 8175 bytes
### HASH: BFF9405521928A7A18166E2CE847EAA043564A05C3673E1CC779C2050A38763A

"""
apps.users.mfa
==============

Enterprise-grade Multi-Factor Authentication (MFA) utilities.

✔ Django 5.2 / Python 3.12 compliant
✔ RFC 6238 (TOTP) + RFC 4226 (HOTP) compliant
✔ Timing-attack resistant comparisons
✔ Stable issuer rules with no branding
✔ Hardened Base32 handling (no secret leakage)
✔ Drift-tolerant window verification
"""

from __future__ import annotations

import base64
import binascii
import hashlib
import hmac
import logging
import secrets
import time
from typing import Optional
from urllib.parse import quote_plus

from apps.site_settings.models import SiteSettings

logger = logging.getLogger(__name__)

DEFAULT_ISSUER = "Account Portal"


# =====================================================================
# BASE32 HELPERS
# =====================================================================
def _base32_pad(secret: str) -> str:
    """
    Normalize & pad Base32 secret for decoding.
    - Removes spaces
    - Uppercases
    - Pads to a multiple of 8 chars
    """
    s = secret.strip().replace(" ", "").upper()
    if not s:
        raise ValueError("Empty Base32 secret.")
    pad = (-len(s)) % 8
    return s + ("=" * pad)


def _base32_decode(secret: str) -> bytes:
    """
    Decode Base32 secret with strict safety.
    Logs errors without leaking the secret.
    Raises ValueError on failure.
    """
    try:
        padded = _base32_pad(secret)
        return base64.b32decode(padded, casefold=True)
    except (binascii.Error, ValueError, TypeError) as exc:
        logger.exception("Invalid Base32 secret (decode failure).")
        raise ValueError("Invalid Base32 secret") from exc


# =====================================================================
# TOTP (RFC-6238)
# =====================================================================
class TOTPService:
    """
    RFC 6238 TOTP implementation.
    Generates TOTP codes compatible with:
        - Google Authenticator
        - Authy
        - Microsoft Authenticator

    Public methods:
        generate_secret()
        generate_current_code()
        verify()
    """

    @staticmethod
    def generate_secret(num_bytes: int = 20) -> str:
        """
        Generate a secure Base32 secret.
        Returned secret contains no '=' padding.
        """
        raw = secrets.token_bytes(num_bytes)
        enc = base64.b32encode(raw).decode("ascii")
        return enc.rstrip("=")

    @staticmethod
    def _hotp_from_bytes(key: bytes, counter: int, digits: int = 6) -> str:
        """
        RFC-4226 HOTP implementation using HMAC-SHA1.
        """
        msg = counter.to_bytes(8, "big")
        digest = hmac.new(key, msg, hashlib.sha1).digest()
        offset = digest[-1] & 0x0F
        part = digest[offset : offset + 4]
        binary = int.from_bytes(part, "big") & 0x7FFFFFFF
        return str(binary % (10**digits)).zfill(digits)

    @staticmethod
    def generate_current_code(
        secret: str,
        period: int = 30,
        digits: int = 6,
        at_time: Optional[int] = None,
    ) -> str:
        """
        Generate TOTP code for current time or custom timestamp.
        """
        ts = int(at_time if at_time is not None else time.time())
        counter = ts // period
        key = _base32_decode(secret)
        return TOTPService._hotp_from_bytes(key, counter, digits)

    @staticmethod
    def verify(
        secret: str,
        code: str,
        tolerance: int = 1,
        period: int = 30,
        digits: int = 6,
    ) -> bool:
        """
        Verify TOTP with ±tolerance window.

        Returns:
            True  — valid token
            False — invalid or malformed

        Never raises; logs safe diagnostic info only.
        """
        try:
            code_str = str(code).strip().zfill(digits)
            key = _base32_decode(secret)
            counter = int(time.time()) // period

            for offset in range(-tolerance, tolerance + 1):
                expected = TOTPService._hotp_from_bytes(key, counter + offset, digits)
                if hmac.compare_digest(expected, code_str):
                    return True

            return False

        except Exception:
            logger.exception("TOTP verification error (invalid secret or input).")
            return False


# =====================================================================
# MFA POLICY (from SiteSettings)
# =====================================================================
class MFAEnforcer:
    """
    Read-only MFA policy provider.

    Reads from SiteSettings:
        require_mfa
        mfa_totp_issuer
        site_name

    Never raises — always returns safe values.
    """

    @staticmethod
    def required() -> bool:
        """Return True if MFA is globally required."""
        try:
            settings_obj = SiteSettings.get_solo()
            return bool(getattr(settings_obj, "require_mfa", False))
        except Exception:
            logger.warning("Failed to read require_mfa; defaulting to False.")
            return False

    @staticmethod
    def issuer() -> str:
        """
        Return MFA issuer string with safe fallbacks:
            1) mfa_totp_issuer
            2) generic default (to avoid branding leakage)
        """
        try:
            s = SiteSettings.get_solo()
            return (
                getattr(s, "mfa_totp_issuer", None)
                or DEFAULT_ISSUER
            )
        except Exception:
            logger.warning("Failed to read MFA issuer; using default.")
            return DEFAULT_ISSUER

    @staticmethod
    def provisioning_uri(
        secret: str,
        user_email: str,
        label: Optional[str] = None,
        digits: int = 6,
        period: int = 30,
        issuer: Optional[str] = None,
    ) -> str:
        """
        Build otpauth:// URI for QR provisioning.

        Example:
            otpauth://totp/Issuer:email?secret=ABC123&issuer=Issuer&digits=6&period=30
        """
        try:
            actual_issuer = issuer or MFAEnforcer.issuer()

            if label:
                full_label = f"{actual_issuer}:{label}"
            else:
                full_label = f"{actual_issuer}:{user_email}"

            label_encoded = quote_plus(full_label)
            issuer_encoded = quote_plus(actual_issuer)
            secret_str = _base32_pad(secret).replace("=", "")

            params = (
                f"secret={secret_str}"
                f"&issuer={issuer_encoded}"
                f"&algorithm=SHA1"
                f"&digits={digits}"
                f"&period={period}"
            )

            return f"otpauth://totp/{label_encoded}?{params}"

        except Exception:
            logger.exception("Failed to build provisioning URI.")
            raise


# =====================================================================
# OPTIONAL SECRET STORAGE HELPERS
# =====================================================================
def hmac_store_secret(secret: str, pepper: str) -> str:
    """
    Hash a secret using server-side pepper. Store the resulting digest in DB.
    """
    if not pepper:
        raise ValueError("pepper is required.")
    return hmac.new(pepper.encode(), secret.encode(), hashlib.sha256).hexdigest()


def compare_hmac_secret(stored_hmac: str, candidate_secret: str, pepper: str) -> bool:
    """
    Validate candidate secret against stored HMAC using constant-time comparison.
    """
    if not pepper:
        logger.warning("compare_hmac_secret() called without pepper.")
        return False
    try:
        candidate = hmac.new(
            pepper.encode(), candidate_secret.encode(), hashlib.sha256
        ).hexdigest()
        return hmac.compare_digest(stored_hmac, candidate)
    except Exception:
        logger.exception("compare_hmac_secret() error.")
        return False


__all__ = ["TOTPService", "MFAEnforcer", "hmac_store_secret", "compare_hmac_secret"]


--------------------------------------------
### FILE: apps\users\middleware\mfa_enforce.py
### SIZE: 2040 bytes
### HASH: 8B79574BD5DA238C7DDE863A9187F78D67AD4BAF8B3D68D061686A2243FF6DC1

from __future__ import annotations

from typing import Iterable

from django.shortcuts import redirect
from django.urls import resolve, reverse


class EnforceMfaMiddleware:
    """
    Enforce MFA/device registration when SiteSettings.require_mfa is enabled.

    - Skips static/admin/api/consent paths.
    - Applies only to authenticated users.
    - Redirects to devices page for enrollment.
    """

    SAFE_URL_NAMES: Iterable[str] = {
        "users:devices",
        "account_login",
        "account_logout",
        "account_signup",
    }
    SAFE_PATH_PREFIXES: Iterable[str] = (
        "/admin",
        "/static",
        "/media",
        "/api",
        "/consent",
        "/.well-known",
    )

    def __init__(self, get_response):
        self.get_response = get_response
        self.devices_url = reverse("users:devices")

    def __call__(self, request):
        user = getattr(request, "user", None)

        try:
            from apps.site_settings.models import SiteSettings

            ss = SiteSettings.get_solo()
            require_mfa = bool(getattr(ss, "require_mfa", False))
        except Exception:
            require_mfa = False

        if not require_mfa or not user or not user.is_authenticated:
            return self.get_response(request)

        path = request.path
        for prefix in self.SAFE_PATH_PREFIXES:
            if path.startswith(prefix):
                return self.get_response(request)

        try:
            match = request.resolver_match or resolve(path)
            if match and match.view_name in self.SAFE_URL_NAMES:
                return self.get_response(request)
        except Exception:
            return self.get_response(request)

        # If user has no active device fingerprints, enforce enrollment
        try:
            if not user.device_fingerprints.filter(is_active=True).exists():
                return redirect(self.devices_url)
        except Exception:
            return self.get_response(request)

        return self.get_response(request)


--------------------------------------------
### FILE: apps\users\middleware\profile_completion.py
### SIZE: 4497 bytes
### HASH: EF8A8CF3FFC1E5FE56D42A1933F1843230E780240372E87B2A5A45E0A2FFFFF1

from __future__ import annotations

from typing import Iterable

from django.shortcuts import redirect
from django.urls import resolve, reverse


class EnforceProfileCompletionMiddleware:
    """
    Enterprise-grade enforcement that ensures authenticated users complete their profile
    before accessing the rest of the platform.

    Features:
    - Zero redirect loops
    - Excludes auth, admin, logout, static, consent, and health endpoints
    - Ultra-fast: uses path startswith + resolver_match fallback
    - Compatible with Django 5.2+ and Allauth 0.65+
    - No accidental blocking of AJAX/HTMX/XHR/API endpoints
    - Compatible with non-HTML API requests (returns response unchanged)
    """

    # ----------------------------------------------------------------------
    # Pre-resolved URL names avoid repeated reverse() calls (micro-optimizing)
    # ----------------------------------------------------------------------
    PROFILE_URL_NAME = "users:tell_us_about_you"

    # URLs that must never be intercepted
    SAFE_URL_NAMES: Iterable[str] = {
        PROFILE_URL_NAME,
        "account_login",
        "account_logout",
        "account_signup",
        "account_reset_password",
        "account_reset_password_done",
        "account_reset_password_from_key",
        "account_reset_password_from_key_done",
    }

    # PATH prefixes to ignore entirely
    SAFE_PATH_PREFIXES: Iterable[str] = (
        "/admin",
        "/static",
        "/media",
        "/api",
        "/health",
        "/consent",  # prevent blocking when consent banner loads
        "/.well-known",  # allow ACME / verification endpoints
    )

    def __init__(self, get_response):
        self.get_response = get_response
        # compute once
        self.profile_url = reverse(self.PROFILE_URL_NAME)

    # ------------------------------------------------------------------
    # Main middleware
    # ------------------------------------------------------------------
    def __call__(self, request):

        user = getattr(request, "user", None)

        # Feature flag: allow disabling enforcement from SiteSettings
        try:
            from apps.site_settings.models import SiteSettings

            ss = SiteSettings.get_solo()
            # Only enforce profile/MFA flow when require_mfa flag is on
            if not getattr(ss, "require_mfa", False):
                return self.get_response(request)
        except Exception:
            pass

        # --- Fast exit for anonymous users ----------------------------------
        if not (user and user.is_authenticated):
            return self.get_response(request)

        # --- Do not run for admin/staff access to Django admin -------------
        if user.is_staff and request.path.startswith("/admin"):
            return self.get_response(request)

        # --- Already completed ---------------------------------------------
        if getattr(user, "profile_completed", True):
            return self.get_response(request)

        path = request.path

        # --- Safe paths (static, media, admin, consent, api...) ------------
        for prefix in self.SAFE_PATH_PREFIXES:
            if path.startswith(prefix):
                return self.get_response(request)

        # --- Prevent redirect loops ----------------------------------------
        if path == self.profile_url:
            return self.get_response(request)

        # --- Safe named routes (auth/login/signup etc.) --------------------
        try:
            # resolver_match is cached inside request by Django 5+
            match = request.resolver_match or resolve(path)
            if match and match.view_name in self.SAFE_URL_NAMES:
                return self.get_response(request)
        except Exception:
            # Resolving failure → allow request to proceed
            return self.get_response(request)

        # --- Prevent blocking of AJAX/HTMX/API --------------------------------
        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
            return self.get_response(request)
        if request.headers.get("HX-Request") == "true":
            return self.get_response(request)
        if request.content_type == "application/json":
            return self.get_response(request)

        # --- Finally: enforce redirect -------------------------------------
        return redirect(self.PROFILE_URL_NAME)


--------------------------------------------
### FILE: apps\users\models.py
### SIZE: 21280 bytes
### HASH: 472D93A2CB9E8F552572CAA2B6E8DD43E2F0DF775834F70F06CCA2129109A1F6

# apps/users/models.py
"""
apps/users/models.py

GSMInfinity — authoritative, enterprise-grade user models.

Design:
- CustomUser (email primary) with atomic referral generation
- DeviceFingerprint for MFA / trusted devices
- Notification & Announcement models
- Defensive DB operations and logging
- Compatible with Django 5.2+ / Python 3.12
"""

from __future__ import annotations

import logging
import re
import secrets
import string
import uuid
from typing import Any, Dict, Optional

from django.conf import settings
from django.contrib.auth.models import (
    AbstractBaseUser,
    BaseUserManager,
    PermissionsMixin,
)
from django.core.cache import cache
from django.db import IntegrityError, models, transaction
from django.utils import timezone
from django.utils.text import slugify

logger = logging.getLogger(__name__)

_PHONE_NORMALIZE_RE = re.compile(r"[^\d+]")  # keep digits and leading +


# --------------------------------------------------------------------------
# User manager
# --------------------------------------------------------------------------
class CustomUserManager(BaseUserManager):
    """Custom manager with unified user/superuser creation."""

    use_in_migrations = True

    def _create_user(
        self,
        email: str,
        username: Optional[str],
        password: Optional[str],
        **extra_fields: Any,
    ) -> "CustomUser":
        if not email:
            raise ValueError("An email address is required.")
        email = self.normalize_email(email).strip().lower()
        username = (username or email.split("@")[0]).strip()[:150]

        with transaction.atomic():
            user = self.model(email=email, username=username, **extra_fields)
            if password:
                user.set_password(password)
            else:
                user.set_unusable_password()
            user.save(using=self._db)
        return user

    def create_user(
        self,
        email: str,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **extra_fields: Any,
    ) -> "CustomUser":
        extra_fields.setdefault("is_staff", False)
        extra_fields.setdefault("is_superuser", False)
        extra_fields.setdefault("is_active", True)
        return self._create_user(email, username, password, **extra_fields)

    def create_superuser(
        self,
        email: str,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **extra_fields: Any,
    ) -> "CustomUser":
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("is_active", True)

        if not (extra_fields.get("is_staff") and extra_fields.get("is_superuser")):
            raise ValueError("Superuser must have is_staff=True and is_superuser=True.")
        return self._create_user(email, username, password, **extra_fields)


# --------------------------------------------------------------------------
# CustomUser
# --------------------------------------------------------------------------
class CustomUser(AbstractBaseUser, PermissionsMixin):
    """
    Core authentication model with referrals, verification & tracking.
    Email is the primary unique identifier.
    """

    # Identity
    email = models.EmailField(unique=True, db_index=True)
    username = models.CharField(
        max_length=150, unique=True, null=True, blank=True, db_index=True
    )
    full_name = models.CharField(max_length=150, blank=True, default="")

    # Profile
    country = models.CharField(max_length=100, blank=True)
    phone = models.CharField(max_length=20, unique=True, null=True, blank=True)
    currency = models.CharField(max_length=10, null=True, blank=True)
    class Roles(models.TextChoices):
        ADMIN = "admin", "Admin"
        EDITOR = "editor", "Editor"
        AUTHOR = "author", "Author"
        MODERATOR = "moderator", "Moderator"
        READER = "reader", "Reader"

    role = models.CharField(max_length=50, null=True, blank=True, choices=Roles.choices)

    # Permissions
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    # Credits & referrals
    credits = models.PositiveIntegerField(default=0)
    referral_code = models.CharField(
        max_length=12, unique=True, blank=True, db_index=True
    )
    referred_by = models.ForeignKey(
        "self",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name="referrals",
    )

    # Security & verification
    unlock_count = models.PositiveIntegerField(default=0)
    last_unlock = models.DateTimeField(null=True, blank=True)
    email_verified_at = models.DateTimeField(null=True, blank=True)
    verification_code = models.CharField(max_length=24, blank=True)

    # Signup metadata
    signup_method = models.CharField(
        max_length=20,
        choices=[("manual", "Manual"), ("social", "Social")],
        default="manual",
    )
    manual_signup = models.BooleanField(default=False)
    profile_completed = models.BooleanField(
        default=False,
        help_text="Indicates whether the user has completed their onboarding/profile setup.",
    )
    date_joined = models.DateTimeField(auto_now_add=True)

    # Manager / ID
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []  # keep empty to simplify superuser creation prompts
    objects = CustomUserManager()

    class Meta:
        ordering = ["-date_joined"]
        verbose_name = "User"
        verbose_name_plural = "Users"
        indexes = [
            models.Index(fields=["email"], name="user_email_idx"),
            models.Index(fields=["username"], name="user_username_idx"),
            models.Index(fields=["referral_code"], name="user_referral_idx"),
        ]

    def __str__(self) -> str:
        return self.email or (self.username or f"user-{self.pk}")

    # ============================================================
    # Minimal model clean / normalization
    # ============================================================
    def clean(self) -> None:
        # Normalize email and phone before validations
        if self.email:
            self.email = str(self.email).strip().lower()
        if self.phone:
            # strip separators but keep leading plus if present
            normalized = _PHONE_NORMALIZE_RE.sub("", str(self.phone))
            self.phone = normalized

    # ============================================================
    # Referral system (atomic and bounded)
    # ============================================================
    @staticmethod
    def _generate_referral_candidate() -> str:
        """
        Generate a referral candidate of length 12 using secure randomness.
        """
        base = uuid.uuid4().hex[:8].upper()
        suffix_chars = string.ascii_uppercase + string.digits
        suffix = "".join(secrets.choice(suffix_chars) for _ in range(4))
        return f"{base}{suffix}"[:12]

    def _attempt_assign_referral(self, candidate: str) -> bool:
        """
        Try atomic assignment of referral code on the DB record for this user.
        Returns True if assignment succeeded; False otherwise.
        """
        try:
            with transaction.atomic():
                obj = CustomUser.objects.select_for_update().get(pk=self.pk)
                if obj.referral_code:
                    self.referral_code = obj.referral_code
                    return True
                if CustomUser.objects.filter(referral_code=candidate).exists():
                    return False
                obj.referral_code = candidate
                obj.save(update_fields=["referral_code"])
                self.referral_code = candidate
                return True
        except IntegrityError:
            logger.debug("Referral collision for candidate=%s", candidate)
            return False
        except Exception as exc:
            logger.exception("Referral assignment failed for %s → %s", candidate, exc)
            return False

    def save(self, *args, **kwargs) -> None:
        """
        Auto-generate referral_code atomically if missing.
        Ensures at least one save occurs to obtain PK before assignment attempts.
        """
        # Basic normalization + username generation for new objects
        try:
            self.clean()
        except Exception:
            # never block save because of normalization issues
            logger.debug("cleanup failed in save(); proceeding with save")

        # If new instance without PK, create a minimal row to obtain PK
        if not self.pk:
            if not self.username and self.email:
                base = self.email.split("@")[0][:120]
                slug = slugify(base) or f"user{secrets.token_hex(3)}"
                # avoid trivial slug collisions (best-effort)
                if CustomUser.objects.filter(username=slug).exists():
                    slug = f"{slug[:10]}{secrets.token_hex(2)}"
                self.username = slug
            super().save(*args, **kwargs)

        # If referral_code still missing, attempt assignment
        if not self.referral_code:
            max_attempts = 8
            assigned_candidate: Optional[str] = None
            for _ in range(max_attempts):
                cand = self._generate_referral_candidate()
                reserve_key = f"refcode:{cand}"
                reserved = False
                try:
                    reserved = cache.add(reserve_key, True, timeout=5)
                except Exception:
                    reserved = False

                if not reserved:
                    continue

                try:
                    if self._attempt_assign_referral(cand):
                        assigned_candidate = cand
                        break
                finally:
                    if not assigned_candidate:
                        try:
                            cache.delete(reserve_key)
                        except Exception:
                            logger.debug(
                                "Failed to delete referral reservation key %s",
                                reserve_key,
                            )

            if not assigned_candidate:
                # fallback deterministic but unique-ish default
                stamp = int(timezone.now().timestamp()) % 100000
                suffix = secrets.randbelow(90000) + 10000
                fallback = f"REF{stamp}{suffix}"[:12].upper()
                try:
                    with transaction.atomic():
                        obj = CustomUser.objects.select_for_update().get(pk=self.pk)
                        if not obj.referral_code:
                            obj.referral_code = fallback
                            obj.save(update_fields=["referral_code"])
                            self.referral_code = fallback
                        else:
                            self.referral_code = obj.referral_code
                except Exception as exc:
                    logger.exception(
                        "Failed to persist fallback referral code for user %s → %s",
                        getattr(self, "pk", None),
                        exc,
                    )
                    self.referral_code = fallback

        # Final save to persist any other unsaved changes
        try:
            super().save(*args, **kwargs)
        except Exception as exc:
            logger.exception(
                "Failed to save user %s → %s", getattr(self, "email", None), exc
            )
            raise

    # ============================================================
    # Utilities
    # ============================================================
    @property
    def is_verified(self) -> bool:
        return bool(self.email_verified_at)

    def has_role(self, *roles: str) -> bool:
        if not self.role:
            return False
        return self.role in roles

    def is_admin(self) -> bool:
        return self.is_superuser or self.has_role(self.Roles.ADMIN)

    def is_editor(self) -> bool:
        return self.has_role(self.Roles.EDITOR)

    def is_author(self) -> bool:
        return self.has_role(self.Roles.AUTHOR)

    def is_moderator(self) -> bool:
        return self.has_role(self.Roles.MODERATOR)

    def mark_email_verified(self) -> None:
        if not self.email_verified_at:
            self.email_verified_at = timezone.now()
            try:
                self.save(update_fields=["email_verified_at"])
            except Exception as exc:
                logger.exception("Email verification update failed: %s", exc)

    def generate_verification_code(
        self, length: int = 6, code_type: str = "alphanumeric"
    ) -> str:
        alphabet = (
            string.digits
            if code_type == "numeric"
            else (string.ascii_uppercase + string.digits)
        )
        length = max(1, min(length, 24))
        code = "".join(secrets.choice(alphabet) for _ in range(length))
        self.verification_code = code
        try:
            self.save(update_fields=["verification_code"])
        except Exception as exc:
            logger.exception(
                "Verification code save failed for %s → %s", self.email, exc
            )
        return code

    def increment_unlock(self) -> None:
        try:
            self.unlock_count = (self.unlock_count or 0) + 1
            self.last_unlock = timezone.now()
            self.save(update_fields=["unlock_count", "last_unlock"])
        except Exception as exc:
            logger.exception("Unlock counter update failed: %s", exc)

    def add_credits(self, amount: int) -> None:
        if amount > 0:
            try:
                self.credits = (self.credits or 0) + int(amount)
                self.save(update_fields=["credits"])
            except Exception as exc:
                logger.exception("Credit update failed: %s", exc)


# --------------------------------------------------------------------------
# DeviceFingerprint
# --------------------------------------------------------------------------
class DeviceFingerprint(models.Model):
    """Tracks device/browser identifiers for MFA and session trust."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="device_fingerprints",
    )
    fingerprint_hash = models.CharField(max_length=128)
    os_info = models.CharField(max_length=100, blank=True)
    motherboard_id = models.CharField(max_length=100, blank=True)
    browser_info = models.CharField(max_length=255, blank=True)
    registered_at = models.DateTimeField(auto_now_add=True)
    last_used_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["user", "fingerprint_hash"], name="unique_user_fingerprint"
            )
        ]
        ordering = ["-last_used_at"]
        verbose_name = "Device Fingerprint"
        verbose_name_plural = "Device Fingerprints"
        indexes = [
            models.Index(fields=["user", "is_active"], name="device_user_active_idx")
        ]

    def __str__(self) -> str:
        return f"{getattr(self.user, 'email', 'unknown')} · {self.fingerprint_hash[:8]}"

    def fingerprint_hash_short(self) -> str:
        return (self.fingerprint_hash or "")[:16]


# --------------------------------------------------------------------------
# Notification
# --------------------------------------------------------------------------
class Notification(models.Model):
    """Multi-channel user notifications with audit timestamps."""

    PRIORITY_CHOICES = [
        ("info", "Info"),
        ("warning", "Warning"),
        ("critical", "Critical"),
    ]
    CHANNEL_CHOICES = [
        ("web", "Web"),
        ("email", "Email"),
        ("sms", "SMS"),
        ("push", "Push"),
    ]

    recipient = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="notifications",
    )
    title = models.CharField(max_length=255)
    message = models.TextField()
    priority = models.CharField(max_length=20, choices=PRIORITY_CHOICES, default="info")
    channel = models.CharField(max_length=20, choices=CHANNEL_CHOICES, default="web")
    created_at = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)
    read_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Notification"
        verbose_name_plural = "Notifications"
        indexes = [
            models.Index(
                fields=["recipient", "is_read"], name="notif_recipient_read_idx"
            )
        ]

    def __str__(self) -> str:
        return f"{self.title} → {getattr(self.recipient, 'email', 'unknown')}"

    def mark_as_read(self) -> None:
        if not self.is_read:
            self.is_read = True
            self.read_at = timezone.now()
            try:
                self.save(update_fields=["is_read", "read_at"])
            except Exception as exc:
                logger.exception("Failed to mark notification read: %s", exc)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.pk,
            "title": self.title,
            "message": self.message,
            "priority": self.priority,
            "channel": self.channel,
            "is_read": bool(self.is_read),
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "read_at": self.read_at.isoformat() if self.read_at else None,
        }

    def to_json(self) -> Dict[str, Any]:
        return self.to_dict()

    def author_schema(self) -> Dict[str, Any]:
        """Basic author schema info for SEO."""
        return {
            "@type": "Person",
            "name": self.full_name or self.username or self.email,
            "url": getattr(self, "profile_url", None) or "",
        }


# --------------------------------------------------------------------------
# Announcement
# --------------------------------------------------------------------------
class Announcement(models.Model):
    """Global or segmented announcements for users or staff."""

    AUDIENCE_CHOICES = [
        ("all", "All"),
        ("user", "Users"),
        ("staff", "Staff"),
    ]

    title = models.CharField(max_length=255)
    message = models.TextField()
    audience = models.CharField(max_length=20, choices=AUDIENCE_CHOICES, default="all")
    is_global = models.BooleanField(default=False)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        on_delete=models.SET_NULL,
        related_name="created_announcements",
    )
    start_at = models.DateTimeField(default=timezone.now)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Announcement"
        verbose_name_plural = "Announcements"
        indexes = [
            models.Index(
                fields=["is_global", "start_at"], name="announce_global_start_idx"
            )
        ]

    def __str__(self) -> str:
        return self.title

    def active_now(self) -> bool:
        now = timezone.now()
        if self.start_at and self.start_at > now:
            return False
        if self.expires_at and self.expires_at <= now:
            return False
        return bool(self.is_global or self.audience)

    def deactivate_if_expired(self) -> None:
        if self.expires_at and self.expires_at < timezone.now() and self.is_global:
            self.is_global = False
            try:
                self.save(update_fields=["is_global"])
            except Exception as exc:
                logger.exception("Failed to deactivate expired announcement: %s", exc)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.pk,
            "title": self.title,
            "message": self.message,
            "audience": self.audience,
            "is_global": bool(self.is_global),
            "start_at": self.start_at.isoformat() if self.start_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "created_by": getattr(self.created_by, "email", None)
            or getattr(self.created_by, "username", None)
            or None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    def to_json(self) -> Dict[str, Any]:
        return self.to_dict()


--------------------------------------------
### FILE: apps\users\notifications_urls.py
### SIZE: 723 bytes
### HASH: A710032E055F47E01D781FD3B4716779D03358DE455A55D673903B54ADDA8626

from __future__ import annotations

from django.urls import path

from .views_notifications import (
    notification_detail,
    notification_list,
    notification_mark_all_read,
    notification_mark_read,
    notification_unread_count,
)

app_name = "users_notifications"

urlpatterns = [
    # HTML
    path("", notification_list, name="list"),
    path(
        "<int:pk>/", notification_detail, name="detail"
    ),  # ✔ matches view PK type (INT)
    # JSON
    path("count/unread/", notification_unread_count, name="unread_count"),
    # Mutations
    path("mark/<int:pk>/", notification_mark_read, name="mark_read"),
    path("mark-all/", notification_mark_all_read, name="mark_all"),
]

--------------------------------------------
### FILE: apps\users\services\notifications.py
### SIZE: 1561 bytes
### HASH: E13897E24EA167AF173A169D79D25A19B4E572C9D14D8FFB89F28273AEAD203B

from __future__ import annotations

import logging
from typing import Optional

from apps.users.models import Notification
from django.contrib.auth import get_user_model
from django.db import transaction
from django.utils import timezone

logger = logging.getLogger(__name__)
User = get_user_model()


def send_notification(
    recipient: User,
    title: str,
    message: str,
    level: str = "info",  # mapped to model.priority
    url: Optional[str] = None,
    actor: Optional[User] = None,
    channel: Optional[str] = None,  # NEW: support channel field
) -> Optional[Notification]:
    """
    Safely create a notification for a user.
    Returns the Notification instance or None on error.
    """

    try:
        with transaction.atomic():
            n = Notification.objects.create(
                recipient=recipient,
                title=title[:255],
                message=message,
                priority=level,  # FIXED: your model uses 'priority'
                url=url or "",
                actor=actor,
                channel=channel,  # NEW: support channel usage
                # created_at auto_set by model default (best practice)
            )

            # Optional: trigger websockets / signals / push
            # publish_notification(n)

            return n

    except Exception as exc:
        logger.exception(
            "Failed to create notification for user %s: %s",
            getattr(recipient, "pk", None),
            exc,
        )
        return None

--------------------------------------------
### FILE: apps\users\services\rate_limit.py
### SIZE: 4040 bytes
### HASH: 6245F08D790316E126636596AFA70627C2E71EDA12E5918AEED1583E6CEA5F64

"""
apps.users.services.rate_limit
------------------------------
Lightweight, cache-based rate limiter for authentication and signup actions.

✅ Features:
- Atomic per-key rate limiting
- Sliding window expiration
- Cache backend–agnostic (Redis, Memcached, LocMem)
- Zero external dependencies
- Self-healing against corrupted cache entries
- Minimal latency footprint (<1ms Redis)
"""

import logging
import time
from typing import List

from django.core.cache import cache

logger = logging.getLogger(__name__)


# ============================================================
#  RATE LIMIT CORE LOGIC
# ============================================================
def allow_action(
    key: str,
    max_attempts: int = 5,
    window_seconds: int = 300,
) -> bool:
    """
    Determines whether a given action (e.g., login attempt) is allowed
    under a sliding-window rate limit.

    Args:
        key (str): Unique cache key, e.g. `"login:ip:1.2.3.4"` or `"signup:user:123"`.
        max_attempts (int): Max number of allowed actions per window.
        window_seconds (int): Sliding time window in seconds.

    Returns:
        bool: True if action is allowed, False if rate limit exceeded.

    Behavior:
        ✅ Uses timestamp bucket stored in Django cache.
        ✅ Removes stale timestamps (outside sliding window).
        ✅ Handles cache corruption gracefully.
        ✅ Works across Redis, Memcached, or LocMem.
        ✅ Fails open on cache backend errors.
    """
    if not key:
        logger.warning("allow_action called with empty key.")
        return False

    now = time.time()

    try:
        bucket: List[float] = cache.get(key, [])
        if not isinstance(bucket, list):
            logger.warning(
                "Corrupted rate-limit bucket detected for %s; resetting.", key
            )
            bucket = []

        # Keep only timestamps within window
        bucket = [t for t in bucket if now - t <= window_seconds]

        # Exceeded?
        if len(bucket) >= max_attempts:
            logger.info(
                "Rate limit exceeded: key=%s, attempts=%d/%d, window=%ds",
                key,
                len(bucket),
                max_attempts,
                window_seconds,
            )
            return False

        # Add current attempt and persist
        bucket.append(now)

        # Set cache with sliding expiration
        cache.set(key, bucket, timeout=window_seconds)

        logger.debug(
            "Rate limit OK: key=%s, attempts=%d/%d, window=%ds",
            key,
            len(bucket),
            max_attempts,
            window_seconds,
        )
        return True

    except Exception as exc:
        # Fail-open to prevent blocking on cache outage
        logger.exception("Rate limiter backend failure for %s: %s", key, exc)
        return True


# ============================================================
#  RESET & UTILITY HELPERS
# ============================================================
def reset_rate_limit(key: str) -> None:
    """
    Clears the rate limiter for a given key.
    Useful for testing or manual unblocking after successful login.
    """
    try:
        cache.delete(key)
        logger.debug("Rate limit reset for key=%s", key)
    except Exception as exc:
        logger.warning("Failed to reset rate limit for %s: %s", key, exc)


def get_attempt_count(key: str, window_seconds: int = 300) -> int:
    """
    Returns the current number of attempts within the window for a key.
    Safe against corrupted cache values.
    """
    try:
        now = time.time()
        bucket: List[float] = cache.get(key, [])
        if not isinstance(bucket, list):
            return 0
        return len([t for t in bucket if now - t <= window_seconds])
    except Exception as exc:
        logger.warning("Failed to read attempt count for %s: %s", key, exc)
        return 0

--------------------------------------------
### FILE: apps\users\services\recaptcha.py
### SIZE: 8359 bytes
### HASH: 8AF91790E35355C98C11FDBA22060EE76907296841E59ECC36679B7882190926

"""
apps.users.services.recaptcha
=============================

Enterprise-Grade Google reCAPTCHA Verification Service

✅ Supports v2 + v3 with hostname verification
✅ Configurable thresholds via SiteSettings
✅ Token-level atomic caching (short-lived, cryptographic digest)
✅ Graceful degradation when disabled or unreachable
✅ Hardened against malformed tokens & network errors
✅ Fully typed, Django 5.2 / Python 3.12 compliant
✅ Zero silent failures, no unsafe hash() use
"""

from __future__ import annotations

import hashlib
import json
import logging
from decimal import Decimal
from typing import Any, Dict, Optional

import requests
from apps.site_settings.models import SiteSettings
from django.conf import settings as django_settings
from django.core.cache import cache
from requests import Response
from requests.exceptions import ConnectionError as RequestsConnectionError
from requests.exceptions import RequestException, Timeout

logger = logging.getLogger(__name__)

API_URL = "https://www.google.com/recaptcha/api/siteverify"
CACHE_TTL_SECONDS = 15


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _token_digest(token: str) -> str:
    """
    Return a stable SHA-256 digest for the given token.
    Avoids Python's built-in hash(), which is process-randomized.
    """
    return hashlib.sha256(token.encode("utf-8")).hexdigest()


def _safe_decimal(value: Any, default: Decimal = Decimal("0")) -> Decimal:
    """Safely convert a value to Decimal; return default on failure."""
    try:
        return Decimal(str(value))
    except Exception:
        return default


# ---------------------------------------------------------------------------
# Main Verification Function
# ---------------------------------------------------------------------------


def verify_recaptcha(
    token: str,
    remote_ip: Optional[str] = None,
    action: str = "login",
) -> Dict[str, Any]:
    """
    Verify a Google reCAPTCHA token using configuration from SiteSettings.

    Returns:
        {
            "ok": bool,
            "score": float | None,
            "errors": list[str],
            "error": str | None,  # internal issue, if any
        }
    """
    # ----------------------------------------------------------
    # Step 1. Load configuration
    # ----------------------------------------------------------
    try:
        settings_obj = SiteSettings.get_solo()
    except Exception as exc:
        logger.warning("reCAPTCHA: unable to load SiteSettings → %s", exc)
        return {"ok": False, "error": "settings_unavailable", "errors": []}

    recaptcha_enabled: bool = bool(getattr(settings_obj, "recaptcha_enabled", False))
    recaptcha_mode: str = str(getattr(settings_obj, "recaptcha_mode", "off")).lower()
    private_key: Optional[str] = getattr(settings_obj, "recaptcha_private_key", None)

    # ----------------------------------------------------------
    # Step 2. Skip if disabled
    # ----------------------------------------------------------
    if not recaptcha_enabled or recaptcha_mode == "off":
        logger.debug("reCAPTCHA: bypassed (disabled/off)")
        return {"ok": True, "score": None, "errors": []}

    # ----------------------------------------------------------
    # Step 3. Validate token input
    # ----------------------------------------------------------
    if not token or not isinstance(token, str) or len(token) > 10_000:
        logger.debug("reCAPTCHA: invalid token format")
        return {"ok": False, "error": "invalid_token_format", "errors": []}

    if not private_key:
        logger.error("reCAPTCHA: missing private key in SiteSettings")
        return {"ok": False, "error": "missing_credentials", "errors": []}

    # ----------------------------------------------------------
    # Step 4. Short-term cache check (digest-based)
    # ----------------------------------------------------------
    cache_key = f"recaptcha:{action}:{_token_digest(token)}"
    try:
        cached: Optional[Dict[str, Any]] = cache.get(cache_key)
        if cached is not None:
            logger.debug("reCAPTCHA: using cached result for %s", action)
            return cached
    except Exception as exc:
        logger.debug("reCAPTCHA: cache.get failed → %s", exc)

    # ----------------------------------------------------------
    # Step 5. Build request payload
    # ----------------------------------------------------------
    payload: Dict[str, str] = {"secret": private_key, "response": token}
    if remote_ip:
        payload["remoteip"] = remote_ip

    timeout_s: float = max(
        float(getattr(settings_obj, "recaptcha_timeout_ms", 3000)) / 1000.0, 1.0
    )

    # ----------------------------------------------------------
    # Step 6. Perform network verification
    # ----------------------------------------------------------
    try:
        resp: Response = requests.post(API_URL, data=payload, timeout=timeout_s)
        resp.raise_for_status()
        data = resp.json()
    except Timeout:
        logger.warning("reCAPTCHA: timeout verifying token (%s)", action)
        return {"ok": False, "error": "timeout", "errors": []}
    except RequestsConnectionError as exc:
        logger.error("reCAPTCHA: connection error → %s", exc)
        return {"ok": False, "error": "connection_error", "errors": []}
    except RequestException as exc:
        logger.error("reCAPTCHA: network failure → %s", exc)
        return {"ok": False, "error": "network_error", "errors": []}
    except json.JSONDecodeError:
        logger.error("reCAPTCHA: invalid JSON response")
        return {"ok": False, "error": "invalid_response", "errors": []}
    except Exception as exc:
        logger.exception("reCAPTCHA: unexpected exception → %s", exc)
        return {"ok": False, "error": "recaptcha_unreachable", "errors": []}

    # ----------------------------------------------------------
    # Step 7. Validate response integrity
    # ----------------------------------------------------------
    success: bool = bool(data.get("success", False))
    hostname: Optional[str] = data.get("hostname")
    error_codes: list[str] = list(data.get("error-codes", []) or [])

    expected_host: Optional[str] = getattr(
        django_settings, "RECAPTCHA_EXPECTED_HOSTNAME", None
    )
    if expected_host and hostname and hostname != expected_host:
        logger.warning(
            "reCAPTCHA: hostname mismatch (%s ≠ %s)", hostname, expected_host
        )
        success = False
        error_codes.append("hostname_mismatch")

    # ----------------------------------------------------------
    # Step 8. Mode-specific evaluation
    # ----------------------------------------------------------
    if recaptcha_mode == "v3":
        score = _safe_decimal(data.get("score", 0))
        threshold = _safe_decimal(
            getattr(settings_obj, "recaptcha_score_threshold", 0.5)
        )
        valid = success and score >= threshold

        result: Dict[str, Any] = {
            "ok": bool(valid),
            "score": float(score),
            "errors": error_codes,
            "error": None,
        }

        if not valid:
            logger.info(
                "reCAPTCHA v3 failed: score=%.2f threshold=%.2f host=%s",
                float(score),
                float(threshold),
                hostname,
            )
    else:  # v2
        result = {
            "ok": bool(success),
            "score": None,
            "errors": error_codes,
            "error": None,
        }

    # ----------------------------------------------------------
    # Step 9. Cache result briefly
    # ----------------------------------------------------------
    try:
        cache.set(cache_key, result, timeout=CACHE_TTL_SECONDS)
        logger.debug(
            "reCAPTCHA: cached result key=%s TTL=%ss", cache_key, CACHE_TTL_SECONDS
        )
    except Exception as exc:
        logger.debug("reCAPTCHA: cache.set failed for %s → %s", cache_key, exc)

    return result

--------------------------------------------
### FILE: apps\users\signals.py
### SIZE: 6777 bytes
### HASH: 73DE70D3F20FE7CB94A2B0299D0F46EAC1B1D55583530EEC1217A3BD28B90EEA

"""
apps.users.signals
==================
Centralized user-related signal handlers for GSMInfinity.
"""

from __future__ import annotations

import logging

from allauth.account.signals import email_confirmed, user_signed_up
from allauth.account.utils import perform_login
from apps.users.utils.device import enforce_device_limit, register_fingerprint
from django.contrib.auth.signals import user_logged_in
from django.dispatch import receiver
from django.utils import timezone

logger = logging.getLogger(__name__)


@receiver(user_logged_in)
def handle_user_logged_in(sender, request, user, **kwargs):
    if not user or not request:
        logger.debug("handle_user_logged_in: missing user or request context.")
        return

    try:
        fp_hash = (
            request.META.get("DEVICE_FP")
            or request.COOKIES.get("device_fp")
            or request.META.get("HTTP_USER_AGENT", "unknown")
        )[:255]

        fingerprint_data = {
            "fingerprint_hash": fp_hash,
            "os_info": (request.META.get("OS_INFO") or "").strip()[:100],
            "browser_info": (request.META.get("HTTP_USER_AGENT") or "").strip()[:255],
            "motherboard_id": (request.META.get("MOTHERBOARD_ID") or "").strip()[:100],
        }

        if not enforce_device_limit(user):
            logger.warning(
                "Device registration blocked - user %s exceeded device limit.",
                getattr(user, "email", user.pk),
            )
            return

        register_fingerprint(user=user, **fingerprint_data)
        logger.info(
            "Device fingerprint updated for user %s [%s]",
            getattr(user, "email", user.pk),
            fingerprint_data["fingerprint_hash"][:16],
        )

    except Exception as exc:
        logger.exception(
            "Error registering fingerprint for user %s: %s",
            getattr(user, "email", user.pk),
            exc,
        )


@receiver(user_signed_up)
def handle_user_signed_up(request, user, **kwargs):
    """
    Triggered immediately after a new user account is created
    (via email, social, or SSO signup).

    Responsibilities:
      • Set signup_method ("manual" | "social").
      • Ensure profile_completed=False so middleware can enforce onboarding.
      • Mark email_verified_at for social signups.
    """
    if not user:
        logger.debug("handle_user_signed_up: missing user instance.")
        return

    sociallogin = kwargs.get("sociallogin")
    is_social = bool(sociallogin)
    updated_fields: list[str] = []

    try:
        if hasattr(user, "signup_method"):
            desired_method = "social" if is_social else "manual"
            if getattr(user, "signup_method", None) != desired_method:
                user.signup_method = desired_method
                updated_fields.append("signup_method")

        if hasattr(user, "profile_completed"):
            if getattr(user, "profile_completed", True):
                user.profile_completed = False
                updated_fields.append("profile_completed")

        if is_social and hasattr(user, "email_verified_at"):
            if getattr(user, "email_verified_at", None) is None:
                user.email_verified_at = timezone.now()
                updated_fields.append("email_verified_at")

        if updated_fields:
            user.save(update_fields=updated_fields)
            logger.info(
                "User %s flagged for onboarding; updated fields=%s",
                getattr(user, "email", user.pk),
                updated_fields,
            )

        if sociallogin:
            try:
                perform_login(request, user, email_verification="optional")
            except Exception:
                pass

    except Exception as exc:
        logger.exception(
            "Error flagging signup completion for user %s: %s",
            getattr(user, "email", user.pk),
            exc,
        )

    # Register device fingerprint at signup if available
    try:
        fp_hash = (
            (request.POST.get("device_fp") if request else None)
            or (request.COOKIES.get("device_fp") if request else None)
            or (request.META.get("DEVICE_FP") if request else None)
            or (request.META.get("HTTP_USER_AGENT") if request else None)
            or "unknown"
        )[:255]

        fingerprint_data = {
            "fingerprint_hash": fp_hash,
            "os_info": (request.META.get("OS_INFO") if request else "" or "").strip()[:100],
            "browser_info": (request.META.get("HTTP_USER_AGENT") if request else "" or "").strip()[:255],
            "motherboard_id": (request.META.get("MOTHERBOARD_ID") if request else "" or "").strip()[:100],
        }

        if enforce_device_limit(user):
            register_fingerprint(user=user, **fingerprint_data)
    except Exception as exc:
        logger.debug("Signup fingerprint registration failed: %s", exc, exc_info=True)


@receiver(email_confirmed)
def handle_email_confirmed(request, email_address, **kwargs):
    """
    Sync allauth EmailAddress confirmations to CustomUser.email_verified_at.
    """
    try:
        user = getattr(email_address, "user", None)
        if not user:
            logger.debug("email_confirmed: missing user on email_address")
            return

        updated_fields = []
        if not getattr(user, "email_verified_at", None):
            user.email_verified_at = timezone.now()
            updated_fields.append("email_verified_at")

        if hasattr(user, "verification_code") and getattr(
            user, "verification_code", ""
        ):
            user.verification_code = ""
            updated_fields.append("verification_code")

        if updated_fields:
            user.save(update_fields=updated_fields)
            logger.info(
                "email_confirmed: marked verified for user=%s",
                getattr(user, "email", user.pk),
            )

        # Optional referral reward logic
        try:
            from django.conf import settings

            referrer_bonus = int(getattr(settings, "REFERRAL_REWARD_REFERRER", 0) or 0)
            new_user_bonus = int(getattr(settings, "REFERRAL_REWARD_NEW_USER", 0) or 0)

            if referrer_bonus > 0 and getattr(user, "referred_by", None):
                referrer = user.referred_by
                if hasattr(referrer, "add_credits"):
                    referrer.add_credits(referrer_bonus)
            if new_user_bonus > 0 and hasattr(user, "add_credits"):
                user.add_credits(new_user_bonus)
        except Exception as exc:
            logger.debug("Referral reward processing failed: %s", exc, exc_info=True)
    except Exception as exc:
        logger.exception("email_confirmed handler failed: %s", exc)


--------------------------------------------
### FILE: apps\users\tests.py
### SIZE: 61 bytes
### HASH: 16BD2BFAA5A5193DBE66207AF62D6B157D55F883C23F32F344103BCF9BB7C506

from django.test import TestCase

# Create your tests here.

--------------------------------------------
### FILE: apps\users\tokens.py
### SIZE: 2407 bytes
### HASH: C5370D9F26CBD189600465E1F1C717C7585ABCEBC3FDF69668A39AF93F3B57BE

"""
apps.users.tokens
=================
Enterprise-safe token utilities for GSMInfinity.

✅ Highlights
-------------
• Cryptographically secure random tokens
• URL-safe output (for email links or QR codes)
• Timezone-aware expiry calculation
• Configurable length & lifetime
• No deprecated or unsafe modules
"""

from __future__ import annotations

import secrets
from datetime import timedelta

from django.utils import timezone

# ============================================================
#  TOKEN GENERATION
# ============================================================


def generate_token(length: int = 32) -> str:
    """
    Generate a cryptographically secure, URL-safe token.

    Args:
        length (int): Desired token length (default 32).
                      Must be ≥ 8 and ≤ 128 for best entropy/performance.

    Returns:
        str: Secure random token trimmed to desired length.
    """
    if not isinstance(length, int) or length < 8 or length > 128:
        length = 32
    token = secrets.token_urlsafe(length * 2)  # overshoot for trimming
    return token[:length]


# ============================================================
#  TOKEN EXPIRY UTILITIES
# ============================================================


def token_expiry(hours: int = 24) -> timezone.datetime:
    """
    Compute an expiry datetime for a token using Django's timezone utilities.

    Args:
        hours (int): Lifetime in hours (default 24).

    Returns:
        datetime: Timezone-aware expiry timestamp.
    """
    safe_hours = hours if isinstance(hours, (int, float)) and hours > 0 else 24
    return timezone.now() + timedelta(hours=safe_hours)


# ============================================================
#  TOKEN VALIDATION (Optional Utility)
# ============================================================


def is_token_expired(created_at: timezone.datetime, hours: int = 24) -> bool:
    """
    Determine whether a token has expired.

    Args:
        created_at (datetime): Original token creation timestamp.
        hours (int): Valid lifetime in hours (default 24).

    Returns:
        bool: True if expired, False otherwise.
    """
    if not created_at:
        return True
    expiry_time = created_at + timedelta(hours=hours)
    return timezone.now() >= expiry_time

--------------------------------------------
### FILE: apps\users\urls.py
### SIZE: 1767 bytes
### HASH: AB529BCA13D50C12A14F0841D8D9C3A9F857F71445084C50B5DF49DEB7DBC47F

"""
apps.users.urls
================
Enterprise-grade URL configuration for GSMInfinity Users module.
"""

from allauth.account.views import LogoutView
from django.urls import path

from . import api, views_notifications
from .views import (
    EnterpriseLoginView,
    EnterpriseSignupView,
    auth_hub_view,
    change_username,
    dashboard_view,
    device_list_view,
    device_reset_view,
    profile_view,
    resend_verification,
    tell_us_about_you,
    verify_email_view,
)

app_name = "users"

urlpatterns = [
    path("auth/", auth_hub_view, name="auth_hub"),
    path("login/", EnterpriseLoginView.as_view(), name="account_login"),
    path("signup/", EnterpriseSignupView.as_view(), name="account_signup"),
    path("logout/", LogoutView.as_view(), name="account_logout"),
    path("dashboard/", dashboard_view, name="dashboard"),
    path("profile/", profile_view, name="profile"),
    path("devices/", device_list_view, name="devices"),
    path("devices/<int:pk>/reset/", device_reset_view, name="device_reset"),
    path("verify-email/", verify_email_view, name="verify_email"),
    path("tell-us-about-you/", tell_us_about_you, name="tell_us_about_you"),
    path("accounts/resend-verification/", resend_verification, name="resend_verification"),
    path("accounts/change-username/", change_username, name="change_username"),
    path("notifications/unread.json", api.notifications_unread_json, name="notifications_unread_json"),
    path("notifications/", views_notifications.notification_list, name="notifications"),
    path("notifications/<int:pk>/", views_notifications.notification_detail, name="notification_detail"),
    path("notifications/mark-all/", views_notifications.notification_mark_all_read, name="notification_mark_all"),
]


--------------------------------------------
### FILE: apps\users\utils\device.py
### SIZE: 12197 bytes
### HASH: 0ECC98759D8E0F7443E6CDA1D951653A959A6D6141DB52F58BBA3B4B293E5D24

"""
apps.users.utils.device
-----------------------

Enterprise-grade device fingerprint and limit enforcement utilities for GSMInfinity.

Features:
- Registers or updates DeviceFingerprint on each login.
- Enforces per-user device limits (strict / lenient) with ADMIN BYPASS.
- Thread-safe atomic updates, ORM-optimized (Django 5.x).
- Compatible with async-safe authentication and signals.
- Includes periodic admin cleanup utilities.
"""

from __future__ import annotations

import logging
from datetime import timedelta
from typing import Any, Dict, List, Optional

from apps.site_settings.models import SiteSettings
from apps.users.models import CustomUser, DeviceFingerprint
from django.core.exceptions import ValidationError
from django.db import transaction
from django.utils import timezone

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------
# Device registration / update (atomic, locked)
# ---------------------------------------------------------------------
def register_fingerprint(
    user: CustomUser,
    fingerprint_hash: str,
    os_info: str = "",
    motherboard_id: str = "",
    browser_info: str = "",
) -> Optional[DeviceFingerprint]:
    """
    Create or update a DeviceFingerprint record for the given user.

    Admin users: fingerprint registered but device limits are not enforced.

    Returns:
        DeviceFingerprint | None
    """
    if not user or not fingerprint_hash:
        logger.warning("register_fingerprint: missing user or fingerprint_hash")
        return None

    # Truncate inputs to sane lengths to avoid DB bloat
    os_info = (os_info or "")[:100]
    motherboard_id = (motherboard_id or "")[:100]
    browser_info = (browser_info or "")[:255]

    try:
        with transaction.atomic():
            # Try to lock an existing fingerprint row for update
            qs = DeviceFingerprint.objects.select_for_update().filter(
                user=user, fingerprint_hash=fingerprint_hash
            )
            device = qs.first()
            created = False

            now = timezone.now()

            if device is None:
                # Create new device row
                device = DeviceFingerprint.objects.create(
                    user=user,
                    fingerprint_hash=fingerprint_hash,
                    os_info=os_info,
                    motherboard_id=motherboard_id,
                    browser_info=browser_info,
                    registered_at=now,
                    last_used_at=now,
                    is_active=True,
                )
                created = True
                update_fields: List[str] = []  # nothing to update after create
            else:
                # Update last_used_at and any changed metadata
                update_fields = ["last_used_at"]
                device.last_used_at = now

                if os_info and device.os_info != os_info:
                    device.os_info = os_info
                    update_fields.append("os_info")
                if motherboard_id and device.motherboard_id != motherboard_id:
                    device.motherboard_id = motherboard_id
                    update_fields.append("motherboard_id")
                if browser_info and device.browser_info != browser_info:
                    device.browser_info = browser_info
                    update_fields.append("browser_info")
                if not device.is_active:
                    device.is_active = True
                    update_fields.append("is_active")

                if update_fields:
                    device.save(update_fields=update_fields)

        logger.debug(
            "DeviceFingerprint[%s] %s for %s (admin=%s) — fields: %s",
            device.pk,
            "created" if created else "updated",
            getattr(user, "email", user.pk),
            getattr(user, "is_staff", False),
            ",".join(update_fields) if update_fields else "(none)",
        )
        return device

    except Exception as exc:
        logger.exception(
            "register_fingerprint failed for user=%s -> %s",
            getattr(user, "pk", None),
            exc,
        )
        return None


# ---------------------------------------------------------------------
# Device limit enforcement (atomic, admin bypass)
# ---------------------------------------------------------------------
def enforce_device_limit(user: CustomUser) -> bool:
    """
    Enforce per-user device limits from SiteSettings.

    ADMIN BYPASS: Staff/superusers have unlimited devices.
    REGULAR USERS: Subject to device limit and eviction mode.

    Modes:
        - strict  -> block new device registration if limit reached.
        - lenient -> deactivate oldest fingerprints to make room.

    Returns:
        True if registration/usage allowed, False if blocked.
    """
    if not user:
        return True

    # Admin bypass
    if getattr(user, "is_staff", False) or getattr(user, "is_superuser", False):
        logger.debug(
            "Device limit bypassed for admin user: %s", getattr(user, "email", user.pk)
        )
        return True

    try:
        settings_obj = SiteSettings.get_solo()
        limit = int(getattr(settings_obj, "max_devices_per_user", 3))
        mode = str(getattr(settings_obj, "fingerprint_mode", "strict")).lower()
    except Exception as exc:
        logger.warning(
            "SiteSettings unavailable; using defaults for device limits: %s", exc
        )
        limit, mode = 3, "strict"

    # Lock the active device rows for this user to avoid races
    with transaction.atomic():
        active_qs = (
            DeviceFingerprint.objects.select_for_update()
            .filter(user=user, is_active=True)
            .only("id", "last_used_at")
            .order_by("last_used_at")
        )
        count = active_qs.count()

        if count < limit:
            logger.debug(
                "User %s within device limit (%d/%d)",
                getattr(user, "email", user.pk),
                count,
                limit,
            )
            return True

        if mode == "lenient":
            # Evict the oldest devices (bulk update)
            to_remove = count - limit + 1
            oldest_devices = list(active_qs[:to_remove])  # evaluated within transaction
            if not oldest_devices:
                # Unexpected, but fail-safe allow
                logger.warning(
                    "No devices found to evict for user %s despite count exceeded",
                    getattr(user, "email", user.pk),
                )
                return False
            try:
                for d in oldest_devices:
                    d.is_active = False
                DeviceFingerprint.objects.bulk_update(oldest_devices, ["is_active"])
                logger.info(
                    "Evicted %d oldest device(s) for user %s (lenient mode)",
                    len(oldest_devices),
                    getattr(user, "email", user.pk),
                )
                return True
            except Exception as exc:
                logger.exception(
                    "Device eviction failed for %s: %s",
                    getattr(user, "email", user.pk),
                    exc,
                )
                return False

        # Strict mode: block
        logger.warning(
            "Device registration BLOCKED for %s — device limit reached (%d/%d, strict mode)",
            getattr(user, "email", user.pk),
            count,
            limit,
        )
        return False


# ---------------------------------------------------------------------
# Combined safe helper (record + enforce)
# ---------------------------------------------------------------------
def record_device_fingerprint(
    request,
    user: CustomUser,
    fingerprint_data: Optional[Dict[str, Any]] = None,
) -> Optional[DeviceFingerprint]:
    """
    Unified helper for recording device fingerprints during login.

    Raises:
        ValidationError -> missing fingerprint hash
        PermissionError -> strict mode violation for regular users
    """
    fingerprint_data = fingerprint_data or {}

    fingerprint_hash = (
        fingerprint_data.get("fingerprint_hash")
        or (
            getattr(request, "POST", {}).get("device_fp")
            if hasattr(request, "POST")
            else None
        )
        or (
            getattr(request, "COOKIES", {}).get("device_fp")
            if hasattr(request, "COOKIES")
            else None
        )
        or (
            getattr(request, "META", {}).get("HTTP_USER_AGENT")
            if getattr(request, "META", None)
            else None
        )
    )

    if not fingerprint_hash:
        raise ValidationError("record_device_fingerprint: missing fingerprint_hash")

    os_info = fingerprint_data.get("os_info") or (
        getattr(request, "META", {}).get("HTTP_USER_AGENT", "")[:100]
        if getattr(request, "META", None)
        else ""
    )
    motherboard_id = fingerprint_data.get("motherboard_id") or ""
    browser_info = fingerprint_data.get("browser_info") or (
        getattr(request, "META", {}).get("HTTP_USER_AGENT", "")[:255]
        if getattr(request, "META", None)
        else ""
    )

    # Enforce device limit (admin bypass included)
    allowed = enforce_device_limit(user)
    if not allowed:
        raise PermissionError("Device registration blocked (strict mode limit reached)")

    device = register_fingerprint(
        user=user,
        fingerprint_hash=fingerprint_hash,
        os_info=os_info,
        motherboard_id=motherboard_id,
        browser_info=browser_info,
    )

    user_type = (
        "admin"
        if (getattr(user, "is_staff", False) or getattr(user, "is_superuser", False))
        else "user"
    )
    logger.debug(
        "record_device_fingerprint: device recorded for %s (%s)",
        getattr(user, "email", user.pk),
        user_type,
    )
    return device


# ---------------------------------------------------------------------
# Admin-specific utilities
# ---------------------------------------------------------------------
def get_admin_device_stats() -> Dict[str, Dict[str, Any]]:
    """
    Returns device statistics for admin users.
    Useful for dashboards or audits.
    """
    stats: Dict[str, Dict[str, Any]] = {}
    admins = CustomUser.objects.filter(is_staff=True).only("id", "email")
    for user in admins:
        devices_qs = DeviceFingerprint.objects.filter(user=user, is_active=True).only(
            "fingerprint_hash", "last_used_at", "os_info", "browser_info"
        )
        stats_key = user.email or f"User#{user.pk}"
        stats[stats_key] = {
            "total_devices": devices_qs.count(),
            "devices": list(
                devices_qs.values(
                    "fingerprint_hash", "last_used_at", "os_info", "browser_info"
                )
            ),
        }
    return stats


def cleanup_old_admin_devices(days_old: int = 30) -> int:
    """
    Clean up old admin device fingerprints older than `days_old`.
    Returns total number of deleted objects.
    """
    cutoff_date = timezone.now() - timedelta(days=days_old)
    deleted_total = 0

    admins = CustomUser.objects.filter(is_staff=True).only("id", "email")
    for user in admins:
        old_devices_qs = DeviceFingerprint.objects.filter(
            user=user, last_used_at__lt=cutoff_date
        )
        count = old_devices_qs.count()
        if count:
            old_devices_qs.delete()
            deleted_total += count
            logger.info(
                "Cleaned %d old devices for admin %s",
                count,
                user.email or f"User#{user.pk}",
            )

    logger.info("Total admin devices cleaned: %d", deleted_total)
    return deleted_total

--------------------------------------------
### FILE: apps\users\utils\utils.py
### SIZE: 1822 bytes
### HASH: 9B51BC5A3097E4D3E6C26EC288ED7A132A8F894FEBCF6CD17D4F73B2B95ADEAA

import hashlib
from django.http import HttpRequest


def _get_client_ip(request: HttpRequest) -> str:
    """
    Normalized client IP resolution (aligns with RequestMetaMiddleware).
    Prefer the first X-Forwarded-For value when present.
    """
    xff = request.META.get("HTTP_X_FORWARDED_FOR", "") or ""
    if xff:
        parts = [p.strip() for p in xff.split(",") if p.strip()]
        if parts:
            return parts[0]
    return request.META.get("REMOTE_ADDR", "") or ""


def get_device_fingerprint(request: HttpRequest) -> str:
    """
    Stable device fingerprint based on user agent, client IP and session key.

    Prefers client-provided fingerprint (from JS cookie/localStorage) so it
    remains stable across HTTP/HTTPS and pre-auth flows. Falls back to a
    server-derived hash when none is provided.
    """
    # Prefer explicit client fingerprint (from hidden form field or cookie)
    client_fp = ""
    try:
        client_fp = (
            request.POST.get("device_fp")
            or request.COOKIES.get("device_fp")
            or request.GET.get("device_fp", "")
        )
    except Exception:
        client_fp = ""

    if client_fp:
        return str(client_fp)

    # Server-side fallback (ensures a session key exists)
    ua = request.META.get("HTTP_USER_AGENT", "") or ""
    ip = _get_client_ip(request)
    session = getattr(request, "session", None)
    session_key = ""
    try:
        if session is not None:
            # Create a session key if it doesn't exist yet (pre-auth)
            if not session.session_key:
                session.save()
            session_key = session.session_key or ""
    except Exception:
        session_key = ""

    payload = f"{ua}|{ip}|{session_key}"
    return hashlib.sha256(payload.encode("utf-8", errors="ignore")).hexdigest()


--------------------------------------------
### FILE: apps\users\views.py
### SIZE: 23959 bytes
### HASH: F2BF7B85EFB5DC82B877DEF0027418BC3842F6120E5BB4CA64EC1D02956D0802

"""
apps.users.views
================
Enterprise-grade user management and authentication views for GSMInfinity.

✅ Highlights
-------------
• Tenant-aware SiteSettings resolver (uses site_settings.views._get_settings when available)
• Integrated rate limiting + reCAPTCHA verification
• Device fingerprint capture and per-user limit enforcement
• MFA / Email verification enforcement
• Optimized dashboard queries (deferred, select_related)
• Atomic safety and hardened UX
• Fully compatible with Django 5.x and allauth ≥ 0.65
"""

from __future__ import annotations

import logging
import re
from typing import Any, Dict, Optional

from allauth.account.forms import LoginForm, SignupForm
from allauth.account.views import LoginView, SignupView
from apps.users.forms import TellUsAboutYouForm
from apps.users.models import Announcement, DeviceFingerprint, Notification
from apps.users.services.rate_limit import allow_action
from apps.users.services.recaptcha import verify_recaptcha
from apps.users.utils.device import enforce_device_limit, record_device_fingerprint
from apps.users.utils.utils import get_device_fingerprint
from django.conf import settings
from django.contrib import messages
from django.contrib.auth import get_user_model, update_session_auth_hash
from django.contrib.auth.decorators import login_required
from django.contrib.sites.shortcuts import get_current_site
from django.db.models import Q
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.shortcuts import redirect, render
from django.urls import reverse
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.views.decorators.http import require_POST, require_http_methods

logger = logging.getLogger(__name__)


@login_required
def profile(request: HttpRequest) -> HttpResponse:
    """
    Display the authenticated user's profile.
    """
    context: dict[str, Any] = {
        "user": request.user,
        "notifications": Notification.objects.filter(user=request.user).order_by(
            "-created_at"
        )[:10],
        "announcements": Announcement.objects.filter(is_active=True).order_by(
            "-created_at"
        )[:5],
        "referral_link": "",
    }
    try:
        if getattr(request.user, "referral_code", None):
            base_signup = request.build_absolute_uri(reverse("account_signup"))
            context["referral_link"] = f"{base_signup}?ref={request.user.referral_code}"
    except Exception:
        context["referral_link"] = ""
    return render(request, "users/profile.html", context)


def login_view(request: HttpRequest) -> HttpResponse:
    """
    Render the login page. Delegates authentication to django-allauth.
    """
    if request.user.is_authenticated:
        return redirect("core:home")

    context: dict[str, Any] = {
        "form": LoginForm(),
        "site": get_current_site(request),
    }
    return render(request, "login.html", context)


# ============================================================
# Settings resolver (lazy import to avoid circular deps)
# ============================================================
def _get_settings(request=None) -> Dict[str, object]:
    """
    Return primitive settings snapshot (dict). Try to use the canonical resolver
    from apps.site_settings.views (which already returns dict snapshots). If
    unavailable, fall back to safe defaults.
    """
    try:
        # Lazy import to avoid circular imports
        from apps.site_settings.views import (
            _get_settings as _ss_get_settings,
        )  # type: ignore

        result = _ss_get_settings(request)
        # Ensure it's a dict (backwards tolerant)
        if isinstance(result, dict):
            return result
        # If old-style model instance returned, convert to dict
        return {
            "site_name": getattr(result, "site_name", "GSMInfinity"),
            "enable_signup": getattr(result, "enable_signup", True),
            "max_login_attempts": int(getattr(result, "max_login_attempts", 5) or 5),
            "rate_limit_window_seconds": int(
                getattr(result, "rate_limit_window_seconds", 300) or 300
            ),
            "recaptcha_enabled": bool(getattr(result, "recaptcha_enabled", False)),
            "enforce_unique_device": bool(
                getattr(result, "enforce_unique_device", False)
            ),
            "max_devices_per_user": int(
                getattr(result, "max_devices_per_user", 3) or 3
            ),
            "require_mfa": bool(getattr(result, "require_mfa", False)),
            "enable_payments": bool(getattr(result, "enable_payments", True)),
        }
    except Exception:
        # Fallback defaults (primitive types only)
        logger.debug(
            "site settings resolver lazy import failed; using fallback defaults",
            exc_info=True,
        )
        return {
            "site_name": "GSMInfinity",
            "enable_signup": True,
            "max_login_attempts": 5,
            "rate_limit_window_seconds": 300,
            "recaptcha_enabled": False,
            "enforce_unique_device": False,
            "max_devices_per_user": 3,
            "require_mfa": False,
            "enable_payments": True,
            "site_header": "GSM Admin",
            "site_description": "Default configuration",
            "meta_tags": [],
            "verification_files": [],
            # Branding fallbacks used by base.html
            "primary_color": "#0d6efd",
            "secondary_color": "#6c757d",
            "logo": None,
            "dark_logo": None,
            "favicon": None,
        }


# ============================================================
# Enterprise Login View
# ============================================================
class EnterpriseLoginView(LoginView):
    """
    Enterprise login with:
    - IP-based rate limiting
    - reCAPTCHA verification
    - Device fingerprint & limit enforcement
    - Optional MFA redirect
    """

    form_class = LoginForm
    template_name = "account/login.html"

    def form_valid(self, form):
        settings_obj = _get_settings(self.request)
        ip = (
            (
                self.request.META.get("HTTP_X_FORWARDED_FOR")
                or self.request.META.get("REMOTE_ADDR")
                or "unknown"
            )
            .split(",")[0]
            .strip()
        )

        # --- Rate Limiting ---
        try:
            if not allow_action(
                f"login:{ip}",
                int(settings_obj.get("max_login_attempts", 5)),
                int(settings_obj.get("rate_limit_window_seconds", 300)),
            ):
                form.add_error(None, "Too many login attempts. Please try again later.")
                logger.warning("Rate limit exceeded for IP=%s", ip)
                return self.form_invalid(form)
        except Exception:
            # Fail-open: allow login if rate limiter has issues, but log
            logger.exception("Rate limiter failure (fail-open)")

        # --- reCAPTCHA ---
        token = self.request.POST.get("g-recaptcha-response") or self.request.POST.get(
            "recaptcha_token"
        )
        if settings_obj.get("recaptcha_enabled", False) and token:
            try:
                rc_result = verify_recaptcha(token, ip, action="login")
                if not rc_result.get("ok"):
                    form.add_error(
                        None, "reCAPTCHA verification failed. Please try again."
                    )
                    logger.info("reCAPTCHA failed for %s → %s", ip, rc_result)
                    return self.form_invalid(form)
            except Exception:
                logger.exception("reCAPTCHA error (fail-open): %s", exc_info=True)
                form.add_error(None, "reCAPTCHA service error. Try again later.")
                return self.form_invalid(form)

        # Authenticate & create session
        response = super().form_valid(form)

        # --- Session fixation protection ---
        try:
            if hasattr(self.request, "session"):
                # Rotate session key on login
                self.request.session.cycle_key()
                # Set a sane default expiry (2 weeks). Rely on remember-me elsewhere if present.
                self.request.session.set_expiry(1209600)
        except Exception:
            logger.exception("Failed to rotate session after login")

        user = self.request.user

        # --- Device limit enforcement (admin bypass inside helper) ---
        try:
            if settings_obj.get("enforce_unique_device", False):
                allowed = enforce_device_limit(user)
                if not allowed:
                    form.add_error(None, "Device limit exceeded. Contact support.")
                    logger.warning(
                        "Device limit exceeded for user=%s",
                        getattr(user, "email", user.pk),
                    )
                    return self.form_invalid(form)
        except Exception:
            logger.exception("Device enforcement error (fail-open)")

        # --- Fingerprint Recording (best-effort) ---
        try:
            fp = get_device_fingerprint(self.request)
            if fp:
                try:
                    record_device_fingerprint(
                        self.request, user, {"fingerprint_hash": fp}
                    )
                except PermissionError:
                    # Device rejected under strict mode
                    form.add_error(
                        None, "This device cannot be registered. Contact support."
                    )
                    logger.warning(
                        "Device blocked for user=%s", getattr(user, "email", user.pk)
                    )
                    return self.form_invalid(form)
                except Exception:
                    logger.exception("Failed to record device fingerprint")
        except Exception:
            logger.debug("Fingerprint capture failed (non-fatal)")

        # --- MFA / Email verification enforcement (config-aware) ---
        try:
            require_mfa = settings_obj.get("require_mfa", False)
            email_verification_mode = getattr(
                settings, "ACCOUNT_EMAIL_VERIFICATION", "optional"
            )
            if (
                require_mfa
                and email_verification_mode == "mandatory"
                and not getattr(user, "email_verified_at", None)
            ):
                logger.info(
                    "Redirecting %s to email verification (MFA required)",
                    getattr(user, "email", user.pk),
                )
                return redirect("users:verify_email")
        except Exception:
            logger.exception("MFA check failed (non-fatal)")

        return response


# ============================================================
# Enterprise Signup View
# ============================================================
class EnterpriseSignupView(SignupView):
    """Tenant-aware signup with optional reCAPTCHA verification."""

    form_class = SignupForm
    template_name = "account/signup.html"

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        # Pass request to form so it can prefill referral from ?ref=
        kwargs["request"] = self.request
        return kwargs

    def form_valid(self, form):
        s = _get_settings(self.request)

        if not s.get("enable_signup", True):
            form.add_error(None, "Signup is currently disabled.")
            logger.info("Signup attempt blocked by settings.")
            return self.form_invalid(form)

        token = self.request.POST.get("g-recaptcha-response") or self.request.POST.get(
            "recaptcha_token"
        )
        if s.get("recaptcha_enabled", False) and token:
            try:
                client_ip = (
                    (
                        self.request.META.get("HTTP_X_FORWARDED_FOR")
                        or self.request.META.get("REMOTE_ADDR")
                        or "unknown"
                    )
                    .split(",")[0]
                    .strip()
                )
                rc = verify_recaptcha(token, client_ip, action="signup")
                if not rc.get("ok"):
                    form.add_error(None, "reCAPTCHA failed. Please retry.")
                    logger.info("reCAPTCHA failed during signup → %s", rc)
                    return self.form_invalid(form)
            except Exception:
                logger.exception("reCAPTCHA error during signup")
                form.add_error(None, "reCAPTCHA error. Please try again.")
                return self.form_invalid(form)

        return super().form_valid(form)


# ============================================================
# Manual email verification (MFA / email)
# ============================================================
@login_required
def verify_email_view(request):
    """Manual verification for MFA / email confirmation."""
    user = request.user
    if request.method == "POST":
        code = request.POST.get("code", "").strip()
        if not code:
            messages.error(request, "Verification code required.")
            return render(request, "users/verify_email.html")

        if code == getattr(user, "verification_code", ""):
            user.email_verified_at = timezone.now()
            user.verification_code = ""
            user.save(update_fields=["email_verified_at", "verification_code"])
            messages.success(request, "Email verified successfully.")
            return redirect("users:dashboard")

        messages.error(request, "Invalid verification code.")
        logger.warning("Invalid verification attempt for user=%s", user.pk)

    return render(request, "users/verify_email.html")


# ============================================================
# Dashboard view
# ============================================================
@login_required
def dashboard_view(request):
    """Render user dashboard with recent announcements and notifications."""
    s = _get_settings(request)
    # Gate unverified manual users if required
    try:
        if getattr(request.user, "manual_signup", False) and not getattr(
            request.user, "email_verified_at", None
        ):
            return redirect("users:verify_email")
    except Exception:
        pass
    now = timezone.now()

    # Announcements: use 'message' (model uses message field)
    announcements = (
        Announcement.objects.filter(start_at__lte=now)
        .filter(Q(expires_at__isnull=True) | Q(expires_at__gt=now))
        .only("title", "message", "start_at", "expires_at")
        .order_by("-start_at")
    )

    notifications = (
        Notification.objects.filter(recipient=request.user)
        .select_related("recipient")
        # Include recipient to avoid deferred+select_related conflict with .only()
        .only("title", "message", "created_at", "recipient")
        .order_by("-created_at")[:5]
    )

    # Device usage snapshot (defensive)
    device_limit = int(s.get("max_devices_per_user", 3) or 3)
    try:
        device_used = (
            DeviceFingerprint.objects.filter(user=request.user, is_active=True).count()
        )
    except Exception:
        logger.debug("device count failed", exc_info=True)
        device_used = 0
    device_remaining = max(device_limit - device_used, 0)

    context = {
        "site_settings": s,
        "announcements": announcements,
        "notifications": notifications,
        "credits": getattr(request.user, "credits", 0),
        "can_watch_ad": bool(s.get("recaptcha_enabled", False)),
        "can_pay": bool(s.get("enable_payments", True)),
        "device_limit": device_limit,
        "device_used": device_used,
        "device_remaining": device_remaining,
    }
    return render(request, "users/dashboard.html", context)


# ============================================================
# Profile view
# ============================================================
@login_required
def profile_view(request):
    """Render the user profile overview page."""
    s = _get_settings(request)
    return render(
        request,
        "users/profile.html",
        {
            "user": request.user,
            "credits": getattr(request.user, "credits", 0),
            "site_settings": s,
        },
    )


# ============================================================
# Devices view / reset
# ============================================================
@login_required
def device_list_view(request):
    """List active devices for the current user."""
    devices = (
        DeviceFingerprint.objects.filter(user=request.user)
        .order_by("-last_used_at")
        .only("id", "fingerprint_hash", "os_info", "browser_info", "last_used_at")
    )
    return render(
        request,
        "users/devices.html",
        {"devices": devices, "site_settings": _get_settings(request)},
    )


@login_required
def device_reset_view(request, pk: int):
    """
    Deactivate a device fingerprint.
    Only staff/superusers may reset devices directly.
    """
    if not (request.user.is_staff or request.user.is_superuser):
        messages.error(
            request,
            "Self-service resets are not available. Please use paid or ad-based reset options.",
        )
        return redirect("users:devices")

    try:
        device = DeviceFingerprint.objects.get(pk=pk, user=request.user)
        device.is_active = False
        device.save(update_fields=["is_active", "last_used_at"])
        messages.success(request, "Device has been reset/deactivated.")
    except DeviceFingerprint.DoesNotExist:
        messages.error(request, "Device not found.")
    except Exception as exc:
        logger.exception("device_reset_view failed: %s", exc)
        messages.error(request, "Unable to reset device right now.")
    return redirect("users:devices")


# ============================================================
# Auth hub
# ============================================================
def auth_hub_view(request):
    """Landing page for login/signup/social auth selection."""
    return render(request, "account/hub.html")


# ============================================================
# Tell Us About You – OAuth / profile onboarding
# ============================================================
@login_required
@require_http_methods(["GET", "POST"])
def tell_us_about_you(request: HttpRequest):
    """
    Onboarding view that runs after social signup (and optionally manual signup)
    to ensure the user has:
      • a unique username
      • a full name
      • a usable password (required for social accounts)
    """
    user = request.user

    if getattr(user, "profile_completed", False):
        return redirect("users:dashboard")

    if request.method == "POST":
        form = TellUsAboutYouForm(request.POST, user=user, request=request)
        if form.is_valid():
            cleaned = form.cleaned_data
            update_fields: list[str] = []

            if user.username != cleaned["username"]:
                user.username = cleaned["username"]
                update_fields.append("username")

            full_name = cleaned.get("full_name") or ""
            if getattr(user, "full_name", "") != full_name:
                user.full_name = full_name
                update_fields.append("full_name")

            password = cleaned.get("password1") or ""
            if password:
                user.set_password(password)
                update_fields.append("password")

            if hasattr(user, "signup_method") and not user.signup_method:
                user.signup_method = "social"
                update_fields.append("signup_method")

            if hasattr(user, "profile_completed") and not user.profile_completed:
                user.profile_completed = True
                update_fields.append("profile_completed")

            # Optional referral capture if not already set
            if hasattr(user, "referred_by") and not user.referred_by:
                ref_code = (cleaned.get("referral_code") or "").strip().upper()
                if ref_code:
                    try:
                        from apps.users.models import CustomUser  # local import

                        referrer = CustomUser.objects.filter(
                            referral_code__iexact=ref_code
                        ).first()
                        if referrer and referrer != user:
                            user.referred_by = referrer
                            update_fields.append("referred_by")
                    except Exception:
                        logger.debug("Failed to attach referral during onboarding", exc_info=True)

            if update_fields:
                user.save(update_fields=update_fields)

            if password:
                try:
                    update_session_auth_hash(request, user)
                except Exception:
                    pass

            try:
                messages.success(request, _("Your profile has been completed."))
            except Exception:
                pass

            return redirect("users:dashboard")
    else:
        initial: Dict[str, Any] = {
            "username": user.username or "",
            "full_name": getattr(user, "full_name", "") or "",
            "referral_code": (request.GET.get("ref") or "").strip().upper(),
        }
        form = TellUsAboutYouForm(user=user, request=request, initial=initial)

    return render(request, "users/tell_us_about_you.html", {"form": form})


# ============================================================
# Resend email verification
# ============================================================
@login_required
@require_POST
def resend_verification(request: HttpRequest) -> JsonResponse:
    from allauth.account.models import EmailAddress
    from allauth.account.utils import send_email_confirmation

    email = request.user.email
    try:
        email_obj = EmailAddress.objects.get(user=request.user, email=email)
        if email_obj.verified:
            return JsonResponse({"ok": False, "error": "already_verified"})
        send_email_confirmation(request, request.user, email=email)
        return JsonResponse({"ok": True})
    except EmailAddress.DoesNotExist:
        return JsonResponse({"ok": False, "error": "email_not_found"})
    except Exception as exc:
        logger.exception("resend_verification failed: %s", exc)
        return JsonResponse({"ok": False, "error": "server_error"}, status=500)


# ============================================================
# Change username
# ============================================================
USERNAME_RE = re.compile(r"^[a-zA-Z0-9._-]{3,32}$")


@login_required
@require_POST
def change_username(request: HttpRequest) -> JsonResponse:
    new_username = (request.POST.get("username") or "").strip()
    if not USERNAME_RE.match(new_username):
        return JsonResponse({"ok": False, "error": "invalid_username"}, status=400)

    User = get_user_model()
    if User.objects.filter(username__iexact=new_username).exists():
        return JsonResponse({"ok": False, "error": "taken"}, status=409)

    try:
        request.user.username = new_username
        request.user.save(update_fields=["username"])
        return JsonResponse({"ok": True})
    except Exception as exc:
        logger.exception("change_username failed: %s", exc)
        return JsonResponse({"ok": False, "error": "server_error"}, status=500)


--------------------------------------------
### FILE: apps\users\views_notifications.py
### SIZE: 3632 bytes
### HASH: E471928FC5DB0841497B37BF0C2AFCEE8C5FC05A35AA5210CCDAD4260EE7CC60

from __future__ import annotations

import logging
from typing import Any, Dict

from django.contrib.auth.decorators import login_required
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.shortcuts import get_object_or_404, render
from django.utils import timezone
from django.views.decorators.http import require_GET, require_POST

from .models import Announcement, Notification

logger = logging.getLogger(__name__)


# ============================================================================
# Serializers (JSON Safe)
# ============================================================================
def _serialize_notification(n: Notification) -> Dict[str, Any]:
    return {
        "id": n.id,
        "title": getattr(n, "title", ""),
        "message": getattr(n, "message", ""),
        "priority": getattr(n, "priority", None),
        "channel": getattr(n, "channel", None),
        "is_read": bool(n.is_read),
        "created_at": n.created_at.isoformat() if n.created_at else None,
        "read_at": n.read_at.isoformat() if n.read_at else None,
    }


# ============================================================================
# HTML Detail Page
# ============================================================================
@login_required
@require_GET
def notification_detail(request: HttpRequest, pk: int) -> HttpResponse:
    """
    HTML detail page for a single notification.
    Name fixed to match notifications_urls.py import.
    """
    notif = get_object_or_404(Notification, pk=pk, recipient=request.user)

    # Auto-mark as read
    if not notif.is_read:
        notif.is_read = True
        notif.read_at = timezone.now()
        notif.save(update_fields=["is_read", "read_at"])

    return render(
        request,
        "users/notifications/detail.html",
        {"notification": notif},
    )


# ============================================================================
# HTML List Page
# ============================================================================
@login_required
@require_GET
def notification_list(request: HttpRequest) -> HttpResponse:
    scope = (request.GET.get("scope") or "all").lower()
    qs = Notification.objects.filter(recipient=request.user).order_by("-created_at")
    if scope == "unread":
        qs = qs.filter(is_read=False)
    return render(
        request,
        "users/notifications/list.html",
        {"notifications": qs, "scope": scope},
    )


# ============================================================================
# JSON Endpoints
# ============================================================================
@login_required
@require_GET
def notification_unread_count(request: HttpRequest) -> JsonResponse:
    count = Notification.objects.filter(recipient=request.user, is_read=False).count()
    return JsonResponse({"ok": True, "unread_count": count})


@login_required
@require_POST
def notification_mark_read(request: HttpRequest, pk: int) -> JsonResponse:
    notif = get_object_or_404(Notification, pk=pk, recipient=request.user)

    if not notif.is_read:
        notif.is_read = True
        notif.read_at = timezone.now()
        notif.save(update_fields=["is_read", "read_at"])

    return JsonResponse({"ok": True})


@login_required
@require_POST
def notification_mark_all_read(request: HttpRequest) -> JsonResponse:
    Notification.objects.filter(recipient=request.user, is_read=False).update(
        is_read=True,
        read_at=timezone.now(),
    )
    return JsonResponse({"ok": True})


--------------------------------------------
### FILE: conftest.py
### SIZE: 277 bytes
### HASH: B9FDF0BC53312CE0867C9B10A1CEBB45ED5918AAAA466EB7589FB0C13A04E9CA

import os

import django
from django.conf import settings


def pytest_configure():
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "gsminfinity.settings")
    os.environ.setdefault("DJANGO_SECRET_KEY", "test-secret")
    if not settings.configured:
        django.setup()


--------------------------------------------
### FILE: gsminfinity\__init__.py
### SIZE: 1467 bytes
### HASH: 51F960650E5051A934BD17FAB50E3CAD908CE6A8CF06C4F9AE61A5F372FE80F2

"""
Generic Django Project Package
------------------------------

This file MUST remain minimal, deterministic, and completely side-effect free.

Purposes:
    • Marks this directory as a Python package.
    • Exposes stable, lightweight project metadata (__version__, __author__, __description__).
    • Guarantees import-safety for manage.py, ASGI, and WSGI boot processes.
    • Prevents ANY automatic code execution, framework initialization, or heavy imports.
    • Protects against accidental inclusion of non-Python content.

Rules:
    • DO NOT import Django or project modules here.
    • DO NOT perform I/O, logging, settings access, or dynamic logic.
    • DO NOT use try/except — this file must never hide initialization issues.
    • Content must always remain pure constants + metadata only.

This structure is hardened for enterprise deployments where stability,
repeatability, and deterministic imports are essential.
"""

__all__ = ["__version__", "__author__", "__description__"]

# ---------------------------------------------------------------------
# PROJECT METADATA (STATIC — SAFE — NO SIDE EFFECTS)
# ---------------------------------------------------------------------

# Semantic Version (bump per release/tag)
__version__ = "1.0.0"

# Generic, reusable project metadata
__author__ = "Application System"
__description__ = "Core initializer for the Django application package."

--------------------------------------------
### FILE: gsminfinity\development.py
### SIZE: 3100 bytes
### HASH: 2BFB78031DBBF763D0983FE2D314A038FA2B9BE3510EE3D63CAECED9AAA56989

"""
GSMInfinity Development Settings
--------------------------------
Overrides production settings for local development.

- Always HTTP - never enforces HTTPS
- DEBUG = True
- Console email backend
- Safe cache, session & CSRF defaults
- Supports local runserver (no SSL certs required)
"""

import os
from pathlib import Path

from .settings import *  # import all production defaults

# -------------------------
# Core environment
# -------------------------
DEBUG = True
ENV = "development"

# Disable any accidental HTTPS enforcement (middleware or admin toggle)
FORCE_HTTPS_DEV_OVERRIDE = 0

ALLOWED_HOSTS = ["127.0.0.1", "localhost", "0.0.0.0"]

# -------------------------
# Security overrides (safe HTTP)
# -------------------------
SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
SESSION_COOKIE_HTTPONLY = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_BROWSER_XSS_FILTER = False
SECURE_CONTENT_TYPE_NOSNIFF = False
SESSION_COOKIE_SAMESITE = "Lax"

CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:8000",
    "http://localhost:8000",
    "http://0.0.0.0:8000",
]

# -------------------------
# Local SSL certificate paths (optional, not used by default)
# -------------------------
CERT_DIR = Path(BASE_DIR) / "certs"
SSL_CERT_FILE = CERT_DIR / "localhost.pem"
SSL_KEY_FILE = CERT_DIR / "localhost-key.pem"

# Optional developer feedback — nothing enforces SSL
if SSL_CERT_FILE.exists():
    print(f"[DEV] Optional local certificate found: {SSL_CERT_FILE}")
else:
    print("[DEV] Development mode running strictly over HTTP (no HTTPS enforced).")

# -------------------------
# Logging (verbose for development)
# -------------------------
LOGGING["root"]["level"] = "DEBUG"
for logger_name in ("apps.users", "apps.core", "apps.consent", "apps.site_settings"):
    LOGGING.setdefault("loggers", {}).setdefault(
        logger_name,
        {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    )

# -------------------------
# Email (console backend)
# -------------------------
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"

# -------------------------
# Cache (local memory)
# -------------------------
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "TIMEOUT": 300,
    }
}

# -------------------------
# Faster password hashing for quick test logins
# -------------------------
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.MD5PasswordHasher",
]

# -------------------------
# Optional development-only toolbar or extensions (future toggle)
# -------------------------
if DEBUG and "django_extensions" not in INSTALLED_APPS:
    INSTALLED_APPS += ["django_extensions"]

# -------------------------
# Runtime banner
# -------------------------
print("[DEV] GSMInfinity Development Settings Loaded (HTTP only, DEBUG=True)")


--------------------------------------------
### FILE: gsminfinity\settings.py
### SIZE: 15815 bytes
### HASH: EAFB06D94890F2F5B4578920A20752A4728143E1351E611AC1536104B7907D88

# gsminfinity/settings.py
"""
Enterprise Django Settings
Django 5.2+ • Python 3.12+
Airtight • Modern • CSP-Safe • Zero Silent Failures • Hardened Imports
"""

from __future__ import annotations

import logging
import os
import sys
from pathlib import Path
from typing import Any

from django.core.exceptions import ImproperlyConfigured

# Optional .env loader (non-fatal)
try:
    from dotenv import load_dotenv  # type: ignore

    load_dotenv()
except Exception:
    pass

logger = logging.getLogger("gsminfinity")


# ---------------------------
# Helper utilities
# ---------------------------
def _configure_io_encoding() -> None:
    """Ensure stdout/stderr can emit UTF-8 (avoid Windows console encode errors)."""
    for stream_name in ("stdout", "stderr"):
        stream = getattr(sys, stream_name, None)
        if stream and hasattr(stream, "reconfigure"):
            try:
                stream.reconfigure(encoding="utf-8")
            except Exception:
                pass


_configure_io_encoding()


def env_str(value: Any, default: str = "") -> str:
    return str(value) if value is not None else default


def env_bool(value: Any, default: bool = False) -> bool:
    if value is None:
        return default
    try:
        return str(value).strip().lower() in ("1", "true", "yes", "on")
    except Exception:
        return default


def env_list(value: Any, default: list | None = None) -> list:
    if value is None:
        return default or []
    try:
        return [v.strip() for v in str(value).split(",") if v.strip()]
    except Exception:
        return default or []


# ---------------------------
# Paths & core
# ---------------------------
BASE_DIR = Path(__file__).resolve().parent.parent

_DEFAULT_DEV_SECRET = "django-insecure-development-secret"

SECRET_KEY = env_str(os.getenv("DJANGO_SECRET_KEY"), _DEFAULT_DEV_SECRET)

_settings_module = os.getenv("DJANGO_SETTINGS_MODULE", "")
_default_debug = _settings_module.endswith("settings_dev")
DEBUG = env_bool(os.getenv("DJANGO_DEBUG", None), _default_debug)
ENV = "development" if DEBUG else "production"
IS_PRODUCTION = not DEBUG

if IS_PRODUCTION and (not SECRET_KEY or SECRET_KEY == _DEFAULT_DEV_SECRET):
    raise ImproperlyConfigured(
        "DJANGO_SECRET_KEY must be set in the environment for production; refusing to start with the development secret."
    )


# ---------------------------
# Allowed hosts
# ---------------------------
ALLOWED_HOSTS = env_list(os.getenv("DJANGO_ALLOWED_HOSTS"), ["127.0.0.1", "localhost"])
ALLOWED_HOSTS = [h for h in ALLOWED_HOSTS if h and h.strip()]

if not DEBUG and not ALLOWED_HOSTS:
    raise ImproperlyConfigured("ALLOWED_HOSTS cannot be empty when DEBUG=False.")


# ---------------------------
# Sites framework
# ---------------------------
try:
    SITE_ID = int(env_str(os.getenv("SITE_ID"), "1"))
except Exception:
    SITE_ID = 1


# ---------------------------
# Installed apps
# ---------------------------
DJANGO_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
]

THIRD_PARTY_APPS = [
    "import_export",
    "solo",
    "django_countries",
    "crispy_forms",
    "crispy_bootstrap5",
    "allauth",
    "allauth.account",
    "allauth.socialaccount",
    "django_extensions",
]

SOCIAL_PROVIDERS = [
    "allauth.socialaccount.providers.google",
    "allauth.socialaccount.providers.facebook",
    "allauth.socialaccount.providers.microsoft",
    "allauth.socialaccount.providers.github",
]

LOCAL_APPS = [
    "apps.core",
    "apps.users",
    "apps.site_settings",
    "apps.consent",
    "apps.blog",
    "apps.tags",
    "apps.comments",
    "apps.seo",
    "apps.ads",
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + SOCIAL_PROVIDERS + LOCAL_APPS


# ---------------------------
# Middleware
# ---------------------------
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "apps.core.middleware.security_headers.SecurityHeadersMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "apps.core.middleware.ssl_toggle.SslToggleMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "apps.core.middleware.correlation.CorrelationIdMiddleware",
    "apps.core.middleware.request_meta.RequestMetaMiddleware",
    "django.middleware.locale.LocaleMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "allauth.account.middleware.AccountMiddleware",
    "apps.consent.middleware.ConsentMiddleware",
    "apps.users.middleware.mfa_enforce.EnforceMfaMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]


# ---------------------------
# Routing / ASGI / WSGI
# ---------------------------
ROOT_URLCONF = "gsminfinity.urls"
WSGI_APPLICATION = "gsminfinity.wsgi.application"
ASGI_APPLICATION = "gsminfinity.asgi.application"


# ---------------------------
# Database
# ---------------------------
_db_name = env_str(os.getenv("DB_NAME"))
if not _db_name:
    _db_name = str(BASE_DIR / "db.sqlite3")

DATABASES = {
    "default": {
        "ENGINE": env_str(os.getenv("DB_ENGINE"), "django.db.backends.sqlite3"),
        "NAME": _db_name,
        "USER": env_str(os.getenv("DB_USER")),
        "PASSWORD": env_str(os.getenv("DB_PASSWORD")),
        "HOST": env_str(os.getenv("DB_HOST")),
        "PORT": env_str(os.getenv("DB_PORT")),
        # IMPORTANT:
        # async views (lazy_loader) cannot run with ATOMIC_REQUESTS=True
        # this caused your RuntimeError
        "ATOMIC_REQUESTS": False,
        "CONN_MAX_AGE": 60 if not DEBUG else 0,
    }
}


# ---------------------------
# Authentication
# ---------------------------
AUTH_USER_MODEL = "users.CustomUser"

AUTHENTICATION_BACKENDS = [
    "apps.users.auth_backends.MultiFieldAuthBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
    "django.contrib.auth.backends.ModelBackend",
]

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {"min_length": 8},
    },
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]


# ---------------------------
# i18n / timezone
# ---------------------------
LANGUAGE_CODE = env_str(os.getenv("DJANGO_LANGUAGE"), "en-us")
TIME_ZONE = env_str(os.getenv("DJANGO_TIME_ZONE"), "Asia/Riyadh")

USE_I18N = True
USE_TZ = True


# ---------------------------
# Static / Media
# ---------------------------
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"

STATICFILES_STORAGE = (
    "django.contrib.staticfiles.storage.StaticFilesStorage"
    if DEBUG
    else "whitenoise.storage.CompressedManifestStaticFilesStorage"
)

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# ---------------------------
# Templates
# ---------------------------
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": DEBUG,
        "OPTIONS": {
            "debug": DEBUG,
            "string_if_invalid": "" if not DEBUG else "⚠ Missing: %s ⚠",
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "apps.site_settings.context_processors.site_settings",
                "apps.consent.context_processors.consent_context",
                "apps.core.context_processors.location_based_providers",
                "apps.users.context_processors.auth_status",
            ],
        },
    },
]

if not DEBUG:
    TEMPLATES[0]["APP_DIRS"] = False
    TEMPLATES[0]["OPTIONS"]["loaders"] = [
        (
            "django.template.loaders.cached.Loader",
            [
                "django.template.loaders.filesystem.Loader",
                "django.template.loaders.app_directories.Loader",
            ],
        )
    ]


# ---------------------------
# Login flows
# ---------------------------
LOGIN_URL = "account_login"
LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/"
ACCOUNT_LOGOUT_ON_GET = True


# ---------------------------
# Caching
# ---------------------------
USE_REDIS = env_bool(os.getenv("USE_REDIS_CACHE"), False)

if USE_REDIS:
    REDIS_URL = env_str(os.getenv("REDIS_URL"), "redis://127.0.0.1:6379/1")
    CACHES = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": REDIS_URL,
            "OPTIONS": {
                "CLIENT_CLASS": "django_redis.client.DefaultClient",
                "IGNORE_EXCEPTIONS": not DEBUG,
            },
        }
    }
else:
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
            "TIMEOUT": 300,
        }
    }


# ---------------------------
# Logging
# ---------------------------
LOG_LEVEL = env_str(os.getenv("LOG_LEVEL"), "INFO")

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {"format": "{levelname} {asctime} {module} {message}", "style": "{"},
        "simple": {"format": "{levelname} {message}", "style": "{"},
    },
    "handlers": {"console": {"class": "logging.StreamHandler", "formatter": "simple"}},
    "root": {"handlers": ["console"], "level": LOG_LEVEL},
    "loggers": {
        "django": {"handlers": ["console"], "level": LOG_LEVEL, "propagate": False},
        "apps": {"handlers": ["console"], "level": LOG_LEVEL, "propagate": False},
    },
}


# ---------------------------
# Allauth
# ---------------------------
ACCOUNT_ADAPTER = "apps.users.adapters.CustomAccountAdapter"
SOCIALACCOUNT_ADAPTER = "apps.users.adapters.CustomSocialAccountAdapter"

ACCOUNT_FORMS = {"signup": "apps.users.forms.CustomSignupForm"}

ACCOUNT_LOGIN_METHODS = {"username", "email"}
ACCOUNT_UNIQUE_EMAIL = True
ACCOUNT_SIGNUP_FIELDS = ["email*", "username*", "password1*", "password2*"]
ACCOUNT_EMAIL_VERIFICATION = env_str(
    os.getenv("ACCOUNT_EMAIL_VERIFICATION"), "optional"
)
ACCOUNT_EMAIL_CONFIRMATION_EXPIRE_DAYS = 3
ACCOUNT_PREVENT_ENUMERATION = True
ACCOUNT_SESSION_REMEMBER = True
ACCOUNT_LOGOUT_ON_PASSWORD_CHANGE = True
ACCOUNT_PASSWORD_MIN_LENGTH = 8
ACCOUNT_USERNAME_BLACKLIST = ["admin", "root", "administrator", "system"]
ACCOUNT_RATE_LIMITS = {"login_failed": "5/300s", "signup": "10/3600s"}
ACCOUNT_DEFAULT_HTTP_PROTOCOL = "https" if not DEBUG else "http"
ACCOUNT_EMAIL_SUBJECT_PREFIX = "[Notification] "
ACCOUNT_PRESERVE_USERNAME_CASING = False
ACCOUNT_AUTHENTICATED_LOGIN_REDIRECTS = False

# Referral rewards (credits) – both default to 0 (disabled) unless set via env
REFERRAL_REWARD_REFERRER = int(os.getenv("REFERRAL_REWARD_REFERRER", "0") or "0")
REFERRAL_REWARD_NEW_USER = int(os.getenv("REFERRAL_REWARD_NEW_USER", "0") or "0")


# ---------------------------
# Security
# ---------------------------
# We rely on SslToggleMiddleware + SiteSettings.force_https for dynamic control.
# Default secure in production, relaxed in dev unless overridden.
SECURE_SSL_REDIRECT = env_bool(os.getenv("SECURE_SSL_REDIRECT"), not DEBUG)

SESSION_COOKIE_SECURE = env_bool(os.getenv("SESSION_COOKIE_SECURE"), IS_PRODUCTION)
CSRF_COOKIE_SECURE = env_bool(os.getenv("CSRF_COOKIE_SECURE"), IS_PRODUCTION)

SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = env_str(os.getenv("SESSION_COOKIE_SAMESITE"), "Lax")
CSRF_COOKIE_SAMESITE = env_str(os.getenv("CSRF_COOKIE_SAMESITE"), "Lax")
SESSION_COOKIE_AGE = int(env_str(os.getenv("SESSION_COOKIE_AGE"), "1209600"))  # 14 days default
SESSION_SAVE_EVERY_REQUEST = env_bool(os.getenv("SESSION_SAVE_EVERY_REQUEST"), False)

# If behind a reverse proxy setting X-Forwarded-Proto, honor it for is_secure()
SECURE_PROXY_SSL_HEADER = (
    ("HTTP_X_FORWARDED_PROTO", "https") if env_bool(os.getenv("USE_XFORWARDED_PROTO"), False) else None
)

SECURE_HSTS_SECONDS = int(
    env_str(os.getenv("SECURE_HSTS_SECONDS"), "31536000" if IS_PRODUCTION else "0")
)
SECURE_HSTS_INCLUDE_SUBDOMAINS = env_bool(
    os.getenv("SECURE_HSTS_INCLUDE_SUBDOMAINS"), IS_PRODUCTION
)
SECURE_HSTS_PRELOAD = env_bool(os.getenv("SECURE_HSTS_PRELOAD"), IS_PRODUCTION)

SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True

X_FRAME_OPTIONS = env_str(os.getenv("X_FRAME_OPTIONS"), "DENY")
SECURE_REFERRER_POLICY = env_str(
    os.getenv("SECURE_REFERRER_POLICY"), "strict-origin-when-cross-origin"
)

SECURITY_HSTS_VALUE = env_str(
    os.getenv("SECURITY_HSTS_VALUE"),
    "max-age=63072000; includeSubDomains; preload",
)
SECURITY_COEP_VALUE = env_str(os.getenv("SECURITY_COEP_VALUE"), "require-corp")
SECURITY_CORP_VALUE = env_str(os.getenv("SECURITY_CORP_VALUE"), "same-origin")


# Trusted CSRF origins
_csrf_hosts = [h.strip() for h in ALLOWED_HOSTS if h and not h.startswith("*")]
ALLOW_INSECURE_CSRF_ORIGINS = env_bool(os.getenv("ALLOW_INSECURE_CSRF_ORIGINS"), False)

CSRF_TRUSTED_ORIGINS: list[str] = []
for host in _csrf_hosts:
    CSRF_TRUSTED_ORIGINS.append(f"https://{host}")
    if ALLOW_INSECURE_CSRF_ORIGINS and host in {"127.0.0.1", "localhost", "0.0.0.0"}:
        CSRF_TRUSTED_ORIGINS.append(f"http://{host}")


# ---------------------------
# Email
# ---------------------------
EMAIL_BACKEND = env_str(
    os.getenv("EMAIL_BACKEND"),
    (
        "django.core.mail.backends.console.EmailBackend"
        if DEBUG
        else "django.core.mail.backends.smtp.EmailBackend"
    ),
)
DEFAULT_FROM_EMAIL = env_str(os.getenv("DEFAULT_FROM_EMAIL"), "no-reply@local")
EMAIL_USE_TLS = env_bool(os.getenv("EMAIL_USE_TLS"), True)


# ---------------------------
# Celery / DRF
# ---------------------------
CELERY_BROKER_URL = env_str(os.getenv("CELERY_BROKER_URL"), "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = env_str(os.getenv("CELERY_RESULT_BACKEND"), CELERY_BROKER_URL)

CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": ["rest_framework.renderers.JSONRenderer"],
    "DEFAULT_PARSER_CLASSES": ["rest_framework.parsers.JSONParser"],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        # Enable these only if the app is installed/configured:
        # "rest_framework.authentication.TokenAuthentication",
        # "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
    "EXCEPTION_HANDLER": "apps.core.exceptions.EnterpriseExceptionHandler.handle_api_exception",
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
}


# ---------------------------
# Startup banner
# ---------------------------
logger.info("⚙️ Settings Loaded (DEBUG=%s)", DEBUG)


--------------------------------------------
### FILE: gsminfinity\settings_dev.py
### SIZE: 4329 bytes
### HASH: F19B6657DAC5088A877DCB9E92EE0E1ABB455F064CC64E9B7E837571AC372438

"""
GSMInfinity Development Settings
================================
Overrides production `settings.py` for safe local development.

- DEBUG mode enabled
- HTTPS redirection fully disabled
- No HSTS / CSRF secure cookie enforcement
- Console email backend
- Local-only allowed hosts
- Fast logging and hashing
"""

from __future__ import annotations

from pathlib import Path

from .settings import *  # import production defaults

# ============================================================
# Environment / Debug
# ============================================================
DEBUG = True
ENV = "development"

# Allow sync DB/session access in async dev server contexts (suppress SynchronousOnlyOperation)
os.environ.setdefault("DJANGO_ALLOW_ASYNC_UNSAFE", "true")

ACCOUNT_AUTHENTICATED_LOGIN_REDIRECTS = False

ALLOWED_HOSTS = ["127.0.0.1", "localhost", "0.0.0.0", "testserver"]
SITE_ID = 1


# ============================================================
# Security Overrides (force HTTP)
# ============================================================
# Completely disable all HTTPS-related enforcement for dev
SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_BROWSER_XSS_FILTER = False
SECURE_CONTENT_TYPE_NOSNIFF = False

SESSION_COOKIE_SECURE = False
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Lax"
SESSION_COOKIE_AGE = 1209600  # 14 days
SESSION_SAVE_EVERY_REQUEST = False

CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
CSRF_COOKIE_SAMESITE = "Lax"

# Dev: do not trust X-Forwarded-Proto by default
SECURE_PROXY_SSL_HEADER = None

# Ensure SslToggleMiddleware never forces HTTPS in dev
os.environ["FORCE_HTTPS_DEV_OVERRIDE"] = "0"
MIDDLEWARE = [
    mw for mw in MIDDLEWARE if mw != "apps.core.middleware.ssl_toggle.SslToggleMiddleware"
]


# ============================================================
# CSRF & Trusted Origins
# ============================================================
CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:8000",
    "http://localhost:8000",
]

# When already authenticated, redirect away from login/signup to the dashboard
ACCOUNT_AUTHENTICATED_LOGIN_REDIRECTS = True


# ============================================================
# Local SSL Certificate (optional)
# ============================================================
# Only used if you intentionally run dev server with TLS
CERT_DIR = Path("C:/certs")
SSL_CERT_FILE = CERT_DIR / "localhost.pem"
SSL_KEY_FILE = CERT_DIR / "localhost-key.pem"

if SSL_CERT_FILE.exists() and SSL_KEY_FILE.exists():
    print(f"[DEV] Local HTTPS certs available: {SSL_CERT_FILE.name}")
else:
    print("[DEV] No local certs found - running HTTP-only")


# ============================================================
# Logging Configuration
# ============================================================
LOGGING["root"]["level"] = "DEBUG"
LOGGING["loggers"]["django"]["level"] = "DEBUG"

for logger_name in ("apps.users", "apps.core", "apps.consent", "apps.site_settings"):
    LOGGING["loggers"].setdefault(
        logger_name,
        {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    )


# ============================================================
# Email Backend (safe console)
# ============================================================
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
DEFAULT_FROM_EMAIL = "dev@gsm-infinity.local"


# ============================================================
# Caching (local memory)
# ============================================================
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "TIMEOUT": 300,
    }
}


# ============================================================
# Password Hashers (fast)
# ============================================================
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.MD5PasswordHasher",
]


# ============================================================
# Final notice
# ============================================================
print("[DEV] GSMInfinity Development Settings Loaded (HTTP-only, DEBUG=True)")


--------------------------------------------
### FILE: gsminfinity\urls.py
### SIZE: 5620 bytes
### HASH: 996E5745E2EA62E8CBFEA6A47B907633CD870A5D0FE7C4E454D4C7F2E4F51F10

"""
Unified Enterprise URL Configuration for the project.

Production-ready for:
  • Django 5.2+
  • Python 3.12+
  • django-allauth 0.65+

Features:
  - Async-safe lazy loader
  - Modular routing (users, notifications under users, consent, site_settings, core)
  - Static & media (dev only)
  - Health endpoint
  - Hardened admin identity (non-branded)
"""

from __future__ import annotations

import inspect
import logging
from typing import Any, Callable

from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import include, path, re_path
from django.utils.module_loading import import_string
from django.views.generic import RedirectView
from apps.core import views as core_views

logger = logging.getLogger(__name__)


# =====================================================================
# Async-safe lazy view importer
# =====================================================================
def lazy_view(dotted_path: str) -> Callable[..., Any]:
    """
    Import view lazily at call time.
    Supports sync, async, and class-based views.
    """

    async def _wrapper(request, *args, **kwargs):
        view_obj = import_string(dotted_path)

        # Class-based view support
        if inspect.isclass(view_obj) and hasattr(view_obj, "as_view"):
            view_callable = view_obj.as_view()
        else:
            view_callable = view_obj

        result = view_callable(request, *args, **kwargs)

        # Async view support
        if inspect.isawaitable(result):
            return await result
        return result

    return _wrapper


# =====================================================================
# Admin Branding (non-branded; project rule)
# =====================================================================
admin.site.site_header = "Administration"
admin.site.site_title = "Admin Portal"
admin.site.index_title = "System Management Console"


# =====================================================================
# URL Patterns
# =====================================================================
urlpatterns = [
    # Admin
    path("admin/", admin.site.urls),
    # Authentication (allauth)
    path("accounts/", include("allauth.urls")),
    # Users module
    path("users/", include(("apps.users.urls", "users"), namespace="users")),
    # Notifications (implemented inside users app)
    # NOTE: module apps.users.notifications_urls defines app_name="users_notifications",
    # so we include it with the same internal app_name and namespace to avoid conflicts.
    path(
        "notifications/",
        include(
            ("apps.users.notifications_urls", "users_notifications"),
            namespace="users_notifications",
        ),
    ),
    # Consent subsystem
    path("consent/", include(("apps.consent.urls", "consent"), namespace="consent")),
    # Site settings
    path(
        "site_settings/",
        include(
            ("apps.site_settings.urls", "site_settings"), namespace="site_settings"
        ),
    ),
    # Ads subsystem
    path("ads/", include(("apps.ads.urls", "ads"), namespace="ads")),
    # Tags API
    path("tags/", include(("apps.tags.urls", "tags"), namespace="tags")),
    # Blog (public)
    path("blog/", include(("apps.blog.urls", "blog"), namespace="blog")),
    # Comments API
    path("comments/", include(("apps.comments.urls", "comments"), namespace="comments")),
    # Public root pages (core namespace + plain names for templates)
    path("", include(("apps.core.urls", "core"), namespace="core")),
    path("", lazy_view("apps.core.views.home"), name="home"),
    path("tenants/", lazy_view("apps.core.views.tenants"), name="tenants"),
    path("privacy/", lazy_view("apps.core.views.privacy"), name="privacy"),
    path("terms/", lazy_view("apps.core.views.terms"), name="terms"),
    path("cookies/", lazy_view("apps.core.views.cookies"), name="cookies"),
    # Health check (well-known)
    path(
        ".well-known/health",
        lazy_view("apps.core.views.health_check"),
        name="health_check",
    ),
    # AI assistant endpoint (frontend widget)
    path("api/ai/ask", core_views.ai_assistant_view, name="api_ai_ask"),
    # Legacy redirect
    path("index/", RedirectView.as_view(pattern_name="home", permanent=True)),
    # Legacy dashboard redirect removed (user dashboard lives under /users/dashboard/)
    # Favicon
    re_path(
        r"^favicon\.ico$",
        RedirectView.as_view(url="/static/favicon.ico", permanent=True),
    ),
]


# =====================================================================
# Static & Media (DEV only)
# =====================================================================
if settings.DEBUG:
    # media files
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

    try:
        from django.contrib.staticfiles.urls import staticfiles_urlpatterns

        urlpatterns += staticfiles_urlpatterns()
    except Exception as exc:
        logger.warning("staticfiles_urlpatterns() unavailable: %s", exc)
        urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)


# =====================================================================
# Error handlers
# =====================================================================
handler400 = "apps.core.views.error_400_view"
handler403 = "apps.core.views.error_403_view"
handler404 = "apps.core.views.error_404_view"
handler500 = "apps.core.views.error_500_view"


