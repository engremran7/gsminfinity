--------------------------------------------
### FILE: apps\common\totp.py
### SIZE: 1443 bytes
### HASH: F9BB66029348BF79E7F13C490D944617CF1B2DEC66064AE9333933E1B31256B6

# apps/common/totp.py
import base64, hmac, hashlib, struct, time
from typing import Optional

def _int_to_bytes(i: int) -> bytes:
    return struct.pack(">Q", i)

def _normalize_secret(secret: str) -> bytes:
    s = secret.strip().replace(" ", "").upper()
    pad = (-len(s)) % 8
    if pad:
        s += "=" * pad
    return base64.b32decode(s)

def generate_totp(secret: str, for_time: Optional[int] = None,
                  digits: int = 6, digest: str = "sha1", period: int = 30) -> str:
    if for_time is None:
        for_time = int(time.time())
    counter = int(for_time // period)
    key = _normalize_secret(secret)
    msg = _int_to_bytes(counter)
    algo = getattr(hashlib, digest)
    hmac_digest = hmac.new(key, msg, algo).digest()
    offset = hmac_digest[-1] & 0x0F
    code = (struct.unpack(">I", hmac_digest[offset:offset+4])[0] & 0x7FFFFFFF) % (10 ** digits)
    return str(code).zfill(digits)

def verify_totp(secret: str, token: str, window: int = 1,
                digits: int = 6, digest: str = "sha1", period: int = 30) -> bool:
    try:
        int(token)
    except ValueError:
        return False
    token = str(token).zfill(digits)
    now = int(time.time())
    for offset in range(-window, window + 1):
        t = now + offset * period
        if hmac.compare_digest(generate_totp(secret, t, digits, digest, period), token):
            return True
    return False


--------------------------------------------
### FILE: apps\common\utils.py
### SIZE: 155 bytes
### HASH: 958DA5DE4AFEBE935AD5B6FFE374B29CAD634851FE3E1E5E1411994D7C601698

# apps/common/utils.py
import hashlib
def short_hash(value: str, length:int=10):
    return hashlib.sha256(value.encode("utf-8")).hexdigest()[:length]


--------------------------------------------
### FILE: apps\consent\admin.py
### SIZE: 11999 bytes
### HASH: B22E4F8F70758289BB3F79DE513031314684E9E5D86ED2AB5D315088BAFD1B50

"""
apps.consent.admin
Enterprise-grade, hardened GDPR/CCPA admin interface.
Django 5.2+ • Fully safe • No deprecated APIs • No queryset logic errors.
"""

from __future__ import annotations

import csv
import json
from typing import Iterable

from django.contrib import admin
from django.db import transaction
from django.db.models import QuerySet
from django.http import HttpResponse
from django.utils.html import format_html, mark_safe
from django.utils.encoding import smart_str

from .models import ConsentPolicy, ConsentRecord, ConsentLog


# =====================================================================
#  FILTERS — ENTERPRISE HARDENED
# =====================================================================
class RejectAllFilter(admin.SimpleListFilter):
    """
    Filter records where the user rejected ALL optional cookies.

    Hardening:
    - Does NOT evaluate whole QuerySet
    - Uses DB-side filtering where possible
    - Falls back to safe in-Python logic only when required
    - Never returns lists
    """

    title = "Reject All"
    parameter_name = "reject_all"

    def lookups(self, request, model_admin):
        return [("yes", "Rejected All"), ("no", "Accepted Some")]

    def queryset(self, request, queryset: QuerySet):
        val = self.value()
        if val not in ("yes", "no"):
            return queryset

        # Optimized: detect reject_all via JSON field
        # "reject_all" is a boolean key under accepted_categories
        try:
            if val == "yes":
                return queryset.filter(accepted_categories__reject_all=True)
            else:
                return queryset.exclude(accepted_categories__reject_all=True)
        except Exception:
            # fallback safety version — robust, but slower
            ids = []
            for obj in queryset.only("pk"):
                try:
                    if (val == "yes" and obj.is_reject_all()) or (
                        val == "no" and not obj.is_reject_all()
                    ):
                        ids.append(obj.pk)
                except Exception:
                    continue

            return queryset.filter(pk__in=ids)


class PolicyVersionFilter(admin.SimpleListFilter):
    """
    Filter by policy version (distinct versions only).
    """

    title = "Policy Version"
    parameter_name = "policy_version"

    def lookups(self, request, model_admin):
        versions = (
            ConsentPolicy.objects.order_by("-created_at")
            .values_list("version", flat=True)
            .distinct()
        )
        return [(v, v) for v in versions]

    def queryset(self, request, queryset: QuerySet):
        val = self.value()
        if val:
            return queryset.filter(policy_version=val)
        return queryset


# =====================================================================
#  CONSENT POLICY ADMIN
# =====================================================================
@admin.register(ConsentPolicy)
class ConsentPolicyAdmin(admin.ModelAdmin):
    """
    Manage versioned consent policies with atomic activation logic.
    """

    readonly_fields = (
        "categories_snapshot_pretty",
        "created_at",
        "updated_at",
    )

    list_display = (
        "version",
        "site_domain",
        "is_active",
        "preview_snapshot",
        "created_at",
        "updated_at",
    )

    list_filter = ("site_domain", "is_active", "created_at")
    search_fields = ("version", "site_domain")
    ordering = ("-created_at",)
    actions = ["activate_policy", "export_policy_json"]

    fieldsets = (
        ("Policy Versioning", {
            "fields": ("version", "site_domain", "is_active"),
        }),
        ("Snapshot (read-only)", {
            "fields": ("categories_snapshot_pretty",),
        }),
        ("Timestamps", {
            "fields": ("created_at", "updated_at"),
        }),
    )

    # ---------------- JSON Pretty Printer ----------------
    @admin.display(description="Categories Snapshot")
    def categories_snapshot_pretty(self, obj):
        data = obj.categories_snapshot or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:12px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    @admin.display(description="Snapshot")
    def preview_snapshot(self, obj):
        snap = obj.categories_snapshot or {}
        return f"{len(snap)} categories"

    # ---------------- Admin Actions ----------------
    @admin.action(description="Activate selected policy (auto-deactivate siblings)")
    def activate_policy(self, request, queryset: QuerySet):
        if queryset.count() != 1:
            self.message_user(request, "❌ Select exactly ONE policy", level="error")
            return

        policy = queryset.first()

        with transaction.atomic():
            ConsentPolicy.objects.select_for_update().filter(
                site_domain=policy.site_domain
            ).exclude(pk=policy.pk).update(is_active=False)

            policy.is_active = True
            policy.save(update_fields=["is_active"])

        self.message_user(
            request,
            f"✅ Activated Policy v{policy.version} for '{policy.site_domain}'",
        )

    @admin.action(description="Export selected policies → JSON")
    def export_policy_json(self, request, queryset: QuerySet):
        response = HttpResponse(content_type="application/json; charset=utf-8")
        response["Content-Disposition"] = "attachment; filename=consent_policies.json"

        try:
            payload = [obj.to_payload() for obj in queryset]
        except Exception:
            payload = []

        response.write(json.dumps(payload, indent=2, ensure_ascii=False))
        return response


# =====================================================================
#  CONSENT RECORD ADMIN
# =====================================================================
@admin.register(ConsentRecord)
class ConsentRecordAdmin(admin.ModelAdmin):
    """
    Admin interface for user consent records.
    """

    readonly_fields = (
        "accepted_categories_pretty",
        "accepted_at",
        "updated_at",
    )

    list_display = (
        "user_display",
        "session_key",
        "policy_display",
        "site_domain",
        "is_reject_all_display",
        "accepted_summary_display",
        "updated_at",
    )

    list_filter = (
        PolicyVersionFilter,
        "site_domain",
        "updated_at",
        RejectAllFilter,
    )

    search_fields = (
        "user__email",
        "user__username",
        "session_key",
        "policy_version",
        "site_domain",
    )

    ordering = ("-updated_at",)
    actions = ["export_to_csv"]

    fieldsets = (
        ("User / Session", {"fields": ("user", "session_key", "site_domain")}),
        ("Policy Info", {"fields": ("policy", "policy_version")}),
        ("Accepted Categories", {"fields": ("accepted_categories_pretty",)}),
        ("Timestamps", {"fields": ("accepted_at", "updated_at")}),
    )

    # ---------------- JSON Pretty Printer ----------------
    @admin.display(description="Accepted Categories")
    def accepted_categories_pretty(self, obj):
        data = obj.accepted_categories or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:8px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    # ---------------- Display Helpers ----------------
    @admin.display(description="User")
    def user_display(self, obj):
        try:
            if obj.user:
                return obj.user.email or obj.user.username
        except Exception:
            pass
        return "Anonymous"

    @admin.display(description="Policy")
    def policy_display(self, obj):
        try:
            if obj.policy_version:
                return obj.policy_version
            if obj.policy:
                return obj.policy.version
        except Exception:
            pass
        return "—"

    @admin.display(boolean=True, description="Rejected All?")
    def is_reject_all_display(self, obj):
        try:
            return obj.is_reject_all()
        except Exception:
            return False

    @admin.display(description="Accepted Categories Summary")
    def accepted_summary_display(self, obj):
        try:
            return obj.audit_summary()
        except Exception:
            return "(Error)"

    # ---------------- CSV Export ----------------
    @admin.action(description="Export selected consent records → CSV")
    def export_to_csv(self, request, queryset: QuerySet):
        response = HttpResponse(content_type="text/csv; charset=utf-8")
        response["Content-Disposition"] = "attachment; filename=consent_records.csv"
        response.write("\ufeff")  # Excel-safe BOM

        writer = csv.writer(response)
        writer.writerow([
            "User",
            "Session Key",
            "Policy Version",
            "Site Domain",
            "Accepted Categories",
            "Rejected All",
            "Accepted At",
            "Updated At",
        ])

        recs: Iterable[ConsentRecord] = queryset.select_related("user", "policy")

        for rec in recs:
            writer.writerow([
                smart_str(rec.user.email if rec.user else "Anonymous"),
                smart_str(rec.session_key or ""),
                smart_str(rec.policy_version),
                smart_str(rec.site_domain),
                json.dumps(rec.accepted_categories or {}, ensure_ascii=False),
                rec.is_reject_all(),
                rec.accepted_at.isoformat() if rec.accepted_at else "",
                rec.updated_at.isoformat() if rec.updated_at else "",
            ])

        return response


# =====================================================================
#  CONSENT LOG ADMIN — READ-ONLY AUDIT TRAIL
# =====================================================================
@admin.register(ConsentLog)
class ConsentLogAdmin(admin.ModelAdmin):
    """
    Immutable forensic log entries.
    """

    readonly_fields = (
        "user",
        "ip_address",
        "user_agent",
        "policy_version",
        "site_domain",
        "timestamp",
        "accepted_categories_pretty",
    )

    list_display = (
        "user_display",
        "ip_address",
        "policy_version",
        "site_domain",
        "timestamp",
    )

    list_filter = ("site_domain", "timestamp")
    search_fields = ("user__email", "ip_address", "policy_version")
    ordering = ("-timestamp",)
    date_hierarchy = "timestamp"

    @admin.display(description="Accepted Categories")
    def accepted_categories_pretty(self, obj):
        data = obj.accepted_categories or {}
        try:
            pretty = json.dumps(data, indent=2, ensure_ascii=False)
        except Exception:
            pretty = "{}"
        return format_html(
            "<pre style='background:#fafafa; padding:8px; border-radius:6px; white-space:pre-wrap'>{}</pre>",
            mark_safe(pretty),
        )

    @admin.display(description="User")
    def user_display(self, obj):
        try:
            if obj.user:
                return obj.user.email
        except Exception:
            pass
        return "Anonymous"


--------------------------------------------
### FILE: apps\consent\api.py
### SIZE: 1410 bytes
### HASH: 8ECAA69C79B9BDB52687B7A36CB00CE4140FDC516015C824D239CF9B0FF1DD0B

"""
apps.consent.api
================

Public, import-stable API surface for Consent JSON endpoints.

Purpose:
    • Re-export the JSON API views from apps.consent.api.views
    • Allow import paths such as:
          from apps.consent.api import get_consent_status, update_consent
    • Keep internal folder structure flexible without breaking imports
    • Guarantee ASGI/WSGI-safe imports with zero side effects
    • Avoid unexpected failures during Django boot

This file must remain minimal, deterministic, and should never contain
heavy imports, query execution, or template logic.
"""

from __future__ import annotations

__all__ = [
    "get_consent_status",
    "update_consent",
]

# ---------------------------------------------------------------------
# Import Re-exports (Safe)
# ---------------------------------------------------------------------

try:
    # Canonical JSON API implementations
    from .api.views import (
        get_consent_status,
        update_consent,
    )

except Exception as exc:
    # Boot-safe fallback:
    # We intentionally DO NOT raise errors here because Django may import
    # this module during ASGI/WSGI initialization or migrations.
    # Exposing "None" keeps the import path intact without silent breakage.
    get_consent_status = None  # type: ignore
    update_consent = None      # type: ignore


--------------------------------------------
### FILE: apps\consent\api\views.py
### SIZE: 7485 bytes
### HASH: 167A3F8DFCFB0EEBB64F9FEC4586533689B8806D64EEE0162DA1EE9FAC8AEDBC

"""
apps.consent.views
==================
Enterprise-grade Consent API Endpoints.

✔ Django 5.2 / Python 3.12 compliant
✔ Strict JSON parsing + 1MB payload cap
✔ Canonical category sanitization aligned with banner + context processor
✔ Atomic, idempotent upserts
✔ Per-user cache coherence
✔ No hard-coded site names
✔ Fully ASGI/WSGI-safe
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict

from django.contrib.auth.decorators import login_required
from django.core.cache import cache
from django.db import transaction
from django.http import HttpRequest, JsonResponse
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_GET, require_POST

from apps.consent.models import ConsentRecord
from apps.consent.utils import (
    consent_cache_key,
    get_active_policy,
    resolve_site_domain,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------
# Safety limits
# ---------------------------------------------------------------

_MAX_PAYLOAD_BYTES = 1_048_576  # 1MB limit to prevent abuse


# ---------------------------------------------------------------
# Internal helpers
# ---------------------------------------------------------------

def _safe_json_parse(request: HttpRequest) -> Dict[str, Any]:
    """
    Safely parse JSON or form payloads.

    Returns {} on:
        - non-JSON payloads (fallback to form)
        - invalid body
        - non-object JSON
        - exceeding size cap
    Never raises.
    """
    ctype = (request.content_type or "").lower()

    # JSON payload
    if "application/json" in ctype:
        try:
            raw = request.body.decode("utf-8", errors="ignore")
            if len(raw) > _MAX_PAYLOAD_BYTES:
                raise ValueError("payload_too_large")

            parsed = json.loads(raw or "{}")
            return parsed if isinstance(parsed, dict) else {}

        except Exception as exc:
            logger.debug("JSON parse failed → %s", exc)
            return {}

    # Fallback: form data
    try:
        return request.POST.dict()
    except Exception:
        return {}


def _sanitize_categories(policy_snapshot: Dict[str, Any], user_data: Dict[str, Any]) -> Dict[str, bool]:
    """
    Convert user categories → {slug: bool}, enforcing required categories as True.

    Snapshot schema:
      {
        slug: {
          "required": bool,
          "name": str,
          "checked": bool
        }
      }
    """
    result: Dict[str, bool] = {}

    try:
        for slug, meta in policy_snapshot.items():
            required = bool(meta.get("required", False))
            raw = user_data.get(slug)

            # User-provided value considered only if not required
            result[slug] = True if required else bool(raw)

    except Exception as exc:
        logger.debug("Category sanitization error → %s", exc)
        # Guaranteed minimum baseline
        return {"functional": True}

    return result


# ---------------------------------------------------------------
# GET /consent/status
# ---------------------------------------------------------------

@require_GET
def get_consent_status(request: HttpRequest) -> JsonResponse:
    """
    Retrieve active policy + categories snapshot for the current site.

    Response:
        {
          "ok": True/False,
          "version": str or null,
          "site_domain": str,
          "categories": dict
        }
    """
    try:
        site_domain = resolve_site_domain(request)
        _ = consent_cache_key(site_domain)

        policy = get_active_policy(site_domain)
        if not policy:
            logger.warning("No active policy for site=%s", site_domain)
            return JsonResponse(
                {"ok": False, "error": "no_active_policy"},
                status=404,
            )

        return JsonResponse(
            {
                "ok": True,
                "version": policy.version,
                "site_domain": site_domain,
                "categories": policy.categories_snapshot or {},
            },
            status=200,
        )

    except Exception as exc:
        logger.exception("get_consent_status failure → %s", exc)
        return JsonResponse({"ok": False, "error": "internal_error"}, status=500)


# ---------------------------------------------------------------
# POST /consent/update
# ---------------------------------------------------------------

@csrf_protect
@login_required
@require_POST
def update_consent(request: HttpRequest) -> JsonResponse:
    """
    Persist authenticated user consent for the active policy.

    Guarantees:
    - Strict JSON parsing
    - Required categories always True
    - Atomic update_or_create
    - Cache coherence (invalidate only user-related cache keys)
    - Zero silent failures
    """
    try:
        # 1) Parse user payload
        data = _safe_json_parse(request)
        if not data:
            return JsonResponse(
                {"ok": False, "error": "invalid_payload"},
                status=400,
            )

        # 2) Resolve site + policy
        site_domain = resolve_site_domain(request)
        _ = consent_cache_key(site_domain)

        policy = get_active_policy(site_domain)
        if not policy:
            return JsonResponse(
                {"ok": False, "error": "no_active_policy"},
                status=404,
            )

        snapshot = policy.categories_snapshot or {}

        # 3) Sanitize categories
        sanitized = _sanitize_categories(snapshot, data)

        # 4) Atomic DB write
        try:
            with transaction.atomic():
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy.version,
                    site_domain=site_domain,
                    defaults={"accepted_categories": sanitized},
                )
        except Exception as exc:
            logger.exception("DB error updating consent → %s", exc)
            return JsonResponse(
                {"ok": False, "error": "db_error"},
                status=500,
            )

        # 5) Cache coherence — scoped delete
        try:
            cache.delete(f"user_consent_{request.user.pk}_{site_domain}")
        except Exception:
            pass

        logger.info(
            "Consent updated: user=%s site=%s policy=%s",
            getattr(request.user, "email", request.user.pk),
            site_domain,
            policy.version,
        )

        return JsonResponse(
            {
                "ok": True,
                "version": policy.version,
                "site_domain": site_domain,
            },
            status=200,
        )

    # Malformed JSON or bad logic in input
    except ValueError as exc:
        logger.warning("update_consent bad request → %s", exc)
        return JsonResponse({"ok": False, "error": "bad_request"}, status=400)

    # True unexpected server failure
    except Exception as exc:
        logger.exception("update_consent unexpected failure → %s", exc)
        return JsonResponse({"ok": False, "error": "internal_error"}, status=500)


--------------------------------------------
### FILE: apps\consent\apps.py
### SIZE: 1282 bytes
### HASH: 7BC18D7A93B2CAEA715038C928569095418D68D2F3DB4964F6D4A030806B5CF0

# apps/consent/apps.py
"""
Consent App Configuration
--------------------------
Initializes the Consent Management subsystem.
Ensures signal registration and avoids double import duplication.
"""

import logging
from django.apps import AppConfig

log = logging.getLogger(__name__)


class ConsentConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.consent"
    label = "consent"
    verbose_name = "Consent Management"

    def ready(self):
        """
        App startup logic:
        ✅ Imports signals after Django app registry is ready
        ✅ Prevents double import issues under ASGI/WSGI reloads
        ✅ Provides safe logging for debugging startup issues
        """
        # Avoid running twice under autoreload (common in runserver)
        if getattr(self, "_consent_ready_ran", False):
            return
        self._consent_ready_ran = True

        try:
            import apps.consent.signals  # noqa: F401
            log.debug("Consent signals registered successfully.")
        except ImportError:
            log.info("No consent signals found (skipping registration).")
        except Exception as exc:
            log.warning(f"Error importing consent signals: {exc}")


--------------------------------------------
### FILE: apps\consent\context_processors.py
### SIZE: 5319 bytes
### HASH: 39064D50359E2FCBDB20DAF05F201D14BA7F5371AB9DC31B0CAFB0FC8A1078FC

"""
apps.consent.context_processors
===============================

Injects consent state and metadata into all Django templates.

- Django 5.2+ / Python 3.12+
- Async-safe, thread-safe, side-effect free
- Compatible with canonical banner structure:
      {slug: {"checked": bool, "required": bool, "name": str}}
- Fully backward-compatible with older variables
"""

from __future__ import annotations

import logging
from typing import Any, Dict
from django.http import HttpRequest
from django.utils.functional import SimpleLazyObject
from django.conf import settings

from apps.consent.models import ConsentPolicy

logger = logging.getLogger(__name__)


def consent_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Canonical consent context for templates.

    Provides:
      - has_cookie_consent: bool
      - cookie_consent_categories: dict[str, bool]
      - consent_categories: dict[str, {checked, required, name}]
      - consent_version, consent_summary
      - active_consent_policy: lazy-loaded ConsentPolicy | None
      - consent_cookie_* settings

    Never raises — always returns safe defaults.
    """

    def _lazy_active_policy():
        """Lazy resolver for active ConsentPolicy (middleware-first)."""
        try:
            existing = getattr(request, "consent_policy", None)
            if existing is not None:
                return existing
            return ConsentPolicy.get_active()
        except Exception as exc:
            logger.warning("Consent context lazy policy failed: %s", exc)
            return None

    try:
        raw = getattr(request, "consent_categories", {}) or {}

        cookie_map: Dict[str, bool] = {}
        canonical: Dict[str, Dict[str, Any]] = {}

        # -----------------------------
        # Build canonical structured map
        # -----------------------------
        try:
            for slug, val in dict(raw).items():
                if isinstance(val, dict):
                    checked = bool(val.get("checked", val.get("accepted", False)))
                    required = bool(val.get("required", False))
                    name = val.get("name", slug)
                else:
                    checked = bool(val)
                    required = False
                    name = slug

                cookie_map[str(slug)] = checked
                canonical[str(slug)] = {
                    "checked": checked,
                    "required": required,
                    "name": name,
                }
        except Exception:
            # if any corruption or unexpected structure occurs
            cookie_map = {"functional": True}
            canonical = {
                "functional": {"checked": True, "required": True, "name": "functional"}
            }

        # ------------------------------------------------------------------
        # Guarantee presence of functional cookies — required by EU regulation
        # ------------------------------------------------------------------
        if "functional" not in canonical:
            canonical["functional"] = {
                "checked": True,
                "required": True,
                "name": "functional",
            }
            cookie_map.setdefault("functional", True)
        else:
            canonical["functional"]["required"] = True
            cookie_map.setdefault("functional", True)

        # ---------------------------
        # Construct final safe context
        # ---------------------------
        ctx: Dict[str, Any] = {
            "has_cookie_consent": bool(getattr(request, "has_cookie_consent", False)),
            "cookie_consent_categories": cookie_map,
            "consent_categories": canonical,  # canonical, banner-safe
            "consent_version": getattr(request, "consent_version", None),
            "consent_summary": dict(getattr(request, "consent_summary", {}) or {}),
            "active_consent_policy": SimpleLazyObject(_lazy_active_policy),
            "consent_cookie_name": getattr(settings, "CONSENT_COOKIE_NAME", "consent_status"),
            "consent_cookie_secure": bool(
                getattr(settings, "CONSENT_COOKIE_SECURE", not getattr(settings, "DEBUG", False))
            ),
            "consent_cookie_samesite": getattr(
                settings, "CONSENT_COOKIE_SAMESITE", "Lax"
            ),
            "consent_cookie_max_age": int(
                getattr(settings, "CONSENT_COOKIE_MAX_AGE", 31536000
            )),
        }

        return ctx

    except Exception as exc:
        logger.exception("Consent context processor failed: %s", exc)
        return {
            "has_cookie_consent": False,
            "cookie_consent_categories": {"functional": True},
            "consent_categories": {
                "functional": {"checked": True, "required": True, "name": "functional"}
            },
            "consent_version": None,
            "consent_summary": {},
            "active_consent_policy": None,
            "consent_cookie_name": "consent_status",
            "consent_cookie_secure": False,
            "consent_cookie_samesite": "Lax",
            "consent_cookie_max_age": 31536000,
        }


--------------------------------------------
### FILE: apps\consent\decorators.py
### SIZE: 4248 bytes
### HASH: 4BDBF1ECC732A960715770BBC4855711AD9AC1DE78D10AA345BFC54D39D53CB8

# apps/consent/decorators.py
"""
Consent Decorators
------------------
Reusable decorators to enforce consent validation for
protected or analytics-sensitive endpoints.

Features:
- Sync & async view support (Django 4.2+)
- Works with middleware-injected cookie_consent namespace
- AJAX-friendly JSON response
- Graceful fallback when middleware missing
"""

import logging
import asyncio
from functools import wraps
from inspect import iscoroutinefunction
from django.http import HttpResponseForbidden, JsonResponse

log = logging.getLogger(__name__)


def require_consent(category: str = "analytics", ajax_friendly: bool = True):
    """
    Decorator to enforce cookie/data-usage consent before executing a view.

    Args:
        category (str): Consent category slug (e.g., "analytics", "ads", "functional").
        ajax_friendly (bool): If True, returns JSON 403 for AJAX requests.

    Behavior:
        ✅ Checks `request.cookie_consent` and `request.has_cookie_consent`
        ✅ Graceful fallback when middleware not initialized
        ✅ Works with both sync and async Django views
        ✅ Prevents accidental access without consent
    """

    def _deny_access(request, category: str):
        """Return a standardized 403 response."""
        msg = f"Consent required for category '{category}'."
        if ajax_friendly and (
            request.headers.get("x-requested-with") == "XMLHttpRequest"
            or (request.content_type or "").startswith("application/json")
        ):
            return JsonResponse({"error": "consent_required", "category": category}, status=403)
        return HttpResponseForbidden(msg, content_type="text/plain; charset=utf-8")

    def decorator(view_func):
        if iscoroutinefunction(view_func):
            # ---------------- Async Path ----------------
            @wraps(view_func)
            async def _wrapped_async(request, *args, **kwargs):
                try:
                    cookie_ns = getattr(request, "cookie_consent", None)
                    has_category = bool(getattr(cookie_ns, category, False)) if cookie_ns else False
                    has_overall = bool(getattr(request, "has_cookie_consent", False))

                    if not (has_category and has_overall):
                        log.info(
                            "Access blocked (async): user=%s ip=%s category=%s path=%s",
                            getattr(request.user, "email", "anon"),
                            request.META.get("REMOTE_ADDR", "unknown"),
                            category,
                            request.path,
                        )
                        return _deny_access(request, category)
                except Exception as exc:
                    log.warning("Consent validation failed (async) for %s → %s", category, exc)
                    return HttpResponseForbidden("Consent validation error.")
                return await view_func(request, *args, **kwargs)

            return _wrapped_async

        # ---------------- Sync Path ----------------
        @wraps(view_func)
        def _wrapped(request, *args, **kwargs):
            try:
                cookie_ns = getattr(request, "cookie_consent", None)
                has_category = bool(getattr(cookie_ns, category, False)) if cookie_ns else False
                has_overall = bool(getattr(request, "has_cookie_consent", False))

                if not (has_category and has_overall):
                    log.info(
                        "Access blocked: user=%s ip=%s category=%s path=%s",
                        getattr(request.user, "email", "anon"),
                        request.META.get("REMOTE_ADDR", "unknown"),
                        category,
                        request.path,
                    )
                    return _deny_access(request, category)
            except Exception as exc:
                log.warning("Consent validation failed for %s → %s", category, exc)
                return HttpResponseForbidden("Consent validation error.")
            return view_func(request, *args, **kwargs)

        return _wrapped

    return decorator


--------------------------------------------
### FILE: apps\consent\middleware.py
### SIZE: 12465 bytes
### HASH: D61603372232427997CCBDFFE3D431D4CDF12456FB6AE086854F6D78400EAC5A

"""
apps.consent.middleware
=======================

Enterprise-grade cookie-consent middleware.

- Callable middleware (WSGI + ASGI safe)
- Uses canonical utils (serializable policy payloads only)
- Session guarantee for anonymous visitors (best-effort)
- Robust ConsentRecord loading for user or session
- Exposes request.consent_* attributes for templates/analytics
- Defensive: never raises even if DB or cache is down
"""

from __future__ import annotations

import json
import logging
from types import SimpleNamespace
from typing import Dict, Optional, Tuple, Any, Set

from django.conf import settings
from django.http import HttpRequest, HttpResponse

from apps.consent.utils import (
    consent_cache_key,
    get_active_policy,
    resolve_site_domain,
)
from apps.consent.models import ConsentRecord

logger = logging.getLogger(__name__)


# =====================================================================
#  MAIN MIDDLEWARE
# =====================================================================
class ConsentMiddleware:
    """
    Middleware that attaches consent information to each request.

    Add:
        "apps.consent.middleware.ConsentMiddleware"
    AFTER:
        AuthenticationMiddleware
        SessionMiddleware
    """

    def __init__(self, get_response):
        self.get_response = get_response

        # Avoid unsafe, brand-specific defaults — now generic
        self.cookie_name: str = getattr(settings, "CONSENT_COOKIE_NAME", "cookie_consent")
        self.cookie_max_age: int = int(
            getattr(settings, "CONSENT_COOKIE_MAX_AGE", 60 * 60 * 24 * 365)
        )
        self.cookie_samesite: str = getattr(settings, "CONSENT_COOKIE_SAMESITE", "Lax")
        self.cookie_secure: bool = bool(
            getattr(settings, "CONSENT_COOKIE_SECURE", not settings.DEBUG)
        )

    # =================================================================
    #  WSGI + ASGI entrypoint
    # =================================================================
    def __call__(self, request: HttpRequest) -> HttpResponse:
        # Baseline request attributes — MUST be set before any early returns
        request.has_cookie_consent = False
        request.consent_policy = None
        request.consent_version = None
        request.consent_categories = {}
        request.cookie_consent = SimpleNamespace()
        request.consent_summary = {}

        # -------------------------------
        # Ensure session exists (safe)
        # -------------------------------
        try:
            self._ensure_session(request)
        except Exception as exc:
            logger.debug("ConsentMiddleware: session bootstrap failed -> %s", exc)

        # -------------------------------
        # Determine domain
        # -------------------------------
        try:
            site_domain = resolve_site_domain(request)
        except Exception as exc:
            logger.debug("ConsentMiddleware: resolve_site_domain failed -> %s", exc)
            site_domain = None

        if not site_domain:
            site_domain = getattr(settings, "DEFAULT_SITE_DOMAIN", "default")

        # -------------------------------
        # Validate that cache_key works
        # -------------------------------
        try:
            consent_cache_key(site_domain)
        except Exception:
            logger.debug("ConsentMiddleware: cache key generation failure (ignored)")

        # -------------------------------
        # Load policy payload
        # -------------------------------
        try:
            policy_payload = get_active_policy(site_domain)
        except Exception as exc:
            logger.debug("ConsentMiddleware: policy load failed -> %s", exc)
            policy_payload = None

        if policy_payload:
            request.consent_policy = policy_payload
            request.consent_version = policy_payload.get("version")

        # -------------------------------
        # Try retrieving stored record
        # -------------------------------
        consent_record = None
        if request.consent_version:
            try:
                consent_record = self._get_consent_record(
                    request, request.consent_version, site_domain
                )
            except Exception as exc:
                logger.debug("ConsentMiddleware: record lookup failed -> %s", exc)

        # -------------------------------
        # Build baseline categories
        # -------------------------------
        try:
            categories, required = self._build_baseline_categories(policy_payload)
        except Exception:
            logger.exception(
                "ConsentMiddleware: baseline categories build failed, using safe fallback"
            )
            categories, required = {"functional": True}, {"functional"}

        # -------------------------------
        # Apply stored consent OR defaults
        # -------------------------------
        try:
            if consent_record:
                categories, has_opt_in = self._apply_consent_record(
                    categories, required, consent_record
                )
                request.has_cookie_consent = has_opt_in
            else:
                # Anonymous fallback (required=True, optional=False)
                for slug in list(categories.keys()):
                    categories[slug] = bool(slug in required)
                request.has_cookie_consent = False
        except Exception:
            logger.exception("ConsentMiddleware: applying record failed; fallback")
            for slug in list(categories.keys()):
                categories[slug] = bool(slug in required)
            request.has_cookie_consent = False

        # -------------------------------
        # Hard enforce required categories
        # -------------------------------
        for slug in required:
            categories[slug] = True

        # -------------------------------
        # Attach attributes
        # -------------------------------
        request.consent_categories = categories
        try:
            request.cookie_consent = SimpleNamespace(**categories)
        except Exception:
            request.cookie_consent = SimpleNamespace()

        request.consent_summary = {
            "version": request.consent_version,
            "active": bool(policy_payload),
            "has_consent": request.has_cookie_consent,
            "required": sorted(list(required)),
            "site": site_domain,
        }

        logger.debug("ConsentMiddleware summary: %s", request.consent_summary)

        # =================================================================
        #  Downstream request
        # =================================================================
        response = self.get_response(request)

        # =================================================================
        #  Response hook (cookie writer)
        # =================================================================
        try:
            response = self.process_response(request, response)
        except Exception:
            logger.exception("ConsentMiddleware: response hook failed")

        return response

    # =====================================================================
    #  INTERNAL HELPERS
    # =====================================================================
    def _ensure_session(self, request: HttpRequest) -> None:
        """Ensure session exists for anonymous users."""
        session = getattr(request, "session", None)
        if not session:
            logger.warning("ConsentMiddleware: SessionMiddleware missing.")
            return

        try:
            if not session.session_key:
                session.create()
                session.modified = True
                logger.debug("ConsentMiddleware: new session created")
        except Exception as exc:
            logger.debug("ConsentMiddleware: session create failed -> %s", exc)

    # ---------------------------------------------------------------------
    def _get_consent_record(
        self, request: HttpRequest, policy_version: str, site_domain: str
    ) -> Optional[ConsentRecord]:
        """
        Retrieve ConsentRecord applying database-accurate filters.
        """
        user = getattr(request, "user", None)
        lookup = {"site_domain": site_domain, "policy_version": policy_version}

        try:
            if user and getattr(user, "is_authenticated", False):
                lookup["user"] = user
            else:
                lookup["user__isnull"] = True
                lookup["session_key"] = getattr(request.session, "session_key", None)

            return (
                ConsentRecord.objects.filter(**lookup)
                .order_by("-updated_at", "-created_at")
                .first()
            )
        except Exception as exc:
            logger.debug("ConsentMiddleware: ORM lookup failed -> %s", exc)
            return None

    # ---------------------------------------------------------------------
    def _build_baseline_categories(
        self, policy_payload: Optional[dict]
    ) -> Tuple[Dict[str, bool], Set[str]]:
        """Build baseline categories purely from the JSON snapshot."""
        categories: Dict[str, bool] = {}
        required: Set[str] = set()

        try:
            snap = policy_payload.get("categories_snapshot", {}) if policy_payload else {}
            if isinstance(snap, dict):
                for slug, data in snap.items():
                    slug = str(slug)
                    categories[slug] = False
                    if isinstance(data, dict) and data.get("required"):
                        required.add(slug)
        except Exception as exc:
            logger.debug("ConsentMiddleware: category parsing failed -> %s", exc)

        # Functional is always required
        categories.setdefault("functional", True)
        required.add("functional")

        return categories, required

    # ---------------------------------------------------------------------
    def _apply_consent_record(
        self, categories: Dict[str, bool], required: Set[str], record: ConsentRecord
    ) -> Tuple[Dict[str, bool], bool]:

        try:
            accepted = record.accepted_categories or {}
        except Exception:
            accepted = {}

        if accepted.get("reject_all"):
            for slug in list(categories.keys()):
                categories[slug] = slug in required
            return categories, False

        any_optional = False
        for slug in list(categories.keys()):
            if slug in required:
                categories[slug] = True
            else:
                categories[slug] = bool(accepted.get(slug))
                if categories[slug]:
                    any_optional = True

        return categories, any_optional

    # =====================================================================
    #  RESPONSE HOOK — cookie writer
    # =====================================================================
    def process_response(self, request: HttpRequest, response: HttpResponse) -> HttpResponse:
        """Write cookie storing accepted categories — best effort."""
        try:
            if request.has_cookie_consent:
                try:
                    payload = dict(request.consent_categories)
                except Exception:
                    payload = {"functional": True}

                try:
                    value = json.dumps(payload)
                    response.set_cookie(
                        self.cookie_name,
                        value,
                        max_age=self.cookie_max_age,
                        samesite=self.cookie_samesite,
                        secure=self.cookie_secure,
                        httponly=False,  # UI needs access
                    )
                except Exception as exc:
                    logger.debug("ConsentMiddleware: set_cookie failed -> %s", exc)
        except Exception as exc:
            logger.debug("ConsentMiddleware: process_response error -> %s", exc)

        return response


--------------------------------------------
### FILE: apps\consent\migrations\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\consent\migrations\0001_initial.py
### SIZE: 4158 bytes
### HASH: C03147FB8E8EE6AA7ABA1BB5C09859805B2919DA87BFDC58A36F0C5152479E03

# Generated by Django 5.2.8 on 2025-11-18 21:26

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='ConsentLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('ip_address', models.GenericIPAddressField(blank=True, null=True)),
                ('user_agent', models.TextField(blank=True)),
                ('accepted_categories', models.JSONField(blank=True, default=dict)),
                ('policy_version', models.CharField(blank=True, max_length=20)),
                ('site_domain', models.CharField(default='default', max_length=100)),
                ('timestamp', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Consent log',
                'verbose_name_plural': 'Consent logs',
                'ordering': ['-timestamp'],
            },
        ),
        migrations.CreateModel(
            name='ConsentPolicy',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('version', models.CharField(max_length=20, unique=True)),
                ('site_domain', models.CharField(db_index=True, default='default', max_length=100)),
                ('is_active', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('categories_snapshot', models.JSONField(blank=True, default=dict)),
                ('banner_text', models.TextField(blank=True, default='We use cookies to improve your browsing experience.')),
                ('manage_text', models.TextField(blank=True, default='Manage your cookie preferences.')),
                ('cache_ttl_seconds', models.PositiveIntegerField(default=300, help_text='TTL (seconds) for cached active policy payload.')),
            ],
            options={
                'verbose_name': 'Consent policy',
                'verbose_name_plural': 'Consent policies',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='ConsentRecord',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('session_key', models.CharField(blank=True, db_index=True, max_length=64, null=True)),
                ('policy_version', models.CharField(blank=True, max_length=20)),
                ('site_domain', models.CharField(default='default', max_length=100)),
                ('accepted_categories', models.JSONField(blank=True, default=dict)),
                ('accepted_at', models.DateTimeField(blank=True, null=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'Consent record',
                'verbose_name_plural': 'Consent records',
                'ordering': ['-updated_at'],
            },
        ),
        migrations.CreateModel(
            name='ConsentCategory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True)),
                ('slug', models.SlugField(max_length=100, unique=True)),
                ('description', models.TextField(blank=True)),
                ('required', models.BooleanField(default=False)),
            ],
            options={
                'verbose_name': 'Consent category',
                'verbose_name_plural': 'Consent categories',
                'ordering': ['required', 'name'],
                'indexes': [models.Index(fields=['slug'], name='consent_cat_slug_idx')],
            },
        ),
    ]


--------------------------------------------
### FILE: apps\consent\migrations\0002_initial.py
### SIZE: 3302 bytes
### HASH: 53E884D5EF86E9BEA5B10E21760DAA75C001D8FBFF4B820759EB0F5ECF2BB88F

# Generated by Django 5.2.8 on 2025-11-18 21:26

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('consent', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='consentlog',
            name='user',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='consent_logs', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddIndex(
            model_name='consentpolicy',
            index=models.Index(fields=['site_domain'], name='consent_policy_site_idx'),
        ),
        migrations.AddIndex(
            model_name='consentpolicy',
            index=models.Index(fields=['version'], name='consent_policy_version_idx'),
        ),
        migrations.AddConstraint(
            model_name='consentpolicy',
            constraint=models.UniqueConstraint(condition=models.Q(('is_active', True)), fields=('site_domain', 'is_active'), name='unique_active_policy_per_site'),
        ),
        migrations.AddField(
            model_name='consentrecord',
            name='policy',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.PROTECT, related_name='consent_records', to='consent.consentpolicy', to_field='version'),
        ),
        migrations.AddField(
            model_name='consentrecord',
            name='user',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='consent_records', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddIndex(
            model_name='consentlog',
            index=models.Index(fields=['timestamp'], name='consent_log_time_idx'),
        ),
        migrations.AddIndex(
            model_name='consentrecord',
            index=models.Index(fields=['policy_version'], name='consent_rec_policy_idx'),
        ),
        migrations.AddIndex(
            model_name='consentrecord',
            index=models.Index(fields=['site_domain'], name='consent_rec_site_idx'),
        ),
        migrations.AddIndex(
            model_name='consentrecord',
            index=models.Index(fields=['user', 'site_domain', 'updated_at'], name='consent_user_site_time_idx'),
        ),
        migrations.AddConstraint(
            model_name='consentrecord',
            constraint=models.UniqueConstraint(fields=('user', 'policy_version', 'site_domain'), name='unique_consent_per_user'),
        ),
        migrations.AddConstraint(
            model_name='consentrecord',
            constraint=models.UniqueConstraint(fields=('session_key', 'policy_version', 'site_domain'), name='unique_consent_per_session'),
        ),
        migrations.AddConstraint(
            model_name='consentrecord',
            constraint=models.CheckConstraint(condition=models.Q(('user__isnull', False), models.Q(('session_key__isnull', False), models.Q(('session_key', ''), _negated=True)), _connector='OR'), name='valid_user_or_session'),
        ),
    ]


--------------------------------------------
### FILE: apps\consent\models.py
### SIZE: 13142 bytes
### HASH: 02E2AEE3068770645A87F1E34A99465C9FF60B800F1AA1B588F6A3D27F105D10

"""
apps.consent.models
===================

Authoritative, consolidated GDPR/CCPA consent models.
- Django 5.2 / Python 3.12 compliant
- No duplicate definitions
- No deprecated APIs
- Correct FK wiring
- Fully aligned with utils + views + API
"""

from __future__ import annotations

import logging
from typing import Any, Dict, Optional

from django.conf import settings
from django.core.cache import cache
from django.db import models, transaction
from django.utils import timezone
from django.utils.text import slugify

logger = logging.getLogger(__name__)


# ============================================================================
# ConsentCategory
# ============================================================================

class ConsentCategory(models.Model):
    """Configurable GDPR/CCPA category such as analytics, marketing, essential."""

    name = models.CharField(max_length=100, unique=True)
    slug = models.SlugField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    required = models.BooleanField(default=False)

    class Meta:
        ordering = ["required", "name"]
        verbose_name = "Consent category"
        verbose_name_plural = "Consent categories"
        indexes = [
            models.Index(fields=["slug"], name="consent_cat_slug_idx"),
        ]

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)

        super().save(*args, **kwargs)

        # Invalidate all domains — safe
        try:
            from apps.consent.utils import invalidate_policy_cache
            invalidate_policy_cache(None)
        except Exception as exc:
            logger.warning("ConsentCategory.save: cache invalidation failed → %s", exc)


# ============================================================================
# ConsentPolicy
# ============================================================================

class ConsentPolicy(models.Model):
    """
    Versioned, auditable consent policy.
    Provides banner text, management text, snapshot, and TTL.
    """

    # NOT PK — Django still generates automatic integer PK
    version = models.CharField(max_length=20, unique=True)

    site_domain = models.CharField(
        max_length=100,
        default="default",
        db_index=True,
        help_text="Domain this policy belongs to.",
    )

    is_active = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    categories_snapshot = models.JSONField(default=dict, blank=True)

    banner_text = models.TextField(
        blank=True,
        default="We use cookies to improve your browsing experience.",
    )
    manage_text = models.TextField(
        blank=True,
        default="Manage your cookie preferences.",
    )

    cache_ttl_seconds = models.PositiveIntegerField(
        default=300,
        help_text="Cache TTL for the active policy payload.",
    )

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Consent policy"
        verbose_name_plural = "Consent policies"
        constraints = [
            # Only one active policy per domain
            models.UniqueConstraint(
                fields=["site_domain", "is_active"],
                condition=models.Q(is_active=True),
                name="unique_active_policy_per_site",
            )
        ]
        indexes = [
            models.Index(fields=["site_domain"], name="consent_policy_site_idx"),
            models.Index(fields=["version"], name="consent_policy_version_idx"),
        ]

    def __str__(self):
        return f"{self.site_domain} · v{self.version}"

    # ----------------------------------------------------------------------

    @staticmethod
    def _build_snapshot() -> Dict[str, Any]:
        """Convert ConsentCategory rows → JSON snapshot."""
        try:
            return {
                c.slug: {
                    "name": c.name,
                    "description": c.description or "",
                    "required": bool(c.required),
                }
                for c in ConsentCategory.objects.all()
            }
        except Exception as exc:
            logger.exception("ConsentPolicy._build_snapshot failed → %s", exc)
            return {}

    # ----------------------------------------------------------------------

    def to_payload(self) -> Dict[str, Any]:
        """Serializable dict consumed by utils, views, and API."""
        ttl = int(self.cache_ttl_seconds or settings.CONSENT_POLICY_CACHE_TTL)
        return {
            "version": str(self.version),
            "categories_snapshot": self.categories_snapshot or {},
            "cache_ttl_seconds": ttl,
            "banner_text": self.banner_text or "",
            "manage_text": self.manage_text or "",
            "site_domain": self.site_domain,
        }

    # ----------------------------------------------------------------------

    def save(self, *args, **kwargs):
        """Atomic write + ensure only one active policy per domain."""
        self.site_domain = (self.site_domain or "default").strip().lower()

        # Always rebuild snapshot
        try:
            snapshot = self._build_snapshot()
            if not self.pk or snapshot != self.categories_snapshot:
                self.categories_snapshot = snapshot
        except Exception as exc:
            logger.error("ConsentPolicy.save: snapshot error → %s", exc)

        try:
            if self.is_active:
                # Enforce active=1 per domain
                with transaction.atomic():
                    ConsentPolicy.objects.select_for_update().filter(
                        site_domain=self.site_domain,
                        is_active=True
                    ).exclude(pk=self.pk).update(is_active=False)

                    super().save(*args, **kwargs)
            else:
                super().save(*args, **kwargs)

        except Exception as exc:
            logger.error("ConsentPolicy.save failed → %s", exc)
            raise

        # Invalidate only this domain
        try:
            from apps.consent.utils import invalidate_policy_cache
            invalidate_policy_cache(self.site_domain)
        except Exception as exc:
            logger.warning("ConsentPolicy.save: failed to invalidate → %s", exc)

    # ----------------------------------------------------------------------

    @classmethod
    def get_active(cls, site_domain="default") -> Optional[Dict[str, Any]]:
        try:
            from apps.consent.utils import get_active_policy
            return get_active_policy(site_domain)
        except Exception:
            return None


# ============================================================================
# ConsentRecord
# ============================================================================

class ConsentRecord(models.Model):
    """
    Per-user/session consent state for a *specific policy version*.
    """

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="consent_records",
    )

    session_key = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        db_index=True,
    )

    # Correct FK wiring — bind by version string, not PK
    policy = models.ForeignKey(
        ConsentPolicy,
        to_field="version",
        db_column="policy_version",
        on_delete=models.PROTECT,
        null=True, blank=True,
        related_name="records",
    )

    # Duplicate for quick lookup
    policy_version = models.CharField(max_length=20, blank=True)

    site_domain = models.CharField(max_length=100, default="default")

    accepted_categories = models.JSONField(default=dict, blank=True)

    accepted_at = models.DateTimeField(null=True, blank=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-updated_at"]
        verbose_name = "Consent record"
        verbose_name_plural = "Consent records"
        constraints = [
            models.UniqueConstraint(
                fields=["user", "policy_version", "site_domain"],
                name="unique_consent_per_user",
            ),
            models.UniqueConstraint(
                fields=["session_key", "policy_version", "site_domain"],
                name="unique_consent_per_session",
            ),
            models.CheckConstraint(
                check=models.Q(user__isnull=False)
                | (models.Q(session_key__isnull=False) & ~models.Q(session_key="")),
                name="valid_user_or_session",
            ),
        ]
        indexes = [
            models.Index(fields=["policy_version"], name="consent_rec_policy_idx"),
            models.Index(fields=["site_domain"], name="consent_rec_site_idx"),
            models.Index(
                fields=["user", "site_domain", "updated_at"],
                name="consent_user_site_time_idx",
            ),
        ]

    def __str__(self):
        ident = getattr(self.user, "email", None) or self.session_key or "anonymous"
        return f"{ident} · v{self.policy_version or 'N/A'}"

    # ----------------------------------------------------------------------

    def save(self, *args, **kwargs):
        """Strict, deterministic, no silent failure."""
        if self.accepted_categories and not self.accepted_at:
            self.accepted_at = timezone.now()

        # Sync version from FK
        if self.policy and not self.policy_version:
            try:
                self.policy_version = self.policy.version
            except Exception:
                pass

        self.site_domain = (self.site_domain or "default").strip().lower()

        super().save(*args, **kwargs)

    # ----------------------------------------------------------------------

    def is_reject_all(self) -> bool:
        """
        True if all optional categories are rejected.
        Required categories don't count.
        """
        accepted = self.accepted_categories or {}
        if not accepted:
            return True

        # Cache required slugs
        try:
            required = cache.get("required_consent_categories")
            if required is None:
                required = set(
                    ConsentCategory.objects.filter(required=True).values_list("slug", flat=True)
                )
                cache.set("required_consent_categories", required, 3600)
        except Exception:
            required = set()

        try:
            return not any(v for k, v in accepted.items() if k not in required)
        except Exception:
            return True

    # ----------------------------------------------------------------------

    def audit_summary(self) -> str:
        """Human-readable list of accepted categories."""
        try:
            if not self.accepted_categories:
                return "No categories accepted"

            accepted_names = []
            for slug, val in self.accepted_categories.items():
                if not val:
                    continue
                cat = ConsentCategory.objects.filter(slug=slug).only("name").first()
                if cat:
                    accepted_names.append(cat.name)

            return ", ".join(sorted(accepted_names)) if accepted_names else "None"
        except Exception:
            return "Unavailable"


# ============================================================================
# ConsentLog
# ============================================================================

class ConsentLog(models.Model):
    """Immutable audit log of user/session consent actions."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True, blank=True,
        on_delete=models.SET_NULL,
        related_name="consent_logs",
    )

    ip_address = models.GenericIPAddressField(null=True, blank=True)
    user_agent = models.TextField(blank=True)

    accepted_categories = models.JSONField(default=dict, blank=True)

    policy_version = models.CharField(max_length=20, blank=True)
    site_domain = models.CharField(max_length=100, default="default")

    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-timestamp"]
        verbose_name = "Consent log"
        verbose_name_plural = "Consent logs"
        indexes = [
            models.Index(fields=["timestamp"], name="consent_log_time_idx"),
        ]

    def __str__(self):
        ident = getattr(self.user, "email", None) or self.ip_address or "unknown"
        return f"{ident} @ {self.timestamp:%Y-%m-%d %H:%M}"


--------------------------------------------
### FILE: apps\consent\signals.py
### SIZE: 6326 bytes
### HASH: 3C8D6B51A484269DE0A77333C689DF3C824B39C041E668D612B3B214AB4E8D7F

"""
apps.consent.signals
====================

Enterprise-grade signal handlers for consent management.

✅ Django 5.2 / Python 3.12 Ready
✅ Seamless merge of session → user consent on login
✅ Cleans redundant session records post-merge
✅ Uses canonical utils for site & policy resolution
✅ Defensive session handling and cleanup
✅ Atomic DB ops, async-safe, no silent leaks
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from django.contrib.auth.signals import user_logged_in, user_logged_out
from django.db import transaction
from django.dispatch import receiver

from apps.consent.models import ConsentRecord
from apps.consent.utils import resolve_site_domain, get_active_policy

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Internal helper
# ---------------------------------------------------------------------------

def _safe_session_key(request) -> Optional[str]:
    """Return session key if available, else None."""
    try:
        return getattr(getattr(request, "session", None), "session_key", None)
    except Exception:
        return None


# ---------------------------------------------------------------------------
# USER LOGIN — Merge Session Consent
# ---------------------------------------------------------------------------

@receiver(user_logged_in, dispatch_uid="merge_session_consent_v2")
def merge_session_consent(sender: Any, user: Any, request, **kwargs) -> None:
    """
    On user login, merge any session-based consent record into the
    user's permanent consent record.

    - Uses canonical helpers
    - Fully defensive and idempotent
    - Atomic update to avoid partial merges
    """

    # 1️⃣ Resolve site domain
    try:
        site_domain = resolve_site_domain(request)
    except Exception as exc:
        logger.debug("merge_session_consent: resolve_site_domain failed → %s", exc)
        site_domain = "default"

    # 2️⃣ Retrieve active policy
    policy = get_active_policy(site_domain)
    if not policy:
        logger.debug("merge_session_consent: no active policy for site=%s", site_domain)
        return

    # 3️⃣ Get session key
    session_key = _safe_session_key(request)
    if not session_key:
        logger.debug(
            "merge_session_consent: session missing or no key for user=%s",
            getattr(user, "email", None),
        )
        return

    # 4️⃣ Fetch anonymous session consent record
    try:
        session_rec = ConsentRecord.objects.filter(
            session_key=session_key,
            policy_version=policy.version,
            site_domain=site_domain,
            user__isnull=True,
        ).first()
    except Exception as exc:
        logger.exception("merge_session_consent: lookup failed for %s → %s", session_key, exc)
        return

    if not session_rec:
        logger.debug("merge_session_consent: no session record for key=%s", session_key)
        return

    # 5️⃣ Merge into user-level record (atomic)
    try:
        with transaction.atomic():
            user_rec, created = ConsentRecord.objects.select_for_update().get_or_create(
                user=user,
                policy_version=policy.version,
                site_domain=site_domain,
                defaults={
                    "accepted_categories": session_rec.accepted_categories,
                    "session_key": session_key,
                },
            )

            if created:
                logger.info(
                    "merge_session_consent: created consent v%s for %s (%s)",
                    policy.version,
                    getattr(user, "email", None),
                    site_domain,
                )
            else:
                if user_rec.accepted_categories != session_rec.accepted_categories:
                    user_rec.accepted_categories = session_rec.accepted_categories
                    user_rec.save(update_fields=["accepted_categories", "updated_at"])
                    logger.debug(
                        "merge_session_consent: updated existing consent for %s (site=%s)",
                        getattr(user, "email", None),
                        site_domain,
                    )

            # 6️⃣ Clean redundant session record
            try:
                session_rec.delete()
                logger.debug(
                    "merge_session_consent: cleaned session record key=%s", session_key
                )
            except Exception as exc:
                logger.debug(
                    "merge_session_consent: cleanup failed for %s → %s", session_key, exc
                )

    except Exception as exc:
        logger.exception(
            "merge_session_consent: atomic merge failed for user=%s → %s",
            getattr(user, "email", None),
            exc,
        )


# ---------------------------------------------------------------------------
# USER LOGOUT — Clear Session Consent
# ---------------------------------------------------------------------------

@receiver(user_logged_out, dispatch_uid="clear_session_consent_v2")
def clear_session_consent(sender: Any, request, user: Any, **kwargs) -> None:
    """
    On logout, remove transient consent data from the session
    to prevent stale reuse in subsequent logins.
    """
    try:
        session = getattr(request, "session", None)
        if not session:
            logger.debug(
                "clear_session_consent: no session for user=%s", getattr(user, "email", None)
            )
            return

        if "consent_data" in session:
            session.pop("consent_data", None)
            try:
                session.save()
            except Exception as exc:
                logger.debug("clear_session_consent: session.save() failed → %s", exc)
            logger.debug(
                "clear_session_consent: cleared session consent for user=%s",
                getattr(user, "email", None),
            )

    except Exception as exc:
        logger.debug("clear_session_consent: unexpected failure → %s", exc)


--------------------------------------------
### FILE: apps\consent\urls.py
### SIZE: 2262 bytes
### HASH: BA7A90F1B9D17EAB860446B69C8013E23735417C3CBCFAE8C7CEA3F3B0759E71

from __future__ import annotations

from django.urls import path
from . import views
from apps.consent.api import get_consent_status, update_consent

app_name = "consent"

urlpatterns = [
    # ------------------------------------------------------------------
    # Banner loader (HTML partial — HTMX / JS)
    # ------------------------------------------------------------------
    path("banner/", views.banner_partial, name="banner"),

    # ------------------------------------------------------------------
    # Canonical HTML endpoints (UI-driven)
    # ------------------------------------------------------------------
    path("manage/", views.manage_consent, name="manage"),
    path("status/", views.consent_status, name="status"),

    # ------------------------------------------------------------------
    # Consent mutation handlers (HTML/HTMX + JSON fallback)
    # ------------------------------------------------------------------
    path("accept/", views.consent_accept, name="accept"),
    path("accept-all/", views.consent_accept_all, name="accept_all"),
    path("reject-all/", views.consent_reject_all, name="reject_all"),

    # ------------------------------------------------------------------
    # Compatibility aliases for underscore URLs
    # Required because your frontend still calls:
    #   /consent/accept_all/
    #   /consent/reject_all/
    # DO NOT REMOVE
    # ------------------------------------------------------------------
    path("accept_all/", views.consent_accept_all, name="accept_all_u"),
    path("reject_all/", views.consent_reject_all, name="reject_all_u"),

    # ------------------------------------------------------------------
    # Legacy alias: confirmed in frontend JS
    # ------------------------------------------------------------------
    path("save/", views.consent_accept, name="save"),

    # ------------------------------------------------------------------
    # JSON API (Clean, canonical, frontend-safe)
    # apps/consent/api.py
    # ------------------------------------------------------------------
    path("api/status/", get_consent_status, name="api_status"),
    path("api/update/", update_consent, name="api_update"),
]


--------------------------------------------
### FILE: apps\consent\utils.py
### SIZE: 5961 bytes
### HASH: 191ACBD3695A584388D458F49CF6B9A2226CB04EA70013AD49598D5A96BE3C03

"""
apps.consent.utils
==================

Canonical helpers for enterprise-grade consent management.

✔ Safe, unified domain normalization
✔ Canonical cache key generation
✔ Fully serializable active-policy payloads
✔ ORM → cache promotion with TTL
✔ Django 5.2 / Python 3.12 compliant
✔ No silent failures
"""

from __future__ import annotations

import hashlib
import logging
from typing import Optional, Dict, Any

from django.core.cache import cache
from django.contrib.sites.shortcuts import get_current_site

from apps.consent.models import ConsentPolicy

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Defaults
# ---------------------------------------------------------------------------

DEFAULT_TTL_SECONDS = 300


# ---------------------------------------------------------------------------
# Cache Key Helpers
# ---------------------------------------------------------------------------

def consent_cache_key(domain: str) -> str:
    """
    Canonical, collision-resistant cache key for a site's active ConsentPolicy.
    """
    safe = (domain or "default").strip().lower()
    digest = hashlib.sha256(safe.encode("utf-8")).hexdigest()[:12]
    return f"active_consent_policy_{digest}"


# ---------------------------------------------------------------------------
# Domain Resolution
# ---------------------------------------------------------------------------

def resolve_site_domain(request) -> str:
    """
    Resolve domain according to canonical order:

        1) django.contrib.sites
        2) request.get_host()
        3) "default"

    Always normalized to lowercase + stripped.
    """
    try:
        site = get_current_site(request)
        domain = getattr(site, "domain", None) or request.get_host() or "default"
        domain = str(domain).strip().lower()
        return domain or "default"
    except Exception as exc:
        logger.debug("resolve_site_domain fallback → %s", exc)
        return "default"


# ---------------------------------------------------------------------------
# Active Policy Retrieval
# ---------------------------------------------------------------------------

def get_active_policy(domain: str) -> Optional[Dict[str, Any]]:
    """
    Retrieve active ConsentPolicy payload for a given domain.

    Schema returned:
        {
            "version": "v1",
            "categories_snapshot": {...},
            "banner_text": "...",
            "manage_text": "...",
            "is_active": True,
            "site_domain": "example.com",
            "cache_ttl_seconds": 300
        }

    - Never returns ORM objects
    - Cache is authoritative when present
    - Safe under all backends
    - Defensive normalization
    """
    domain = (domain or "default").strip().lower()
    key = consent_cache_key(domain)

    # ----- Cache Read -----
    try:
        cached = cache.get(key)
        if cached is not None:
            return cached
    except Exception as exc:
        logger.debug("get_active_policy: cache.get failed → %s", exc)

    # ----- DB Fallback -----
    try:
        policy = (
            ConsentPolicy.objects.filter(is_active=True, site_domain=domain)
            .only(
                "version",
                "categories_snapshot",
                "banner_text",
                "manage_text",
                "cache_ttl_seconds",
                "is_active",
                "site_domain",
            )
            .order_by("-created_at")
            .first()
        )
    except Exception as exc:
        logger.exception("get_active_policy: DB failure → %s", exc)
        return None

    if not policy:
        return None

    ttl = int(getattr(policy, "cache_ttl_seconds", DEFAULT_TTL_SECONDS) or DEFAULT_TTL_SECONDS)

    payload: Dict[str, Any] = {
        "version": str(policy.version),
        "categories_snapshot": policy.categories_snapshot or {},
        "banner_text": getattr(policy, "banner_text", "") or "",
        "manage_text": getattr(policy, "manage_text", "") or "",
        "is_active": bool(policy.is_active),
        "site_domain": (policy.site_domain or domain).strip().lower(),
        "cache_ttl_seconds": ttl,
    }

    # ----- Cache Write -----
    try:
        cache.set(key, payload, timeout=ttl)
        logger.debug("get_active_policy: cached active policy for domain=%s", domain)
    except Exception as exc:
        logger.debug("get_active_policy: cache.set failed → %s", exc)

    return payload


# ---------------------------------------------------------------------------
# Cache Invalidator
# ---------------------------------------------------------------------------

def invalidate_policy_cache(domain: Optional[str] = None) -> None:
    """
    Invalidate cached active policies:

        domain provided → delete only that domain
        no domain       → wildcard purge if supported

    Never raises.
    """
    # Per-domain invalidate
    if domain:
        key = consent_cache_key((domain or "default").strip().lower())
        try:
            cache.delete(key)
            logger.debug("invalidate_policy_cache: deleted key=%s", key)
        except Exception as exc:
            logger.debug("invalidate_policy_cache: delete failed → %s", exc)
        return

    # Wildcard invalidate (Redis / LocMem, etc.)
    try:
        if hasattr(cache, "delete_pattern"):
            cache.delete_pattern("active_consent_policy_*")
            logger.debug("invalidate_policy_cache: wildcard invalidation performed")
        else:
            logger.debug("invalidate_policy_cache: backend lacks delete_pattern()")
    except Exception as exc:
        logger.debug("invalidate_policy_cache: wildcard failed → %s", exc)


--------------------------------------------
### FILE: apps\consent\views.py
### SIZE: 20101 bytes
### HASH: 6E49C61A043822E7422C44AD025F39B70995A6BE02E320C947E042258904C619

"""
apps.consent.views
==================

Enterprise-grade GDPR / CCPA consent management views.
Hardened, deterministic, free from unsafe fallbacks.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, Optional

from django.conf import settings
from django.contrib import messages
from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.db import transaction
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.middleware.csrf import get_token
from django.shortcuts import redirect, render
from django.template.loader import render_to_string
from django.template.response import TemplateResponse
from django.template import TemplateDoesNotExist
from django.views.decorators.http import require_GET, require_POST

from apps.consent.models import ConsentRecord, ConsentPolicy
from apps.consent.utils import consent_cache_key, get_active_policy, resolve_site_domain

logger = logging.getLogger(__name__)


# ============================================================================
# INTERNAL UTILITIES
# ============================================================================

def hx_response(content: str = "", status: int = 200, triggers: Optional[dict] = None) -> HttpResponse:
    """HTMX-safe response helper with HX-Trigger."""
    resp = HttpResponse(content, status=status)
    if triggers:
        try:
            resp["HX-Trigger"] = json.dumps(triggers)
        except Exception:
            logger.debug("hx_response: HX-Trigger serialization failed")
    return resp


def _is_htmx_or_ajax(request: HttpRequest) -> bool:
    """Detect HTMX or AJAX request."""
    try:
        if request.headers.get("HX-Request"):
            return True
        return request.headers.get("X-Requested-With", "").lower() == "xmlhttprequest"
    except Exception:
        return False


def _parse_json(request: HttpRequest, max_bytes: int = 1_048_576) -> Dict[str, Any]:
    try:
        raw = request.body or b""
        if len(raw) > max_bytes:
            return {"__error__": "payload_too_large"}
        if not raw:
            return {}
        return json.loads(raw.decode("utf-8", errors="ignore"))
    except Exception:
        return {}


def _bool(v: Any) -> bool:
    if isinstance(v, bool):
        return v
    return str(v).strip().lower() in {"1", "true", "yes", "on"}


def _ensure_session(request: HttpRequest) -> Optional[str]:
    """Guarantee a valid session key for anonymous users."""
    try:
        if not getattr(request, "session", None):
            return None
        if not request.session.session_key:
            request.session.create()
        return request.session.session_key
    except Exception:
        return None


def _domain(request: HttpRequest) -> str:
    """Unified domain resolver."""
    try:
        return resolve_site_domain(request) or get_current_site(request).domain or request.get_host()
    except Exception:
        return request.get_host()


def _active_policy(request: HttpRequest) -> Optional[Dict[str, Any]]:
    """Resolve the active policy safely with cache + ORM fallback."""
    try:
        domain = _domain(request)
        key = consent_cache_key(domain)

        cached = cache.get(key)
        if cached is not None:
            return cached

        # helper
        try:
            payload = get_active_policy(domain)
            if payload:
                ttl = int(payload.get("cache_ttl_seconds", getattr(settings, "CONSENT_POLICY_CACHE_TTL", 300)))
                cache.set(key, payload, timeout=ttl)
                return payload
        except Exception:
            pass

        # ORM
        obj = (
            ConsentPolicy.objects.filter(is_active=True, site_domain=domain)
            .order_by("-created_at")
            .first()
        )
        if not obj:
            return None

        payload = {
            "version": str(obj.version or ""),
            "categories_snapshot": obj.categories_snapshot or {},
            "banner_text": obj.banner_text or "",
            "manage_text": obj.manage_text or "",
            "is_active": obj.is_active,
            "site_domain": domain,
            "cache_ttl_seconds": int(getattr(obj, "cache_ttl_seconds",
                                             getattr(settings, "CONSENT_POLICY_CACHE_TTL", 300))),
        }
        cache.set(key, payload, timeout=payload["cache_ttl_seconds"])
        return payload

    except Exception as exc:
        logger.exception("_active_policy failed -> %s", exc)
        return None


# ============================================================================
# BANNER
# ============================================================================

@require_GET
def banner_partial(request: HttpRequest) -> HttpResponse:
    """Render banner safely with multi-template fallback."""
    try:
        policy = _active_policy(request)
        if not policy:
            return HttpResponse("", content_type="text/html")

        # If user accepted everything earlier
        if getattr(request, "session", None) and request.session.get("consent_all_accepted"):
            return HttpResponse("", content_type="text/html")

        snapshot = policy.get("categories_snapshot", {}) or {}

        # Build categories
        categories = {
            slug: {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "required": bool(meta.get("required")),
                "accepted": bool(meta.get("required") or meta.get("default", False)),
            }
            for slug, meta in snapshot.items()
        }

        # Fallback (minimal required cookie)
        if not categories:
            categories = {
                "functional": {"name": "Functional", "required": True, "accepted": True}
            }

        ctx = {
            "consent_active": True,
            "consent_version": policy.get("version", ""),
            "consent_text": policy.get("banner_text", ""),
            "consent_categories": categories,
            "csrf_token": get_token(request),
        }

        for tpl in [
            "consent/includes/banner.html",
            "includes/banner.html",
            "consent/banner.html",
        ]:
            try:
                return TemplateResponse(request, tpl, ctx)
            except TemplateDoesNotExist:
                continue
            except Exception as exc:
                logger.exception("banner render error -> %s", exc)
                return HttpResponse("", content_type="text/html")

        return HttpResponse("", content_type="text/html")

    except Exception as exc:
        logger.exception("banner_partial failed -> %s", exc)
        return HttpResponse("", content_type="text/html")


# ============================================================================
# CONSENT MANAGEMENT PAGE
# ============================================================================

@require_GET
def manage_consent(request: HttpRequest) -> HttpResponse:
    try:
        policy = _active_policy(request)
        snapshot = (policy or {}).get("categories_snapshot", {}) or {}

        categories = [
            {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "slug": slug,
                "description": meta.get("description", ""),
                "required": bool(meta.get("required")),
                "accepted": bool(meta.get("required") or meta.get("default", False)),
            }
            for slug, meta in snapshot.items()
        ]

        if not categories:
            categories = [
                {"name": "Functional", "slug": "functional", "required": True, "accepted": True},
                {"name": "Analytics", "slug": "analytics", "required": False, "accepted": False},
            ]

        return render(
            request,
            "site_settings/consent_manage.html",
            {
                "consent_active": bool(policy),
                "consent_version": (policy or {}).get("version", ""),
                "consent_text": (policy or {}).get("manage_text", ""),
                "categories": categories,
            },
        )

    except Exception as exc:
        logger.exception("manage_consent failed -> %s", exc)
        return render(request, "site_settings/consent_manage.html", {"categories": []})


# ============================================================================
# STATUS ENDPOINT (HTML/JS)
# ============================================================================

@require_GET
def consent_status(request: HttpRequest) -> JsonResponse:
    """HTML/JS-safe status endpoint (NOT the API version)."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=404)

        snapshot = policy.get("categories_snapshot", {}) or {}

        categories = {
            slug: {
                "name": meta.get("name", slug.replace("_", " ").title()),
                "required": bool(meta.get("required")),
                "default": bool(meta.get("default")),
                "accepted": bool(meta.get("required")),
            }
            for slug, meta in snapshot.items()
        }

        # Ensure functional
        categories.setdefault(
            "functional",
            {"name": "Functional", "required": True, "default": True, "accepted": True},
        )

        domain = _domain(request)

        # Load previous record
        rec = None
        try:
            if request.user.is_authenticated:
                rec = ConsentRecord.objects.filter(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                ).first()
            else:
                sk = _ensure_session(request)
                if sk:
                    rec = ConsentRecord.objects.filter(
                        session_key=sk,
                        policy_version=policy["version"],
                        site_domain=domain,
                    ).first()
        except Exception:
            rec = None

        if rec and rec.accepted_categories:
            for slug, val in rec.accepted_categories.items():
                if slug in categories and not categories[slug]["required"]:
                    categories[slug]["accepted"] = bool(val)

        return JsonResponse(
            {
                "consent_active": True,
                "consent_version": policy["version"],
                "categories": categories,
                "site_domain": domain,
            },
            json_dumps_params={"indent": 2},
        )

    except Exception as exc:
        logger.exception("consent_status failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


# ============================================================================
# MUTATION HANDLERS
# ============================================================================

@require_POST
def consent_accept(request: HttpRequest) -> HttpResponse:
    """
    Save granular accept / accept_all / reject_all preferences.
    Unified deterministic handler.
    """
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"ok": False, "error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        # JSON or form
        if "json" in (request.content_type or "").lower():
            data = _parse_json(request)
            if data.get("__error__") == "payload_too_large":
                return JsonResponse({"error": "payload_too_large"}, status=413)
        else:
            data = request.POST.copy()

        reject_all = _bool(data.get("reject_all"))
        accept_all = _bool(data.get("accept_all"))

        # Build acceptance map
        if reject_all:
            accepted = {slug: False for slug in valid_slugs}
            accepted["functional"] = True
            for slug, meta in snapshot.items():
                if meta.get("required"):
                    accepted[slug] = True

        elif accept_all:
            accepted = {slug: True for slug in valid_slugs}

        else:
            accepted = {
                slug: True
                if slug == "functional" or snapshot.get(slug, {}).get("required")
                else _bool(data.get(slug))
                for slug in valid_slugs
            }

        sanitized = {slug: bool(v) for slug, v in accepted.items()}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {"accepted_categories": sanitized, "site_domain": domain, "session_key": sk}

        # Save record
        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        # Session flags
        try:
            if getattr(request, "session", None):
                non_required = [v for k, v in sanitized.items() if k != "functional"]
                request.session["consent_all_accepted"] = all(non_required) if non_required else True
                request.session["consent_rejected"] = not any(non_required) if non_required else False
                request.session.modified = True
        except Exception:
            pass

        msg = (
            "You have rejected all optional cookies."
            if reject_all else
            "You have accepted all optional cookies."
            if accept_all else
            "Your preferences have been saved."
        )

        # JSON response
        if "json" in (request.content_type or "").lower() and _is_htmx_or_ajax(request):
            return JsonResponse(
                {
                    "ok": True,
                    "message": msg,
                    "consent": sanitized,
                    "hx_trigger": {"showToast": {"html": msg}},
                },
                json_dumps_params={"indent": 2},
            )

        # HTMX
        if _is_htmx_or_ajax(request):
            toast_html = render_to_string("partials/toast_fragment.html", {"message": msg})
            return hx_response("", triggers={"removeConsentBanner": True, "showToast": {"html": toast_html}})

        messages.success(request, msg)
        return redirect(data.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_accept failed -> %s", exc)
        if _is_htmx_or_ajax(request):
            return JsonResponse({"ok": False, "error": "internal_error"}, status=500)
        messages.error(request, "Unexpected error while saving preferences.")
        return redirect("/")


@require_POST
def consent_accept_all(request: HttpRequest) -> HttpResponse:
    """Accept all optional categories."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        sanitized = {slug: True for slug in valid_slugs}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {"accepted_categories": sanitized, "site_domain": domain, "session_key": sk}

        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        try:
            if getattr(request, "session", None):
                request.session["consent_all_accepted"] = True
                request.session["consent_rejected"] = False
                request.session.modified = True
        except Exception:
            pass

        msg = "You have accepted all optional cookies."

        if _is_htmx_or_ajax(request):
            toast_html = render_to_string("partials/toast_fragment.html", {"message": msg})
            return hx_response("", triggers={"removeConsentBanner": True, "showToast": {"html": toast_html}})

        messages.success(request, msg)
        return redirect(request.POST.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_accept_all failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


@require_POST
def consent_reject_all(request: HttpRequest) -> HttpResponse:
    """Reject all optional categories."""
    try:
        policy = _active_policy(request)
        if not policy:
            return JsonResponse({"error": "no_active_policy"}, status=400)

        snapshot = policy.get("categories_snapshot", {}) or {}
        valid_slugs = set(snapshot.keys()) | {"functional"}

        accepted = {slug: False for slug in valid_slugs}
        accepted["functional"] = True

        for slug, meta in snapshot.items():
            if meta.get("required"):
                accepted[slug] = True

        sanitized = {k: bool(v) for k, v in accepted.items()}

        sk = _ensure_session(request)
        domain = _domain(request)

        defaults = {"accepted_categories": sanitized, "site_domain": domain, "session_key": sk}

        with transaction.atomic():
            if request.user.is_authenticated:
                ConsentRecord.objects.update_or_create(
                    user=request.user,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )
            else:
                ConsentRecord.objects.update_or_create(
                    session_key=sk,
                    policy_version=policy["version"],
                    site_domain=domain,
                    defaults=defaults,
                )

        try:
            if getattr(request, "session", None):
                request.session["consent_all_accepted"] = False
                request.session["consent_rejected"] = True
                request.session.modified = True
        except Exception:
            pass

        msg = "You rejected optional cookies."

        if _is_htmx_or_ajax(request):
            toast_html = render_to_string("partials/toast_fragment.html", {"message": msg})
            return hx_response("", triggers={"removeConsentBanner": True, "showToast": {"html": toast_html}})

        messages.success(request, msg)
        return redirect(request.POST.get("next") or "/")

    except Exception as exc:
        logger.exception("consent_reject_all failed -> %s", exc)
        return JsonResponse({"error": "internal_error"}, status=500)


--------------------------------------------
### FILE: apps\core\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\core\admin.py
### SIZE: 7043 bytes
### HASH: 84132BC9827EF366AD72BBA6C2B25274A5B8C2AF910177838E449CF215550A88

"""
admin.py
--------
Enterprise-ready admin bootstrap for the app.

Features:
- Admin site branding (centralized)
- Safe JSON/CSV export admin action helper
- Automatic registration of unregistered models with a default ModelAdmin
- Clear defaults for list_display/search_fields to avoid heavy table scans
- No deprecated APIs (Django 5.2+ compatible)
"""

from __future__ import annotations

import json
import logging
from typing import Iterable

from django import forms
from django.contrib import admin
from django.db import models
from django.http import HttpResponse
from django.utils.encoding import smart_str
from django.utils.text import capfirst
from django.core.exceptions import ImproperlyConfigured

logger = logging.getLogger(__name__)

# ---------------------------
# Admin site branding (change as needed)
# ---------------------------
admin.site.site_header = "GSMInfinity Administration"
admin.site.site_title = "GSM Admin"
admin.site.index_title = "System Administration"

# ---------------------------
# Utility admin actions
# ---------------------------
def export_as_json_action(description: str = "Export selected objects as JSON"):
    """
    Returns an admin action that exports selected queryset to JSON.
    Usage:
        actions = [export_as_json_action("Export selected users as JSON")]
    """
    def action(modeladmin, request, queryset):
        model = modeladmin.model
        # Use values() to avoid serializing complex relations; admins can override for custom output
        try:
            fields = [f.name for f in model._meta.concrete_fields]
        except Exception:
            fields = None

        data = list(queryset.values(*fields)) if fields else list(queryset.values())
        resp = HttpResponse(
            json.dumps(data, ensure_ascii=False, indent=2),
            content_type="application/json; charset=utf-8",
        )
        resp["Content-Disposition"] = f'attachment; filename={model._meta.model_name}_export.json'
        return resp

    action.short_description = description
    return action

def export_as_csv_action(description: str = "Export selected objects as CSV"):
    """
    Returns an admin action that exports selected queryset to CSV.
    Basic, safe implementation — override in specific ModelAdmin for customized exports.
    """
    def action(modeladmin, request, queryset):
        import csv

        model = modeladmin.model
        try:
            fields = [f.name for f in model._meta.concrete_fields]
        except Exception:
            fields = None

        response = HttpResponse(content_type="text/csv; charset=utf-8")
        response["Content-Disposition"] = f'attachment; filename={model._meta.model_name}_export.csv'
        response.write("\ufeff")  # UTF-8 BOM for Excel

        writer = csv.writer(response)
        if fields:
            writer.writerow([smart_str(capfirst(f)) for f in fields])
            for obj in queryset.values_list(*fields):
                writer.writerow([smart_str(v) for v in obj])
        else:
            # fallback to keys of values()
            first = queryset.values().first()
            if not first:
                return response
            keys = list(first.keys())
            writer.writerow([smart_str(capfirst(k)) for k in keys])
            for obj in queryset.values(*keys):
                writer.writerow([smart_str(obj.get(k, "")) for k in keys])

        return response

    action.short_description = description
    return action


# ---------------------------
# Default ModelAdmin used for auto-registration
# ---------------------------
class DefaultModelAdmin(admin.ModelAdmin):
    """
    Sensible defaults for auto-registered models:
    - show first 6 concrete fields in list_display
    - search on TextField/CharField if present (first 3)
    - readonly auto timestamp fields if present
    - includes JSON/CSV export actions
    """
    actions = [
        export_as_json_action(),
        export_as_csv_action(),
    ]

    def __init__(self, model, admin_site):
        # attempt to build light-weight list_display and search_fields to avoid heavy DB scans
        try:
            concrete_fields = [f for f in model._meta.concrete_fields if not isinstance(f, models.ManyToManyField)]
            # prefer id/email/username/date fields if present
            preferred = []
            for name in ("email", "username", "name", "title", "id", "created_at", "created", "date_joined"):
                if any(f.name == name for f in concrete_fields):
                    preferred.append(name)
            # fallback to first N concrete fields
            fallback = [f.name for f in concrete_fields][:6]
            list_display = preferred + [f for f in fallback if f not in preferred]
            self.list_display = tuple(list_display) if list_display else ("__str__",)
            # search on first few textual fields
            text_fields = [f.name for f in concrete_fields if isinstance(f, (models.CharField, models.TextField))][:3]
            self.search_fields = tuple(text_fields) if text_fields else ()
            # readonly timestamp-like fields
            ro = [f.name for f in concrete_fields if f.name in ("created_at", "updated_at", "date_joined", "created")]
            self.readonly_fields = tuple(ro)
        except Exception as exc:
            logger.debug("DefaultModelAdmin init fallback: %s", exc)
        super().__init__(model, admin_site)


# ---------------------------
# Auto-register any models from this app that are not already registered
# ---------------------------
def auto_register_models(app_label: str):
    """
    Automatically register models belonging to `app_label` that are not yet registered.
    Use with caution — it's convenient during development and safe in production because
    ModelAdmin defaults are conservative.
    """
    from django.apps import apps as django_apps
    try:
        app_config = django_apps.get_app_config(app_label)
    except LookupError as exc:
        raise ImproperlyConfigured(f"Cannot auto-register models: unknown app_label '{app_label}'") from exc

    for model in app_config.get_models():
        model_name = model._meta.model_name
        if model in admin.site._registry:
            continue
        try:
            admin.site.register(model, DefaultModelAdmin)
            logger.info("Auto-registered model %s.%s in admin", app_label, model_name)
        except admin.sites.AlreadyRegistered:
            continue
        except Exception as exc:
            logger.exception("Failed to auto-register %s.%s : %s", app_label, model_name, exc)

# ---------------------------
# If you want automatic registration for the current app, un-comment and set the app label:
# e.g. for apps.core use app_label = "apps.core"
# ---------------------------
# auto_register_models("apps.core")


--------------------------------------------
### FILE: apps\core\apps.py
### SIZE: 726 bytes
### HASH: EBA74343F78CA3EFF460446B7CA66F4FDEAB6F7D808B78332E0B8FF927AEFE61

from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.core"
    label = "core"
    verbose_name = "Core"

    def ready(self):
        """
        Core app initialization:
        - Safely clear the django.contrib.sites cache after registry load
        - Autodiscover signals or other startup modules
        """
        try:
            from django.contrib.sites.models import Site
            Site.objects.clear_cache()
        except Exception:
            pass

        # Auto-discover signals.py in submodules
        autodiscover_modules("signals")


--------------------------------------------
### FILE: apps\core\cache.py
### SIZE: 8065 bytes
### HASH: 21BF4694793725DD59F53E06202390A0A9EF5B5F818E0A6F285F608DD6065DDE

"""
apps.core.cache
===============

Enterprise-grade centralized cache utilities.

✔ Django 5.2+ / Python 3.12+
✔ Redis / LocMem / cluster cache compatible
✔ Multi-tenant safe: stable digested keys, namespace isolation
✔ Strict key normalization to prevent collisions
✔ Defensive invalidators (site + consent)
✔ Atomic get/set with fallback
"""

from __future__ import annotations

import hashlib
import logging
from typing import Any, Callable, Optional, TypeVar

from django.core.cache import cache
from django.contrib.sites.models import Site

logger = logging.getLogger(__name__)

_T = TypeVar("_T")

# =====================================================================
# KEY UTILITIES
# =====================================================================

def _namespaced_key(
    key: str,
    *,
    version: Optional[int] = None,
    namespace: Optional[str] = None,
) -> str:
    """
    Portable canonical key format.

    Example:
        _namespaced_key("user_session", version=3, namespace="auth")
        → "auth::user_session::v3"
    """
    key = (key or "").strip()
    ns = (namespace or "").strip()

    parts: list[str] = []
    if ns:
        parts.append(ns)
    parts.append(key)
    if version is not None:
        parts.append(f"v{int(version)}")
    return "::".join(parts)


def _digest_key(base: str) -> str:
    """
    Safe digest for long/unsafe keys (Redis + memcached-safe)
    Ensures namespacing cannot collide.
    """
    base = base.replace(" ", "").strip()
    digest = hashlib.sha256(base.encode("utf-8")).hexdigest()[:16]
    return f"{base[:32]}::{digest}"


# =====================================================================
# DISTRIBUTED CACHE MANAGER
# =====================================================================

class DistributedCacheManager:
    """
    High-reliability cache manager for multi-site deployments.
    All operations are fully defensive (never crash).
    """

    # ------------------------------------------------------------------
    # Pattern deletes (Redis-only or custom backends)
    # ------------------------------------------------------------------
    @staticmethod
    def safe_delete_pattern(pattern: str) -> None:
        """
        Delete keys matching pattern (if backend supports it).
        """
        try:
            if hasattr(cache, "delete_pattern"):
                cache.delete_pattern(pattern)
                logger.debug("Pattern delete: %s", pattern)
            else:
                logger.debug("Backend lacks delete_pattern (pattern=%s)", pattern)
        except Exception as exc:
            logger.debug("delete_pattern failed (%s → %s)", pattern, exc)

    # ------------------------------------------------------------------
    # SITE SETTINGS INVALIDATION
    # ------------------------------------------------------------------
    @staticmethod
    def invalidate_site_settings(site_id: Optional[int] = None) -> None:
        """
        Invalidate all cache entries for site settings.

        This implementation is fully aligned with:
        - context processor key scheme
        - multi-tenant domain hashing
        """
        try:
            # Remove legacy global key
            try:
                cache.delete("active_site_settings")
            except Exception:
                pass

            # Remove new hashed-domain keys (pattern)
            DistributedCacheManager.safe_delete_pattern("active_site_settings_*")

            # Remove site-specific numeric key
            if site_id is not None:
                try:
                    cache.delete(f"site_settings_{site_id}")
                except Exception:
                    pass

            # Defensive enumeration (non-fatal)
            try:
                for s in Site.objects.only("id"):
                    try:
                        cache.delete(f"site_settings_{s.id}")
                    except Exception:
                        pass
            except Exception:
                pass

            logger.info("Site settings cache invalidated (site_id=%s)", site_id)

        except Exception as exc:
            logger.error("invalidate_site_settings failed → %s", exc)

    # ------------------------------------------------------------------
    # CONSENT POLICY INVALIDATION
    # ------------------------------------------------------------------
    @staticmethod
    def invalidate_consent_policy(site_identifier: Optional[str] = None) -> None:
        """
        Invalidate consent policy caches with full pattern-safe cleanup.
        """
        try:
            ident = (site_identifier or "global").strip().lower()
            digest_key = _digest_key(f"active_consent_policy::{ident}")

            # exact delete
            try:
                cache.delete(digest_key)
            except Exception:
                pass

            # legacy
            try:
                cache.delete("active_consent_policy")
            except Exception:
                pass

            # pattern cleanup
            DistributedCacheManager.safe_delete_pattern("active_consent_policy_*")

            logger.info("ConsentPolicy cache invalidated (identifier=%s)", ident)

        except Exception as exc:
            logger.error("invalidate_consent_policy failed → %s", exc)

    # ------------------------------------------------------------------
    # ATOMIC GET / SET WITH FALLBACK
    # ------------------------------------------------------------------
    @staticmethod
    def get_with_coherence(
        key: str,
        fallback_func: Callable[[], _T],
        *,
        timeout: int = 300,
        version: Optional[int] = None,
        namespace: Optional[str] = None,
    ) -> Optional[_T]:
        """
        Atomic get-or-compute with digest-safe keys.

        • Uses get_or_set when available (atomic)
        • Falls back to manual get → compute → set
        • Never raises exceptions
        """
        try:
            namespaced = _namespaced_key(key, version=version, namespace=namespace)
            cache_key = _digest_key(namespaced)

            # Preferred atomic path
            if hasattr(cache, "get_or_set"):
                try:
                    val = cache.get_or_set(cache_key, fallback_func, timeout=timeout)
                    logger.debug("get_or_set OK (%s)", cache_key)
                    return val
                except Exception:
                    logger.debug("get_or_set failed → manual fallback")

            # Manual path
            try:
                existing = cache.get(cache_key)
                if existing is not None:
                    logger.debug("Cache HIT (%s)", cache_key)
                    return existing
            except Exception:
                logger.debug("Cache.get failed for %s", cache_key)

            logger.debug("Cache MISS (%s) — computing fallback", cache_key)
            val = fallback_func()

            # Race-safe: try add() before set()
            try:
                added = False
                if hasattr(cache, "add"):
                    added = cache.add(cache_key, val, timeout=timeout)
                if not added:
                    cache.set(cache_key, val, timeout=timeout)
                logger.debug("Stored (%s, added=%s)", cache_key, added)
            except Exception:
                logger.debug("Cache set/add failed (%s)", cache_key)

            return val

        except Exception as exc:
            logger.warning("Cache coherence failure (%s)", exc)
            try:
                return fallback_func()
            except Exception as inner:
                logger.error("Fallback compute failed → %s", inner)
                return None


# Legacy alias for compatibility
CacheManager = DistributedCacheManager


--------------------------------------------
### FILE: apps\core\context_processors.py
### SIZE: 9232 bytes
### HASH: 13844D473052A60137D7D4249E593B96519CC05BAC17EAB163899F996958F59E

"""
apps.core.context_processors
----------------------------
Enterprise-grade context processors.

Goals:
 - Lazy imports for startup/migration safety
 - Fully defensive (never break template rendering)
 - Zero branding (generic defaults)
 - Works seamlessly with new site_settings context processor
 - Hardened region detection + provider resolution
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

from django.conf import settings
from django.http import HttpRequest

logger = logging.getLogger(__name__)


# =====================================================================
# SITE SETTINGS (LIGHT SNAPSHOT)
# =====================================================================
def site_settings_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Lightweight supplemental settings for templates.
    NOTE:
        Full site settings come from the main context processor:
        → apps.site_settings.context_processor.site_settings
    This function ONLY adds small frequently-used fields and never duplicates logic.
    """

    # Safe, lazy lookup — never fatal
    try:
        from apps.site_settings.models import SiteSettings  # type: ignore
        try:
            s = SiteSettings.get_solo() if hasattr(SiteSettings, "get_solo") else SiteSettings.objects.first()
        except Exception as exc:
            logger.debug("SiteSettings lookup failure: %s", exc)
            s = None
    except Exception:
        s = None

    return {
        "site_theme": {
            "primary_color": getattr(s, "primary_color", "#0d6efd"),
            "secondary_color": getattr(s, "secondary_color", "#6c757d"),
        },
        "site_settings_light": {
            "site_name": getattr(s, "site_name", "Site"),  # no branding
            "enable_signup": bool(getattr(s, "enable_signup", True)),
            "recaptcha_site_key": getattr(s, "recaptcha_public_key", "") or "",
            "show_consent_banner": bool(getattr(s, "enable_notifications", False)),
        },
    }


# =====================================================================
# SOCIAL PROVIDER SELECTION (LOCATION AWARE)
# =====================================================================
def location_based_providers(request: HttpRequest) -> Dict[str, Any]:
    """
    Returns providers suggested for the user's region, filtered by site's enabled providers.

    Output:
        {
            "location_based_providers": [...],
            "user_region": "...",
            "all_enabled_providers": [...],
        }
    """
    enabled_providers: List[str] = []

    # -----------------------------------------------------------------------------
    # Lazy import allauth only if installed
    # -----------------------------------------------------------------------------
    try:
        from allauth.socialaccount.models import SocialApp  # type: ignore
        from django.contrib.sites.models import Site  # type: ignore

        try:
            current_site = Site.objects.get_current()
        except Exception as exc:
            logger.debug("Site.get_current() failed: %s", exc)
            current_site = None

        try:
            if current_site:
                enabled_providers = list(
                    SocialApp.objects.filter(sites=current_site).values_list("provider", flat=True)
                )
            else:
                enabled_providers = list(SocialApp.objects.values_list("provider", flat=True))
        except Exception as exc:
            logger.debug("SocialApp query failed: %s", exc)
            enabled_providers = []

    except Exception:
        # If allauth not installed → gracefully degrade
        enabled_providers = []

    # -----------------------------------------------------------------------------
    # Region detection
    # -----------------------------------------------------------------------------
    try:
        user_region = detect_user_region(request)
    except Exception as exc:
        logger.debug("detect_user_region failed: %s", exc)
        user_region = "global"

    # -----------------------------------------------------------------------------
    # Region → provider mapping
    # -----------------------------------------------------------------------------
    region_map = getattr(settings, "LOCATION_BASED_PROVIDERS", {}) or {}
    preferred_list = region_map.get(user_region, []) or []

    if not preferred_list:
        preferred_list = getattr(settings, "DEFAULT_SOCIAL_PROVIDERS", ["google"])

    # filter down to those enabled on the site
    try:
        available = [p for p in preferred_list if p in enabled_providers] if enabled_providers else preferred_list
    except Exception:
        available = preferred_list

    return {
        "location_based_providers": available,
        "user_region": user_region,
        "all_enabled_providers": enabled_providers,
    }


# =====================================================================
# REGION DETECTION
# =====================================================================
def detect_user_region(request: HttpRequest) -> str:
    """
    Hierarchical region detection:
        1) user preference (if authenticated)
        2) GeoIP (if available)
        3) Accept-Language header
        4) fallback = "global"
    """

    try:
        user = getattr(request, "user", None)
        if getattr(user, "is_authenticated", False):
            pref = getattr(user, "preferred_region", None)
            if pref:
                return str(pref)
    except Exception:
        pass

    try:
        geo_region = _detect_region_via_geoip(request)
        if geo_region:
            return geo_region
    except Exception:
        pass

    try:
        lang_region = _detect_region_via_language(request)
        if lang_region:
            return lang_region
    except Exception:
        pass

    return "global"


# =====================================================================
# GEOIP REGION
# =====================================================================
def _detect_region_via_geoip(request: HttpRequest) -> Optional[str]:
    try:
        geoip_path = getattr(settings, "GEOIP_PATH", None)
        if not geoip_path:
            return None

        try:
            from django.contrib.gis.geoip2 import GeoIP2  # type: ignore
        except Exception as exc:
            logger.debug("GeoIP2 unavailable: %s", exc)
            return None

        ip = _get_client_ip(request)
        if not ip or ip == "127.0.0.1":
            return None

        try:
            g = GeoIP2()
            country = g.country_code(ip)
        except Exception as exc:
            logger.debug("GeoIP failure for %s: %s", ip, exc)
            return None

        region_map = getattr(settings, "COUNTRY_TO_REGION_MAP", None) or {}
        return region_map.get(country, None)

    except Exception as exc:
        logger.debug("_detect_region_via_geoip unexpected error: %s", exc)
        return None


# =====================================================================
# LANGUAGE REGION
# =====================================================================
def _detect_region_via_language(request: HttpRequest) -> Optional[str]:
    try:
        header = request.META.get("HTTP_ACCEPT_LANGUAGE", "") or ""
        if not header:
            return None

        primary = header.split(",")[0].split("-")[0].lower()

        mapping = getattr(settings, "LANGUAGE_TO_REGION_MAP", None) or {
            "en": "global",
            "ar": "middle_east",
            "zh": "china",
            "ja": "asia",
            "ko": "asia",
            "ru": "russia",
            "de": "europe",
            "fr": "europe",
            "es": "europe",
            "it": "europe",
        }

        return mapping.get(primary, "global")

    except Exception as exc:
        logger.debug("_detect_region_via_language failed: %s", exc)
        return None


# =====================================================================
# IP EXTRACTION
# =====================================================================
def _get_client_ip(request: HttpRequest) -> str:
    try:
        fwd = request.META.get("HTTP_X_FORWARDED_FOR")
        if fwd:
            return fwd.split(",")[0].strip()

        return request.META.get("REMOTE_ADDR", "127.0.0.1") or "127.0.0.1"
    except Exception:
        return "127.0.0.1"


# =====================================================================
# CORE CONTEXT
# =====================================================================
def core_context(request: HttpRequest) -> Dict[str, Any]:
    """
    Small, safe global flags for templates.
    """
    return {
        "DEBUG": getattr(settings, "DEBUG", False),
        "ENV": getattr(settings, "ENV", "production"),
        "SITE_ID": getattr(settings, "SITE_ID", 1),
        "TIME_ZONE": getattr(settings, "TIME_ZONE", "UTC"),
    }


--------------------------------------------
### FILE: apps\core\exceptions.py
### SIZE: 6739 bytes
### HASH: 22E9EBEF8AF6FE0470FA5B9C8FEFC456F2056912D38A9BC299DAF604AFF18669

"""
apps.core.exceptions
====================

Enterprise-grade unified exception handling.

✓ Django 5.2 / Python 3.12+
✓ Async-safe, JSON + HTML aware
✓ Hardened against info disclosure
✓ DRF-compatible (wired via REST_FRAMEWORK.EXCEPTION_HANDLER)
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from django.conf import settings
from django.core.exceptions import (
    PermissionDenied,
    ValidationError,
    ObjectDoesNotExist,
)
from django.http import (
    HttpRequest,
    HttpResponse,
    JsonResponse,
)
from django.utils.translation import gettext_lazy as _

# -------------------------------------------------------------
# Optional DRF imports — explicit, safe, no broad try/except
# -------------------------------------------------------------
AuthenticationFailed = None
APIException = None

try:
    from rest_framework.exceptions import AuthenticationFailed as _AuthFailed
    from rest_framework.exceptions import APIException as _APIException
    AuthenticationFailed = _AuthFailed
    APIException = _APIException
except ImportError:
    # DRF not installed — these remain None (safe)
    pass

log = logging.getLogger(__name__)


# ============================================================
#  Utility helpers
# ============================================================
def _is_json_request(request: Optional[HttpRequest]) -> bool:
    """Detect JSON or AJAX requests for correct response type."""
    if not request:
        return False

    content_type = (request.content_type or "").lower()

    return (
        request.headers.get("x-requested-with") == "XMLHttpRequest"
        or content_type.startswith("application/json")
        or content_type.endswith("+json")
    )


def json_error_response(
    exc: Exception,
    code: int = 500,
    request: Optional[HttpRequest] = None,
) -> JsonResponse:
    """
    Hardened JSON error response.
    Internal exception details are hidden when DEBUG=False.
    """
    message = str(exc) if settings.DEBUG else _("Internal server error")

    return JsonResponse(
        {
            "ok": False,
            "error": message,
            "type": exc.__class__.__name__,
            "status": code,
        },
        status=code,
        json_dumps_params={"ensure_ascii": False},
    )


# ============================================================
#  Django / DRF unified exception handler
# ============================================================
class EnterpriseExceptionHandler:
    """
    Centralized handler for Django + DRF errors.

    Enable using:

        REST_FRAMEWORK = {
            "EXCEPTION_HANDLER": "apps.core.exceptions.EnterpriseExceptionHandler.handle_api_exception"
        }
    """

    @staticmethod
    def handle_api_exception(
        exc: Exception,
        context: Optional[dict[str, Any]] = None,
    ) -> JsonResponse:
        request = context.get("request") if context else None
        status_code: int
        response_data: dict[str, Any]

        # ------------------------------------------
        # Authentication / Permissions
        # ------------------------------------------
        if isinstance(exc, (PermissionDenied, AuthenticationFailed)):
            status_code = 401
            response_data = {
                "ok": False,
                "error": "authentication_failed",
                "message": _("Invalid credentials or insufficient permissions."),
            }

        # ------------------------------------------
        # Validation
        # ------------------------------------------
        elif isinstance(exc, ValidationError):
            status_code = 400
            details = getattr(exc, "message_dict", None) or str(exc)
            response_data = {
                "ok": False,
                "error": "validation_failed",
                "details": details,
            }

        # ------------------------------------------
        # Missing objects
        # ------------------------------------------
        elif isinstance(exc, ObjectDoesNotExist):
            status_code = 404
            response_data = {
                "ok": False,
                "error": "not_found",
                "message": _("Requested resource was not found."),
            }

        # ------------------------------------------
        # DRF base exceptions (ParseError, NotAuthenticated, etc.)
        # ------------------------------------------
        elif APIException and isinstance(exc, APIException):
            status_code = getattr(exc, "status_code", 500)
            response_data = {
                "ok": False,
                "error": getattr(exc, "default_code", "api_exception"),
                "message": str(getattr(exc, "detail", exc)),
            }

        # ------------------------------------------
        # Unhandled error (safe fallback)
        # ------------------------------------------
        else:
            log.exception("Unhandled exception occurred", exc_info=True)
            status_code = 500
            response_data = {
                "ok": False,
                "error": "internal_error",
                "message": (
                    f"{exc.__class__.__name__}: {exc}"
                    if settings.DEBUG
                    else _("An unexpected error occurred.")
                ),
            }

        return JsonResponse(
            response_data,
            status=status_code,
            json_dumps_params={
                "ensure_ascii": False,
                "indent": 2 if settings.DEBUG else None,
            },
        )


# ============================================================
#  Synchronous Django view fallback (non-DRF)
# ============================================================
def handle_view_exception(
    request: HttpRequest,
    exc: Exception,
    code: int = 500,
) -> HttpResponse:
    """
    Generic handler for standard Django views.
    Returns JSON for AJAX/JSON requests; otherwise text/plain.
    """
    # Only include traceback info when DEBUG=True (safe)
    log.warning("View exception caught: %s", exc, exc_info=settings.DEBUG)

    if _is_json_request(request):
        return json_error_response(exc, code=code, request=request)

    message = (
        f"{exc.__class__.__name__}: {exc}"
        if settings.DEBUG
        else _("Internal server error")
    )

    return HttpResponse(
        message,
        status=code,
        content_type="text/plain; charset=utf-8",
    )


--------------------------------------------
### FILE: apps\core\middleware\rate_limit_bridge.py
### SIZE: 1523 bytes
### HASH: 9B471D73C5C4A0E3F26172953FA367BF1CF5984EE14FC88B1173AEC977E61E79

"""
apps.core.middleware.rate_limit_bridge
--------------------------------------
Bridges Django requests to apps.users.services.rate_limit.allow_action().
Prevents brute-force login/signup attempts globally.
"""

import logging
from django.http import JsonResponse
from apps.users.services import rate_limit

logger = logging.getLogger(__name__)


class RateLimitMiddleware:
    """Attach global rate limit for login/signup endpoints."""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        path = request.path.lower()

        if "login" in path or "signup" in path:
            client_ip = self._get_client_ip(request)
            key = f"auth:{client_ip}:{path}"

            # 10 attempts / 5 minutes window
            allowed = rate_limit.allow_action(key, max_attempts=10, window_seconds=300)
            if not allowed:
                logger.warning(f"Rate limit exceeded for {client_ip} at {path}")
                return JsonResponse(
                    {
                        "error": "Too many attempts. Please wait a few minutes before retrying."
                    },
                    status=429,
                )

        return self.get_response(request)

    @staticmethod
    def _get_client_ip(request):
        xff = request.META.get("HTTP_X_FORWARDED_FOR")
        if xff:
            return xff.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "unknown")


--------------------------------------------
### FILE: apps\core\middleware\request_meta.py
### SIZE: 3190 bytes
### HASH: 2DCB111B2B5B029C7181F90D1CD80CE42E09E3A3EDDBA2FD521C4BE6E3B33EB0

"""
apps.core.middleware.request_meta
---------------------------------
Enterprise-grade request metadata middleware for GSMInfinity.

✅ Fully compatible with Django ≥ 5.2
✅ Async + sync safe (MiddlewareMixin)
✅ No deprecated APIs
✅ Captures site, client IP, and user agent with fallbacks
✅ Normalizes headers for proxies/load balancers (X-Forwarded-For)
✅ Adds request.origin and request.scheme_normalized helpers
"""

import logging
from django.utils.deprecation import MiddlewareMixin
from django.contrib.sites.shortcuts import get_current_site
from django.http import HttpRequest

logger = logging.getLogger(__name__)


class RequestMetaMiddleware(MiddlewareMixin):
    """
    Attach normalized request metadata to every request safely.
    Ensures consistent access to site name/domain, client IP, and headers.
    """

    def process_request(self, request: HttpRequest) -> None:
        """
        Populate request attributes:
          • site_domain / site_name (from django.contrib.sites)
          • client_ip (honoring proxy headers)
          • user_agent
          • origin (for CORS/security logging)
          • scheme_normalized ("http"/"https")
        """

        # --------------------------------------------------------
        # Site resolution with safe fallback
        # --------------------------------------------------------
        try:
            site = get_current_site(request)
            request.site_domain = getattr(site, "domain", None) or request.get_host()
            request.site_name = getattr(site, "name", "") or request.site_domain
        except Exception as exc:
            logger.debug("RequestMetaMiddleware: site resolution failed → %s", exc)
            request.site_domain = request.get_host()
            request.site_name = request.site_domain

        # --------------------------------------------------------
        # Determine client IP (handles X-Forwarded-For safely)
        # --------------------------------------------------------
        xff = request.META.get("HTTP_X_FORWARDED_FOR")
        if xff:
            # take the first IP (leftmost) only if properly formatted
            client_ip = xff.split(",")[0].strip()
        else:
            client_ip = request.META.get("REMOTE_ADDR", "")

        request.client_ip = client_ip

        # --------------------------------------------------------
        # Capture user agent
        # --------------------------------------------------------
        request.user_agent = request.META.get("HTTP_USER_AGENT", "")

        # --------------------------------------------------------
        # Origin & scheme helpers
        # --------------------------------------------------------
        request.scheme_normalized = "https" if request.is_secure() else "http"
        request.origin = f"{request.scheme_normalized}://{request.get_host()}"

        logger.debug(
            "RequestMetaMiddleware attached → site=%s, ip=%s, ua=%s",
            request.site_domain,
            request.client_ip,
            (request.user_agent or "unknown")[:64],
        )


--------------------------------------------
### FILE: apps\core\middleware\security_headers.py
### SIZE: 3622 bytes
### HASH: 461F6FAE366D8A568974F8167D68D5A40725F743320455CD5541E7E450F31530

"""
apps.core.middleware.security_headers
====================================

Enterprise-grade security header middleware.

✅ Django 5.2+ / Python 3.12+
✅ Per-request CSP nonces (no 'unsafe-inline')
✅ Compatible with modern browsers / COOP / CORP
✅ Minimal overhead (nonce generated once per request)
✅ Logging-aware, no silent leaks
"""

from __future__ import annotations

import secrets
import logging
from typing import Callable
from django.conf import settings
from django.http import HttpRequest, HttpResponse

logger = logging.getLogger(__name__)


class SecurityHeadersMiddleware:
    """Attach enterprise-grade secure HTTP headers to each response."""

    def __init__(self, get_response: Callable[[HttpRequest], HttpResponse]):
        self.get_response = get_response
        # Log once at startup for visibility
        logger.info(
            "SecurityHeadersMiddleware initialized (DEBUG=%s)", getattr(settings, "DEBUG", False)
        )

    def __call__(self, request: HttpRequest) -> HttpResponse:
        # Create per-request nonce (used in inline scripts/styles if templates add it)
        nonce = secrets.token_urlsafe(16)
        setattr(request, "csp_nonce", nonce)

        response = self.get_response(request)

        # ------------------------------------------------------------------
        # Core modern security headers
        # ------------------------------------------------------------------
        response["X-Content-Type-Options"] = "nosniff"
        response["X-Frame-Options"] = "DENY"
        response["Referrer-Policy"] = "strict-origin-when-cross-origin"
        response["Cross-Origin-Opener-Policy"] = "same-origin"
        response["Cross-Origin-Resource-Policy"] = "same-origin"
        response["Cross-Origin-Embedder-Policy"] = "require-corp"
        response["Permissions-Policy"] = (
            "geolocation=(), microphone=(), camera=(), payment=()"
        )

        # ------------------------------------------------------------------
        # Content Security Policy
        # ------------------------------------------------------------------
        if getattr(settings, "DEBUG", False):
            # Developer-friendly CSP (still restrictive)
            csp = (
                "default-src 'self' 'unsafe-inline' 'unsafe-eval'; "
                "img-src 'self' data:; style-src 'self' 'unsafe-inline'; "
                "connect-src 'self' ws: wss:; frame-src 'self';"
            )
        else:
            # Production CSP: strict, nonce-based, no unsafe-inline/eval
            csp = (
                "default-src 'self'; "
                f"script-src 'self' 'nonce-{nonce}' https://www.google.com/recaptcha/ "
                f"https://www.gstatic.com/recaptcha/; "
                f"style-src 'self' 'nonce-{nonce}' https://cdn.jsdelivr.net; "
                "img-src 'self' data: https:; "
                "connect-src 'self'; "
                "frame-src 'self' https://www.google.com/recaptcha/;"
            )

        response.setdefault("Content-Security-Policy", csp)

        # ------------------------------------------------------------------
        # Strict-Transport-Security (HSTS)
        # ------------------------------------------------------------------
        if not getattr(settings, "DEBUG", False):
            # 2 years = 63072000 s, include subdomains, preload
            response["Strict-Transport-Security"] = (
                "max-age=63072000; includeSubDomains; preload"
            )

        return response


--------------------------------------------
### FILE: apps\core\middleware\ssl_toggle.py
### SIZE: 2299 bytes
### HASH: B67D6E7101F505C43760CCB3F966B5AD10F733CF1402D8322D08CA75097A23F8

# apps/core/middleware/ssl_toggle.py
"""
apps/core/middleware/ssl_toggle
===============================
Dynamic HTTPS Enforcement Middleware for GSMInfinity.

✅ Safe across all environments
✅ Controlled by SiteSettings.force_https (admin-managed)
✅ Can be globally disabled via ENV variable FORCE_HTTPS_DEV_OVERRIDE
✅ Compatible with Django 5.2+
✅ No deprecations or recursion risks
"""

from __future__ import annotations
import os
import logging
from typing import Optional
from django.http import HttpRequest, HttpResponseRedirect
from django.utils.deprecation import MiddlewareMixin

logger = logging.getLogger(__name__)


def _should_force_https() -> bool:
    """
    Runtime-safe evaluation of SiteSettings.force_https.
    - Returns False on any import/config errors.
    - Can be overridden via the env var FORCE_HTTPS_DEV_OVERRIDE=0.
    """
    override = os.getenv("FORCE_HTTPS_DEV_OVERRIDE")
    if override is not None and override.strip().lower() in ("0", "false", "off", "no"):
        return False

    try:
        from apps.site_settings.models import SiteSettings  # local import
        settings_obj = SiteSettings.get_solo()
        return bool(getattr(settings_obj, "force_https", False))
    except Exception as e:
        logger.debug(f"[SslToggle] Fallback to HTTP: {e}")
        return False


class SslToggleMiddleware(MiddlewareMixin):
    """
    Middleware to redirect HTTP -> HTTPS only when:
      1. The current request is insecure, AND
      2. SiteSettings.force_https == True, AND
      3. FORCE_HTTPS_DEV_OVERRIDE is not disabling enforcement.
    """

    def process_request(self, request: HttpRequest) -> Optional[HttpResponseRedirect]:
        # Skip if already HTTPS or behind secure proxy
        if request.is_secure() or request.META.get("HTTP_X_FORWARDED_PROTO") == "https":
            return None

        if _should_force_https():
            absolute = request.build_absolute_uri(request.get_full_path())
            if absolute.startswith("http://"):
                https_url = "https://" + absolute[len("http://") :]
                logger.info(f"[SslToggle] Redirecting to HTTPS: {https_url}")
                return HttpResponseRedirect(https_url)

        return None


--------------------------------------------
### FILE: apps\core\models.py
### SIZE: 229 bytes
### HASH: 0DE9A583E5A1009C51C689E3E74AD77F421843827D9791A0D7F4824765B83D8B

from django.db import models


class TimestampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


--------------------------------------------
### FILE: apps\core\tests.py
### SIZE: 63 bytes
### HASH: DAE0DA7EFDCDB3A7FB572D5E914B60631099122D4A4727AC6434C016161C5FE1

from django.test import TestCase

# Create your tests here.


--------------------------------------------
### FILE: apps\core\urls.py
### SIZE: 4039 bytes
### HASH: 0391EFB9C7E68EBB5DFF0CD261C44489EC131F4478A58C01867FE36C167DC5C9

# apps/core/urls.py
"""
GSMInfinity — Core URL Configuration (Enterprise-Grade)
========================================================
Features:
- Full Django 5.2+ compliance (no deprecated APIs)
- Lazy view loading with import_string (prevents circular imports)
- Explicit namespacing for reverse() lookups
- Legal and policy page aliases for seamless frontend template integration
- Fully aligned with apps.core.views and apps.site_settings.views

Namespace: "core"
"""

from django.urls import path
from django.utils.module_loading import import_string
from typing import Callable, Any


# ----------------------------------------------------------------------
# Lazy Import Utility
# ----------------------------------------------------------------------
def view(name: str) -> Callable[..., Any]:
    """
    Dynamically import a view function by its dotted name.

    Supports:
      - short names (e.g., "home") → imports apps.core.views.home
      - fully qualified names (e.g., "apps.site_settings.views.privacy_policy")
        → imports directly without namespacing

    This approach prevents circular imports and reduces startup time.
    """
    if "." in name and not name.startswith("apps.core.views"):
        return import_string(name)
    return import_string(f"apps.core.views.{name}")


# ----------------------------------------------------------------------
# Namespace Declaration
# ----------------------------------------------------------------------
app_name = "core"


# ----------------------------------------------------------------------
# URL Patterns
# ----------------------------------------------------------------------
urlpatterns = [
    # ---------------------------------------------------------------
    #  Public Home / Landing
    # ---------------------------------------------------------------
    path("", view("home"), name="home"),

    # ---------------------------------------------------------------
    #  Tenants (Multi-Site Overview)
    # ---------------------------------------------------------------
    path("tenants/", view("tenants"), name="tenants"),

    # ---------------------------------------------------------------
    #  Dashboard Routes
    # ---------------------------------------------------------------
    path("dashboard/", view("overview"), name="dashboard_overview"),
    path("dashboard/security/", view("security"), name="dashboard_security"),
    path("dashboard/monetization/", view("monetization"), name="dashboard_monetization"),
    path("dashboard/notifications/", view("notifications"), name="dashboard_notifications"),
    path("dashboard/announcements/", view("announcements"), name="dashboard_announcements"),
    path("dashboard/users/", view("users_dashboard"), name="dashboard_users"),
    path("dashboard/system/", view("system_health"), name="dashboard_system"),

    # ---------------------------------------------------------------
    #  Legal / Policy Page Aliases
    # ---------------------------------------------------------------
    # These aliases ensure existing templates referencing {% url 'privacy' %}
    # or {% url 'terms' %} continue to work seamlessly.
    # They map to canonical views in apps.site_settings.views.
    path("privacy/", view("apps.site_settings.views.privacy_policy"), name="privacy"),
    path("terms/", view("apps.site_settings.views.terms_of_service"), name="terms"),
    path("cookies/", view("apps.site_settings.views.cookies_policy"), name="cookies"),
]


# ----------------------------------------------------------------------
# Notes:
# - All paths are namespaced under "core" for explicit reverse() lookups:
#     {% url 'core:dashboard_overview' %}
#     {% url 'core:privacy' %}
# - For cross-app aliasing, dotted import paths are used safely.
# - No recursion, no deprecated include() nesting, 100% Django 5.2+ ready.
# ----------------------------------------------------------------------


--------------------------------------------
### FILE: apps\core\views.py
### SIZE: 13016 bytes
### HASH: 70CF8E037CE0F24DD773352A73E67762ABBC400C009BB9E39633A97814970D56

# apps/core/views.py
"""
Core views — Enterprise-grade, Django 5.2+ ready.

Hardened to:
 - never return async/coroutine objects
 - never leak errors from ORM calls in async event loops
 - return only serializable objects to templates
 - load only existing templates safely
 - provide fully brand-neutral, tenant-safe site settings snapshot
"""

from __future__ import annotations

import logging
import sys
import django
from typing import Any, Dict, Optional, Iterable, List

from django.core.cache import cache
from django.http import HttpRequest, HttpResponse, HttpResponseServerError
from django.shortcuts import render
from django.template import TemplateDoesNotExist
from django.template.loader import get_template
from django.utils.timezone import now
from django.views.decorators.cache import never_cache

logger = logging.getLogger(__name__)

# Snapshot cache keys
_SITE_SETTINGS_SNAPSHOT_KEY = "core_site_settings_snapshot_v1"
_SITE_SETTINGS_VERSION_KEY = "site_settings_version"

# Valid home templates
_HOME_TEMPLATE_PRIORITY: List[str] = ["home.html", "core/home.html"]


# ============================================================
# INTERNAL UTILITIES
# ============================================================
def _safe_count(q: Any) -> int:
    """Safe count for any queryset or iterable."""
    try:
        qs = q() if callable(q) else q
        if qs is None:
            return 0
        if hasattr(qs, "count"):
            return int(qs.count())
        return int(len(qs))
    except Exception as exc:
        logger.debug("_safe_count fallback 0: %s", exc)
        return 0


def _safe_iter(q: Any, limit: int = 5) -> list:
    """Safe slice/iteration over queryset or iterable."""
    try:
        qs = q() if callable(q) else q
        if qs is None:
            return []
        if hasattr(qs, "order_by"):
            return list(qs.order_by("-created_at")[:limit])
        return list(qs)[:limit]
    except Exception as exc:
        logger.debug("_safe_iter fallback empty: %s", exc)
        return []


# ============================================================
# SNAPSHOT OF SITE SETTINGS (BRAND-NEUTRAL)
# ============================================================
def _get_site_settings_snapshot() -> Dict[str, Any]:
    """
    Returns a fully serializable dict for templates.
    Never returns ORM objects and never raises.
    """

    # Versioned cache key
    try:
        version = cache.get(_SITE_SETTINGS_VERSION_KEY) or 0
        key = f"{_SITE_SETTINGS_SNAPSHOT_KEY}_v{version}"
    except Exception:
        key = _SITE_SETTINGS_SNAPSHOT_KEY

    # Load from cache
    try:
        payload = cache.get(key)
        if payload:
            return payload
    except Exception:
        payload = None

    # Build snapshot
    try:
        from apps.site_settings.models import SiteSettings  # type: ignore

        obj = SiteSettings.get_solo() if hasattr(SiteSettings, "get_solo") else SiteSettings.objects.first()

        payload = {
            "site_name": getattr(obj, "site_name", "Site"),
            "site_header": getattr(obj, "site_header", "Admin"),
            "site_description": getattr(obj, "site_description", ""),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "require_mfa": bool(getattr(obj, "require_mfa", False)),
            "maintenance_mode": bool(getattr(obj, "maintenance_mode", False)),
            "primary_color": getattr(obj, "primary_color", "#0d6efd"),
            "secondary_color": getattr(obj, "secondary_color", "#6c757d"),
            "logo": getattr(obj, "logo", None).url if getattr(obj, "logo", None) else None,
            "dark_logo": getattr(obj, "dark_logo", None).url if getattr(obj, "dark_logo", None) else None,
            "favicon": getattr(obj, "favicon", None).url if getattr(obj, "favicon", None) else None,
        }
    except Exception as exc:
        logger.debug("site settings fallback: %s", exc)
        payload = {
            "site_name": "Site",
            "site_header": "Admin",
            "site_description": "",
            "enable_signup": True,
            "require_mfa": False,
            "maintenance_mode": False,
            "primary_color": "#0d6efd",
            "secondary_color": "#6c757d",
            "logo": None,
            "dark_logo": None,
            "favicon": None,
        }

    try:
        cache.set(key, payload, timeout=300)
    except Exception:
        pass

    return payload


# ============================================================
# SAFE RENDERING WRAPPER
# ============================================================
def _render_safe(request: HttpRequest, template: str, context: Dict[str, Any], status: int = 200) -> HttpResponse:
    """Completely safe render wrapper."""
    try:
        return render(request, template, context, status=status)
    except TemplateDoesNotExist as exc:
        logger.warning("Missing template: %s (%s)", template, exc)
        sn = context.get("site_name") or context.get("site_settings", {}).get("site_name") or "Site"
        return HttpResponse(
            f"<html><head><title>{sn}</title></head>"
            f"<body><h1>{sn}</h1><p>Content temporarily unavailable.</p></body></html>",
            status=status,
        )
    except Exception as exc:
        logger.exception("Render error for %s: %s", template, exc)
        return HttpResponseServerError("Internal server error")


def _first_existing_template(candidates: Iterable[str]) -> Optional[str]:
    """Pick first existing template (safe)."""
    for name in candidates:
        try:
            get_template(name)
            return name
        except TemplateDoesNotExist:
            continue
        except Exception:
            continue
    return None


# ============================================================
# HOME PAGE
# ============================================================
@never_cache
def home(request: HttpRequest) -> HttpResponse:
    settings_snapshot = _get_site_settings_snapshot()

    # Maintenance mode?
    if settings_snapshot.get("maintenance_mode"):
        return _render_safe(
            request,
            "errors/503.html",
            {
                "site_settings": settings_snapshot,
                "site_name": settings_snapshot.get("site_name"),
                "message": "This site is currently under maintenance.",
            },
            status=503,
        )

    # Query factories
    def _u():
        try:
            from apps.users.models import CustomUser  # type: ignore
            return CustomUser.objects.all()
        except Exception:
            return []

    def _d():
        try:
            from apps.users.models import DeviceFingerprint  # type: ignore
            return DeviceFingerprint.objects.filter(is_active=True)
        except Exception:
            return []

    def _n():
        try:
            from apps.users.models import Notification  # type: ignore
            if request.user.is_authenticated:
                return Notification.objects.filter(user=request.user, is_read=False)
            return Notification.objects.none()
        except Exception:
            return []

    def _a():
        try:
            from apps.users.models import Announcement  # type: ignore
            return Announcement.objects.filter(is_active=True)
        except Exception:
            return []

    # System info
    try:
        django_version = django.get_version()
    except Exception:
        django_version = "unknown"

    try:
        python_version = sys.version.split()[0]
    except Exception:
        python_version = "unknown"

    context = {
        "site_settings": settings_snapshot,
        "site_name": settings_snapshot.get("site_name"),
        "django_version": django_version,
        "python_version": python_version,
        "now": now(),
        "total_users": _safe_count(_u),
        "active_devices": _safe_count(_d),
        "unread_notifications": _safe_count(_n),
        "active_announcements": _safe_count(_a),
        "announcements": _safe_iter(_a, limit=5),
    }

    # Select homepage template
    template_name = _first_existing_template(_HOME_TEMPLATE_PRIORITY)
    if template_name:
        return _render_safe(request, template_name, context)

    # Ultimate fallback
    logger.error("No homepage template found among: %s", _HOME_TEMPLATE_PRIORITY)
    sn = context["site_name"]
    return HttpResponse(
        f"<html><head><title>{sn}</title></head>"
        f"<body><h1>{sn}</h1><p>Home page temporarily unavailable.</p></body></html>",
        status=503,
    )


# ============================================================
# DASHBOARD / STATIC PAGES
# ============================================================
def overview(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/overview.html", {"site_settings": _get_site_settings_snapshot()})


def security(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/security.html", {"site_settings": _get_site_settings_snapshot()})


def monetization(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/monetization.html", {"site_settings": _get_site_settings_snapshot()})


def notifications(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/notifications.html", {"site_settings": _get_site_settings_snapshot()})


def announcements(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/announcements.html", {"site_settings": _get_site_settings_snapshot()})


def users_dashboard(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/users.html", {"site_settings": _get_site_settings_snapshot()})


def system_health(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "dashboard/system_health.html", {"site_settings": _get_site_settings_snapshot()})


# ============================================================
# TENANTS
# ============================================================
def tenants(request: HttpRequest) -> HttpResponse:
    try:
        from apps.site_settings.models import TenantSiteSettings  # type: ignore
        qs = TenantSiteSettings.objects.select_related("site").prefetch_related("meta_tags", "verification_files")
        tenants = list(qs.order_by("site__domain"))
    except Exception as exc:
        logger.debug("TenantSiteSettings unavailable: %s", exc)
        tenants = []

    return _render_safe(
        request,
        "core/tenants.html",
        {
            "site_settings": _get_site_settings_snapshot(),
            "tenants": tenants,
        },
    )


# ============================================================
# LEGAL PAGES
# ============================================================
def privacy(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "legal/privacy.html", {"site_settings": _get_site_settings_snapshot()})


def terms(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "legal/terms.html", {"site_settings": _get_site_settings_snapshot()})


def cookies(request: HttpRequest) -> HttpResponse:
    return _render_safe(request, "legal/cookies.html", {"site_settings": _get_site_settings_snapshot()})


# ============================================================
# ERROR HANDLERS
# ============================================================
def error_400_view(request: HttpRequest, exception: Optional[Exception] = None) -> HttpResponse:
    return _render_safe(
        request,
        "errors/400.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=400,
    )


def error_403_view(request: HttpRequest, exception: Optional[Exception] = None) -> HttpResponse:
    return _render_safe(
        request,
        "errors/403.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=403,
    )


def error_404_view(request: HttpRequest, exception: Optional[Exception] = None) -> HttpResponse:
    return _render_safe(
        request,
        "errors/404.html",
        {"site_settings": _get_site_settings_snapshot(), "error": str(exception or "")},
        status=404,
    )


def error_500_view(request: HttpRequest) -> HttpResponse:
    try:
        return _render_safe(
            request,
            "errors/500.html",
            {"site_settings": _get_site_settings_snapshot()},
            status=500,
        )
    except Exception:
        return HttpResponseServerError("Internal server error")


--------------------------------------------
### FILE: apps\core\views\errors.py
### SIZE: 472 bytes
### HASH: 8972162527EC6FEC14C037B9878C5AB7D799FB85053D77796D854F218F0F6E1C

from django.http import JsonResponse

async def error_400_view(request, exception):
    return JsonResponse({"error": "bad_request"}, status=400)

async def error_403_view(request, exception):
    return JsonResponse({"error": "forbidden"}, status=403)

async def error_404_view(request, exception):
    return JsonResponse({"error": "not_found"}, status=404)

async def error_500_view(request):
    return JsonResponse({"error": "server_error"}, status=500)


--------------------------------------------
### FILE: apps\site_settings\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\site_settings\admin.py
### SIZE: 7730 bytes
### HASH: 7CA0C5E7E69025B58F60AC2FC414EE427E9ABC35A020D8FD525502333A6582CC

"""
apps.site_settings.admin
========================
Enterprise Admin Configuration for Site + Tenant Settings.

✔ Django 5.2 / Python 3.12
✔ Supports new branding fields (logo, dark_logo, favicon)
✔ Secure, clean fieldsets (no direct M2M inside)
✔ Through-model inlines for meta-tags & verification files
✔ Image previews inside admin
"""

from __future__ import annotations

import logging
from django.contrib import admin
from django.utils.html import format_html
from django.utils.translation import gettext_lazy as _
from import_export.admin import ExportMixin
from solo.admin import SingletonModelAdmin

from .models import (
    SiteSettings,
    TenantSiteSettings,
    VerificationMetaTag,
    VerificationFile,
)

logger = logging.getLogger(__name__)

# ------------------------------------------------------------
#  INLINE THROUGH-MODELS
# ------------------------------------------------------------
class SiteSettingsMetaTagInline(admin.TabularInline):
    model = SiteSettings.meta_tags.through
    extra = 0
    verbose_name = _("Verification Meta Tag Link")
    verbose_name_plural = _("Verification Meta Tag Links")


class SiteSettingsFileInline(admin.TabularInline):
    model = SiteSettings.verification_files.through
    extra = 0
    verbose_name = _("Verification File Link")
    verbose_name_plural = _("Verification File Links")


# ------------------------------------------------------------
#  IMAGE PREVIEW HELPERS
# ------------------------------------------------------------
def _preview(obj, field_name: str, height: int = 60):
    """Safe preview for logo, dark_logo, favicon."""
    try:
        field = getattr(obj, field_name, None)
        if not field:
            return "-"
        if not getattr(field, "url", None):
            return "-"
        return format_html(
            '<img src="{}" style="height:{}px; border-radius:6px;" />',
            field.url,
            height,
        )
    except Exception:
        return "-"


# ------------------------------------------------------------
#  SiteSettings Admin (Singleton)
# ------------------------------------------------------------
@admin.register(SiteSettings)
class SiteSettingsAdmin(ExportMixin, SingletonModelAdmin):

    list_display = (
        "site_name",
        "maintenance_mode",
        "force_https",
        "enable_signup",
        "enable_notifications",
        "require_mfa",
        "recaptcha_enabled",
    )

    search_fields = ("site_name", "site_header", "site_description")
    list_per_page = 25
    save_on_top = True

    readonly_fields = (
        "logo_preview",
        "dark_logo_preview",
        "favicon_preview",
    )

    # ----------------------
    # Fieldsets
    # ----------------------
    fieldsets = (
        ("🔖 Branding & Theme", {
            "fields": (
                "site_name",
                "site_header",
                "site_description",

                "logo",
                "logo_preview",

                "dark_logo",
                "dark_logo_preview",

                "favicon",
                "favicon_preview",

                "theme_profile",
                "primary_color",
                "secondary_color",
            ),
        }),

        ("🌍 Locale & Internationalization", {
            "fields": (
                "default_language",
                "timezone",
                "enable_localization",
            ),
        }),

        ("🤖 AI Personalization", {
            "fields": (
                "enable_ai_personalization",
                "ai_theme_mode",
                "ai_model_version",
            ),
        }),

        ("🔐 Security & Features", {
            "fields": (
                "enable_signup",
                "enable_password_reset",
                "enable_notifications",
                "maintenance_mode",
                "force_https",
            ),
        }),

        ("🧠 reCAPTCHA Configuration", {
            "fields": (
                "recaptcha_enabled",
                "recaptcha_mode",
                "recaptcha_public_key",
                "recaptcha_private_key",
                "recaptcha_score_threshold",
                "recaptcha_timeout_ms",
            ),
        }),

        ("📱 Device & MFA Policies", {
            "fields": (
                "max_devices_per_user",
                "lock_duration_minutes",
                "fingerprint_mode",
                "enforce_unique_device",
                "require_mfa",
                "mfa_totp_issuer",
            ),
        }),

        ("📧 Email Verification", {
            "fields": (
                "email_verification_code_length",
                "email_verification_code_type",
            ),
        }),

        ("🛡️ Rate Limiting & Robustness", {
            "fields": (
                "max_login_attempts",
                "rate_limit_window_seconds",
                "cache_ttl_seconds",
            ),
        }),
    )

    inlines = [SiteSettingsMetaTagInline, SiteSettingsFileInline]

    # ----------------------
    # Preview fields
    # ----------------------
    def logo_preview(self, obj):
        return _preview(obj, "logo")

    def dark_logo_preview(self, obj):
        return _preview(obj, "dark_logo")

    def favicon_preview(self, obj):
        return _preview(obj, "favicon")

    logo_preview.short_description = "Logo Preview"
    dark_logo_preview.short_description = "Dark Logo Preview"
    favicon_preview.short_description = "Favicon Preview"

    # ----------------------
    # Save Logger
    # ----------------------
    def save_model(self, request, obj, form, change):
        super().save_model(request, obj, form, change)
        logger.info(
            "SiteSettings updated by %s (force_https=%s, maintenance_mode=%s)",
            request.user,
            obj.force_https,
            obj.maintenance_mode,
        )


# ------------------------------------------------------------
#  TENANT SETTINGS ADMIN
# ------------------------------------------------------------
@admin.register(TenantSiteSettings)
class TenantSiteSettingsAdmin(ExportMixin, admin.ModelAdmin):

    list_display = ("site", "theme_profile", "primary_color", "secondary_color")
    search_fields = ("site__domain", "theme_profile")
    ordering = ("site",)
    list_select_related = ("site",)
    list_per_page = 50
    save_on_top = True


# ------------------------------------------------------------
#  VERIFICATION RESOURCES
# ------------------------------------------------------------
@admin.register(VerificationMetaTag)
class VerificationMetaTagAdmin(admin.ModelAdmin):
    list_display = ("provider", "name_attr", "content_attr", "created_at")
    search_fields = ("provider", "name_attr", "content_attr")
    ordering = ("-created_at",)
    readonly_fields = ("created_at",)
    save_on_top = True


@admin.register(VerificationFile)
class VerificationFileAdmin(admin.ModelAdmin):
    list_display = ("provider", "file", "uploaded_at")
    search_fields = ("provider", "file")
    ordering = ("-uploaded_at",)
    readonly_fields = ("uploaded_at",)
    save_on_top = True


# ------------------------------------------------------------
#  Admin Branding (non-project-specific)
# ------------------------------------------------------------
admin.site.site_header = _("Administration Portal")
admin.site.index_title = _("Enterprise Settings")
admin.site.site_title = _("Site Configuration")


--------------------------------------------
### FILE: apps\site_settings\apps.py
### SIZE: 789 bytes
### HASH: 6FA426EB1426B65A6BC0BCCE281FE2D0CC0BE1C2A571D68B9678C8A074FAA5AC

from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class SiteSettingsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.site_settings"      # full Python path
    label = "site_settings"          # short label
    verbose_name = "Site Settings"

    def ready(self):
        """
        Initialize site settings and related signals.

        - Loads signal hooks to sync database-based settings
        - Avoids circular imports during startup
        - Autodiscovers additional settings modules if needed
        """
        try:
            import apps.site_settings.signals  # noqa: F401
        except ImportError:
            pass

        autodiscover_modules("signals")


--------------------------------------------
### FILE: apps\site_settings\context_processors.py
### SIZE: 9782 bytes
### HASH: F9C9143DDA8049696E7D5C6EFE4AE4DD04AFBCDCCF9A692CC11F7AAA8DB9ECE7

"""
Enterprise-grade Site Settings Context Processor (FINAL, SYNC-ONLY)

✓ 100% synchronous (no await / no sync_to_async / no async context switching)
✓ WSGI + ASGI safe
✓ ORM calls fully wrapped in defensive guards
✓ Never leaks exceptions into templates
✓ Returns consistent, normalized schema
✓ No recursion risk, no unsafe attributes
"""

from __future__ import annotations

import hashlib
import logging
from typing import Any, Dict, Iterable, Optional

from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.http import HttpRequest
from django.templatetags.static import static

logger = logging.getLogger(__name__)

DEFAULT_TTL_SECONDS = 300
CACHE_KEY_PREFIX = "active_site_settings"


# ---------------------------------------------------------------------
# KEY HELPERS
# ---------------------------------------------------------------------
def _safe_domain_key(domain: Optional[str]) -> str:
    """Convert domain → cache key (collision-resistant, no unsafe chars)."""
    safe = (domain or "global").strip().lower()
    digest = hashlib.sha256(safe.encode("utf-8")).hexdigest()[:16]
    return f"{CACHE_KEY_PREFIX}_{digest}"


def _iter_related(obj: Any, attr: str) -> Iterable:
    """Returns a tuple for all related items safely & consistently."""
    try:
        rel = getattr(obj, attr, None)
        if rel is None:
            return ()
        if hasattr(rel, "all"):
            return tuple(rel.all())
        if isinstance(rel, (list, tuple, set)):
            return tuple(rel)
        return (rel,)
    except Exception:
        return ()


def _file_url_or_default(file_field, default_static_path: str) -> str:
    """Safe URL resolver for file fields."""
    try:
        if file_field and getattr(file_field, "url", None):
            url = file_field.url
            if isinstance(url, str) and url.strip():
                return url
    except Exception:
        pass
    return static(default_static_path)


# ---------------------------------------------------------------------
# SERIALIZER (pure sync, full defensive)
# ---------------------------------------------------------------------
def _safe_defaults() -> Dict[str, Any]:
    """Central default payload (no recursion)."""
    return {
        "id": None,
        "site_domain": "global",
        "site_name": "Site",
        "site_header": "Admin",
        "site_description": "",
        "logo": static("img/default-logo.svg"),
        "dark_logo": static("img/default-logo-dark.svg"),
        "favicon": static("img/default-favicon.png"),
        "theme": "default",
        "primary_color": "#0d6efd",
        "secondary_color": "#6c757d",
        "enable_signup": True,
        "enable_notifications": True,
        "maintenance_mode": False,
        "force_https": False,
        "recaptcha_enabled": False,
        "cache_ttl_seconds": DEFAULT_TTL_SECONDS,
        "meta_tags": [],
        "verification_files": [],
    }


def _serialize(obj: Any) -> Dict[str, Any]:
    """Convert ORM object → dict (fully isolated, exception-proof)."""

    if obj is None:
        return _safe_defaults()

    try:
        # domain fallback logic (tenant site → instance → global)
        site_domain = (
            getattr(getattr(obj, "site", None), "domain", None)
            or getattr(obj, "site_domain", None)
            or "global"
        )

        # META TAGS
        meta_tags = []
        for m in _iter_related(obj, "meta_tags"):
            name = getattr(m, "name", None) or getattr(m, "name_attr", None)
            content = getattr(m, "content", None) or getattr(m, "content_attr", None)
            if isinstance(name, str) and name.strip():
                meta_tags.append({
                    "name": name.strip(),
                    "content": content or "",
                })

        # VERIFICATION FILES
        verification_files = []
        for f in _iter_related(obj, "verification_files"):
            file_field = getattr(f, "file", None)
            raw_name = getattr(file_field, "name", None) or getattr(f, "filename", None) or ""
            raw_url = getattr(file_field, "url", None) or ""

            filename = raw_name if isinstance(raw_name, str) else ""
            url = raw_url if isinstance(raw_url, str) else ""

            if not url.strip():
                url = static("img/default-verification.txt")

            verification_files.append({
                "filename": filename,
                "url": url,
                "provider": getattr(f, "provider", "") or "",
            })

        ttl = getattr(obj, "cache_ttl_seconds", DEFAULT_TTL_SECONDS)
        try:
            ttl = int(ttl)
        except Exception:
            ttl = DEFAULT_TTL_SECONDS

        return {
            "id": getattr(obj, "id", None),
            "site_domain": site_domain,
            "site_name": getattr(obj, "site_name", "Site"),
            "site_header": getattr(obj, "site_header", "Admin"),
            "site_description": getattr(obj, "site_description", "") or "",
            "logo": _file_url_or_default(getattr(obj, "logo", None), "img/default-logo.svg"),
            "dark_logo": _file_url_or_default(getattr(obj, "dark_logo", None), "img/default-logo-dark.svg"),
            "favicon": _file_url_or_default(getattr(obj, "favicon", None), "img/default-favicon.png"),
            "theme": getattr(obj, "theme", "default"),
            "primary_color": getattr(obj, "primary_color", "#0d6efd"),
            "secondary_color": getattr(obj, "secondary_color", "#6c757d"),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "enable_notifications": bool(getattr(obj, "enable_notifications", True)),
            "maintenance_mode": bool(getattr(obj, "maintenance_mode", False)),
            "force_https": bool(getattr(obj, "force_https", False)),
            "recaptcha_enabled": bool(getattr(obj, "recaptcha_enabled", False)),
            "cache_ttl_seconds": ttl,
            "meta_tags": meta_tags,
            "verification_files": verification_files,
        }

    except Exception:
        logger.error("_serialize failed → defaults used", exc_info=True)
        return _safe_defaults()


# ---------------------------------------------------------------------
# ORM LOADER (100% synchronous)
# ---------------------------------------------------------------------
def _load_sync(site):
    """Loads tenant → global settings in strict sync mode."""
    try:
        from apps.site_settings import models as m
    except Exception:
        logger.error("Import failure: apps.site_settings missing", exc_info=True)
        return None

    try:
        # Tenant-level lookup (safe)
        if site and hasattr(site, "id"):
            try:
                t = (
                    m.TenantSiteSettings.objects
                    .select_related("site")
                    .prefetch_related("meta_tags", "verification_files")
                    .filter(site=site)
                    .first()
                )
                if t:
                    return t
            except Exception:
                pass

        # Global singleton
        if hasattr(m.SiteSettings, "get_solo"):
            try:
                return m.SiteSettings.get_solo()
            except Exception:
                pass

        # Fallback: first record
        try:
            return m.SiteSettings.objects.first()
        except Exception:
            return None

    except Exception:
        logger.debug("_load_sync failed → None")
        return None


# ---------------------------------------------------------------------
# MAIN CONTEXT PROCESSOR (FULLY SYNC, FULLY SAFE)
# ---------------------------------------------------------------------
def site_settings(request: HttpRequest) -> Dict[str, Any]:
    try:
        try:
            site = get_current_site(request)
            domain = getattr(site, "domain", None) or f"id-{getattr(site, 'id', 'global')}"
        except Exception:
            site = None
            domain = "global"

        cache_key = _safe_domain_key(domain)

        # Cache hit
        try:
            cached = cache.get(cache_key)
            if isinstance(cached, dict):
                return {
                    "site_settings": cached,
                    "settings": cached,
                    "meta_tags": cached.get("meta_tags", []),
                    "verification_files": cached.get("verification_files", []),
                }
        except Exception:
            pass

        # Load ORM → serialize
        raw_obj = _load_sync(site)
        payload = _serialize(raw_obj)

        # Cache write
        try:
            cache.set(cache_key, payload, timeout=payload["cache_ttl_seconds"])
        except Exception:
            pass

        return {
            "site_settings": payload,
            "settings": payload,
            "meta_tags": payload.get("meta_tags", []),
            "verification_files": payload.get("verification_files", []),
        }

    except Exception:
        logger.error("site_settings processor fatal → defaults", exc_info=True)
        payload = _safe_defaults()
        return {
            "site_settings": payload,
            "settings": payload,
            "meta_tags": [],
            "verification_files": [],
        }


# Alias (keeps backwards compatibility)
def global_settings(request: HttpRequest) -> Dict[str, Any]:
    return site_settings(request)


--------------------------------------------
### FILE: apps\site_settings\management\commands\clear_site_settings_cache.py
### SIZE: 380 bytes
### HASH: 7CCB85D058D97A4ADE6780A45290F88F774DE6CFD15A77B90A57BA6D5E7E9AAF

from django.core.management.base import BaseCommand
from apps.site_settings.signals import clear_site_settings_cache

class Command(BaseCommand):
    help = "Clear site settings caches (singleton and per-site keys)."

    def handle(self, *args, **options):
        clear_site_settings_cache()
        self.stdout.write(self.style.SUCCESS("Site settings caches cleared."))

--------------------------------------------
### FILE: apps\site_settings\migrations\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\site_settings\migrations\0001_initial.py
### SIZE: 10132 bytes
### HASH: FAC13EF4E386BA58C38C797B04FC372E1A7896D42C7F7A2E332C908BFDFD04BE

# Generated by Django 5.2.8 on 2025-11-18 21:26

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('sites', '0002_alter_domain_unique'),
    ]

    operations = [
        migrations.CreateModel(
            name='SiteSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('site_name', models.CharField(default='Site', max_length=100)),
                ('site_header', models.CharField(default='Admin', max_length=100)),
                ('site_description', models.TextField(blank=True, default='')),
                ('logo', models.ImageField(blank=True, help_text='Primary site logo (SVG/PNG)', null=True, upload_to='branding/')),
                ('dark_logo', models.ImageField(blank=True, help_text='Dark mode logo', null=True, upload_to='branding/')),
                ('favicon', models.ImageField(blank=True, help_text='Favicon (PNG/ICO/SVG)', null=True, upload_to='branding/')),
                ('theme_profile', models.CharField(blank=True, max_length=50, null=True)),
                ('primary_color', models.CharField(blank=True, max_length=7, null=True, validators=[django.core.validators.RegexValidator(message='Enter a valid hex color like #0d6efd', regex='^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$')])),
                ('secondary_color', models.CharField(blank=True, max_length=7, null=True, validators=[django.core.validators.RegexValidator(message='Enter a valid hex color like #0d6efd', regex='^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$')])),
                ('default_language', models.CharField(default='en', max_length=10)),
                ('timezone', models.CharField(default='UTC', max_length=50)),
                ('enable_localization', models.BooleanField(default=False)),
                ('enable_ai_personalization', models.BooleanField(default=False)),
                ('ai_theme_mode', models.CharField(choices=[('light', 'Light'), ('dark', 'Dark'), ('auto', 'Auto')], default='auto', max_length=20)),
                ('ai_model_version', models.CharField(blank=True, max_length=20, null=True)),
                ('enable_signup', models.BooleanField(default=True)),
                ('enable_password_reset', models.BooleanField(default=True)),
                ('enable_notifications', models.BooleanField(default=True)),
                ('maintenance_mode', models.BooleanField(default=False)),
                ('force_https', models.BooleanField(default=False, help_text='Enable only if TLS is enforced by reverse proxy')),
                ('recaptcha_enabled', models.BooleanField(default=False)),
                ('recaptcha_mode', models.CharField(choices=[('v2', 'v2'), ('v3', 'v3')], default='v2', max_length=20)),
                ('recaptcha_public_key', models.CharField(blank=True, max_length=100, null=True)),
                ('recaptcha_private_key', models.CharField(blank=True, max_length=100, null=True)),
                ('recaptcha_score_threshold', models.FloatField(default=0.5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('recaptcha_timeout_ms', models.PositiveIntegerField(default=3000)),
                ('max_devices_per_user', models.PositiveIntegerField(default=3)),
                ('lock_duration_minutes', models.PositiveIntegerField(default=15)),
                ('fingerprint_mode', models.CharField(choices=[('strict', 'Strict'), ('lenient', 'Lenient')], default='strict', max_length=20)),
                ('enforce_unique_device', models.BooleanField(default=True)),
                ('require_mfa', models.BooleanField(default=False)),
                ('mfa_totp_issuer', models.CharField(default='Site', max_length=50)),
                ('email_verification_code_length', models.PositiveIntegerField(default=6, validators=[django.core.validators.MinValueValidator(4), django.core.validators.MaxValueValidator(12)])),
                ('email_verification_code_type', models.CharField(choices=[('numeric', 'Numeric'), ('alphanumeric', 'Alphanumeric')], default='alphanumeric', max_length=20)),
                ('max_login_attempts', models.PositiveIntegerField(default=5)),
                ('rate_limit_window_seconds', models.PositiveIntegerField(default=300)),
                ('cache_ttl_seconds', models.PositiveIntegerField(default=600)),
            ],
            options={
                'verbose_name': 'Site Settings',
                'verbose_name_plural': 'Site Settings',
            },
        ),
        migrations.CreateModel(
            name='VerificationFile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('provider', models.CharField(db_index=True, max_length=50)),
                ('file', models.FileField(upload_to='verification/')),
                ('description', models.TextField(blank=True, default='')),
                ('uploaded_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'ordering': ['-uploaded_at'],
                'indexes': [models.Index(fields=['provider'], name='ver_file_idx')],
            },
        ),
        migrations.CreateModel(
            name='SiteSettingsVerificationFileLink',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_at', models.DateTimeField(auto_now_add=True)),
                ('site_settings', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='verification_file_links', to='site_settings.sitesettings')),
                ('verification_file', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='site_links', to='site_settings.verificationfile')),
            ],
        ),
        migrations.AddField(
            model_name='sitesettings',
            name='verification_files',
            field=models.ManyToManyField(blank=True, through='site_settings.SiteSettingsVerificationFileLink', to='site_settings.verificationfile'),
        ),
        migrations.CreateModel(
            name='VerificationMetaTag',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('provider', models.CharField(db_index=True, max_length=50)),
                ('name_attr', models.CharField(max_length=100)),
                ('content_attr', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, default='')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['provider', 'name_attr'], name='ver_meta_idx')],
            },
        ),
        migrations.CreateModel(
            name='TenantSiteSettings',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('theme_profile', models.CharField(blank=True, max_length=50, null=True)),
                ('primary_color', models.CharField(blank=True, max_length=7, null=True, validators=[django.core.validators.RegexValidator(message='Enter a valid hex color like #0d6efd', regex='^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$')])),
                ('secondary_color', models.CharField(blank=True, max_length=7, null=True, validators=[django.core.validators.RegexValidator(message='Enter a valid hex color like #0d6efd', regex='^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$')])),
                ('site', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='tenant_settings', to='sites.site')),
                ('verification_files', models.ManyToManyField(blank=True, to='site_settings.verificationfile')),
                ('meta_tags', models.ManyToManyField(blank=True, to='site_settings.verificationmetatag')),
            ],
            options={
                'verbose_name': 'Tenant Site Settings',
            },
        ),
        migrations.CreateModel(
            name='SiteSettingsMetaTagLink',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('linked_at', models.DateTimeField(auto_now_add=True)),
                ('site_settings', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='meta_tag_links', to='site_settings.sitesettings')),
                ('meta_tag', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='site_links', to='site_settings.verificationmetatag')),
            ],
        ),
        migrations.AddField(
            model_name='sitesettings',
            name='meta_tags',
            field=models.ManyToManyField(blank=True, through='site_settings.SiteSettingsMetaTagLink', to='site_settings.verificationmetatag'),
        ),
        migrations.AddIndex(
            model_name='sitesettingsverificationfilelink',
            index=models.Index(fields=['site_settings', 'verification_file'], name='site_file_link_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='sitesettingsverificationfilelink',
            unique_together={('site_settings', 'verification_file')},
        ),
        migrations.AddIndex(
            model_name='sitesettingsmetataglink',
            index=models.Index(fields=['site_settings', 'meta_tag'], name='site_meta_link_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='sitesettingsmetataglink',
            unique_together={('site_settings', 'meta_tag')},
        ),
    ]


--------------------------------------------
### FILE: apps\site_settings\models.py
### SIZE: 14941 bytes
### HASH: 800E28F488771E1A3A889595EAF159C6E434D868F31E746242A4AD1607C2FA4C

"""
Enterprise-grade Site & Tenant Settings

✓ Django 5.2 / Python 3.12
✓ Admin-uploadable branding assets (logo, dark logo, favicon)
✓ Generic, non-branded defaults
✓ Hardened validation (colors, file uploads, limits)
✓ Fully safe file URL helpers (static() fallback)
✓ Strict ManyToMany consistency
✓ Tenant-aware
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Optional, Any

from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator, MinValueValidator, MaxValueValidator
from django.db import models
from django.contrib.sites.models import Site
from django.templatetags.static import static
from solo.models import SingletonModel

logger = logging.getLogger(__name__)

# =====================================================================
# GLOBAL CONSTANTS
# =====================================================================
_ALLOWED_VERIFICATION_EXTENSIONS = {".txt", ".html", ".xml", ".json"}
_MAX_VERIFICATION_FILE_BYTES = 1 * 1024 * 1024  # 1 MiB

_HEX_COLOR_VALIDATOR = RegexValidator(
    regex=r"^#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
    message="Enter a valid hex color like #0d6efd",
)


# =====================================================================
# GLOBAL / DEFAULT SITE SETTINGS (SINGLETON)
# =====================================================================
class SiteSettings(SingletonModel):
    """
    Global site-wide configuration (non-branded, fully generic).
    """

    # ------------------------------------------------------------------
    # Branding – MUST remain generic (no “GSM” or “Infinity”!)
    # ------------------------------------------------------------------
    site_name = models.CharField(max_length=100, default="Site")
    site_header = models.CharField(max_length=100, default="Admin")
    site_description = models.TextField(blank=True, default="")

    logo = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Primary site logo (SVG/PNG)",
    )
    dark_logo = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Dark mode logo",
    )
    favicon = models.ImageField(
        upload_to="branding/",
        blank=True,
        null=True,
        help_text="Favicon (PNG/ICO/SVG)",
    )

    # ------------------------------------------------------------------
    # Theme
    # ------------------------------------------------------------------
    theme_profile = models.CharField(max_length=50, blank=True, null=True)

    primary_color = models.CharField(
        max_length=7,
        blank=True,
        null=True,
        validators=[_HEX_COLOR_VALIDATOR],
    )
    secondary_color = models.CharField(
        max_length=7,
        blank=True,
        null=True,
        validators=[_HEX_COLOR_VALIDATOR],
    )

    # ------------------------------------------------------------------
    # Localization
    # ------------------------------------------------------------------
    default_language = models.CharField(max_length=10, default="en")
    timezone = models.CharField(max_length=50, default="UTC")
    enable_localization = models.BooleanField(default=False)

    # ------------------------------------------------------------------
    # AI Personalization
    # ------------------------------------------------------------------
    enable_ai_personalization = models.BooleanField(default=False)
    ai_theme_mode = models.CharField(
        max_length=20,
        choices=[("light", "Light"), ("dark", "Dark"), ("auto", "Auto")],
        default="auto",
    )
    ai_model_version = models.CharField(max_length=20, blank=True, null=True)

    # ------------------------------------------------------------------
    # Security & Features
    # ------------------------------------------------------------------
    enable_signup = models.BooleanField(default=True)
    enable_password_reset = models.BooleanField(default=True)
    enable_notifications = models.BooleanField(default=True)
    maintenance_mode = models.BooleanField(default=False)

    force_https = models.BooleanField(
        default=False,
        help_text="Enable only if TLS is enforced by reverse proxy",
    )

    # ------------------------------------------------------------------
    # reCAPTCHA
    # ------------------------------------------------------------------
    recaptcha_enabled = models.BooleanField(default=False)
    recaptcha_mode = models.CharField(
        max_length=20,
        choices=[("v2", "v2"), ("v3", "v3")],
        default="v2",
    )
    recaptcha_public_key = models.CharField(max_length=100, blank=True, null=True)
    recaptcha_private_key = models.CharField(max_length=100, blank=True, null=True)

    recaptcha_score_threshold = models.FloatField(
        default=0.5,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
    )
    recaptcha_timeout_ms = models.PositiveIntegerField(default=3000)

    # ------------------------------------------------------------------
    # MFA / Device Security
    # ------------------------------------------------------------------
    max_devices_per_user = models.PositiveIntegerField(default=3)
    lock_duration_minutes = models.PositiveIntegerField(default=15)
    fingerprint_mode = models.CharField(
        max_length=20,
        choices=[("strict", "Strict"), ("lenient", "Lenient")],
        default="strict",
    )
    enforce_unique_device = models.BooleanField(default=True)
    require_mfa = models.BooleanField(default=False)

    mfa_totp_issuer = models.CharField(max_length=50, default="Site")

    # ------------------------------------------------------------------
    # Email Verification
    # ------------------------------------------------------------------
    email_verification_code_length = models.PositiveIntegerField(
        default=6,
        validators=[MinValueValidator(4), MaxValueValidator(12)],
    )
    email_verification_code_type = models.CharField(
        max_length=20,
        choices=[("numeric", "Numeric"), ("alphanumeric", "Alphanumeric")],
        default="alphanumeric",
    )

    # ------------------------------------------------------------------
    # Rate limiting
    # ------------------------------------------------------------------
    max_login_attempts = models.PositiveIntegerField(default=5)
    rate_limit_window_seconds = models.PositiveIntegerField(default=300)

    # Cache TTL (consumed by the context processor)
    cache_ttl_seconds = models.PositiveIntegerField(default=600)

    # ------------------------------------------------------------------
    # Meta Tags & Verification Files
    # ------------------------------------------------------------------
    meta_tags = models.ManyToManyField(
        "VerificationMetaTag",
        through="SiteSettingsMetaTagLink",
        blank=True,
    )
    verification_files = models.ManyToManyField(
        "VerificationFile",
        through="SiteSettingsVerificationFileLink",
        blank=True,
    )

    class Meta:
        verbose_name = "Site Settings"
        verbose_name_plural = "Site Settings"

    def __str__(self) -> str:
        return self.site_name or "Site Settings"

    # =================================================================
    # SAFE FILE URL HELPERS (always static fallback)
    # =================================================================
    def _safe_file_url(self, field, fallback: str) -> str:
        try:
            if field and getattr(field, "url", None):
                url = field.url
                if isinstance(url, str) and url.strip():
                    return url
        except Exception:
            pass
        return static(fallback)

    @property
    def logo_url(self) -> str:
        return self._safe_file_url(self.logo, "img/default-logo.svg")

    @property
    def dark_logo_url(self) -> str:
        # Try dark → fallback to normal → fallback to static
        url = self._safe_file_url(self.dark_logo, "")
        if url:
            return url
        url = self._safe_file_url(self.logo, "")
        if url:
            return url
        return static("img/default-logo-dark.svg")

    @property
    def favicon_url(self) -> str:
        return self._safe_file_url(self.favicon, "img/default-favicon.png")

    # =================================================================
    # VALIDATION
    # =================================================================
    def clean(self):
        errors = {}

        for name, val in [
            ("primary_color", self.primary_color),
            ("secondary_color", self.secondary_color),
        ]:
            if val:
                try:
                    _HEX_COLOR_VALIDATOR(val)
                except ValidationError as exc:
                    errors[name] = exc.messages

        if errors:
            raise ValidationError(errors)

    # =================================================================
    # FRONTEND CONFIG HELPERS
    # =================================================================
    def get_theme(self) -> dict[str, Any]:
        return {
            "profile": self.theme_profile or "default",
            "primary_color": self.primary_color or "#0d6efd",
            "secondary_color": self.secondary_color or "#6c757d",
            "ai_mode": self.ai_theme_mode,
        }

    def recaptcha_config(self) -> dict[str, Any]:
        return {
            "enabled": bool(self.recaptcha_enabled),
            "mode": self.recaptcha_mode,
            "public_key": self.recaptcha_public_key or "",
            "threshold": float(self.recaptcha_score_threshold),
            "timeout": int(self.recaptcha_timeout_ms),
        }


# =====================================================================
# META TAGS
# =====================================================================
class VerificationMetaTag(models.Model):
    provider = models.CharField(max_length=50, db_index=True)
    name_attr = models.CharField(max_length=100)
    content_attr = models.CharField(max_length=255)
    description = models.TextField(blank=True, default="")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["provider", "name_attr"], name="ver_meta_idx")
        ]

    def __str__(self):
        return f"{self.provider}: {self.name_attr}"


# =====================================================================
# VERIFICATION FILES (SAFE)
# =====================================================================
class VerificationFile(models.Model):
    provider = models.CharField(max_length=50, db_index=True)
    file = models.FileField(upload_to="verification/")
    description = models.TextField(blank=True, default="")
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-uploaded_at"]
        indexes = [
            models.Index(fields=["provider"], name="ver_file_idx")
        ]

    def __str__(self):
        name = getattr(self.file, "name", None)
        return f"{self.provider}: {name or '(invalid file)'}"

    # SAFE VALIDATION
    def clean(self):
        errors = {}

        # extension check
        try:
            ext = Path(self.file.name).suffix.lower()
            if ext not in _ALLOWED_VERIFICATION_EXTENSIONS:
                errors.setdefault("file", []).append(
                    f"Unsupported extension: {ext}"
                )
        except Exception:
            pass

        # size check
        try:
            if self.file.size > _MAX_VERIFICATION_FILE_BYTES:
                errors.setdefault("file", []).append(
                    f"File exceeds {_MAX_VERIFICATION_FILE_BYTES} bytes"
                )
        except Exception:
            pass

        if errors:
            raise ValidationError(errors)

    def save(self, *a, **kw):
        self.full_clean()
        return super().save(*a, **kw)


# =====================================================================
# THROUGH MODELS
# =====================================================================
class SiteSettingsMetaTagLink(models.Model):
    site_settings = models.ForeignKey(
        SiteSettings, on_delete=models.CASCADE, related_name="meta_tag_links"
    )
    meta_tag = models.ForeignKey(
        VerificationMetaTag, on_delete=models.CASCADE, related_name="site_links"
    )
    linked_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("site_settings", "meta_tag")
        indexes = [
            models.Index(fields=["site_settings", "meta_tag"], name="site_meta_link_idx")
        ]


class SiteSettingsVerificationFileLink(models.Model):
    site_settings = models.ForeignKey(
        SiteSettings, on_delete=models.CASCADE, related_name="verification_file_links"
    )
    verification_file = models.ForeignKey(
        VerificationFile, on_delete=models.CASCADE, related_name="site_links"
    )
    linked_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("site_settings", "verification_file")
        indexes = [
            models.Index(fields=["site_settings", "verification_file"], name="site_file_link_idx")
        ]


# =====================================================================
# TENANT SETTINGS
# =====================================================================
class TenantSiteSettings(models.Model):
    site = models.OneToOneField(
        Site, on_delete=models.CASCADE, related_name="tenant_settings"
    )

    theme_profile = models.CharField(max_length=50, blank=True, null=True)
    primary_color = models.CharField(
        max_length=7, blank=True, null=True, validators=[_HEX_COLOR_VALIDATOR]
    )
    secondary_color = models.CharField(
        max_length=7, blank=True, null=True, validators=[_HEX_COLOR_VALIDATOR]
    )

    meta_tags = models.ManyToManyField(VerificationMetaTag, blank=True)
    verification_files = models.ManyToManyField(VerificationFile, blank=True)

    class Meta:
        verbose_name = "Tenant Site Settings"

    def __str__(self):
        return f"Tenant settings for {getattr(self.site, 'domain', 'unknown')}"

    def get_colors(self) -> dict[str, str]:
        return {
            "primary": self.primary_color or "#0d6efd",
            "secondary": self.secondary_color or "#6c757d",
        }


--------------------------------------------
### FILE: apps\site_settings\signals.py
### SIZE: 1371 bytes
### HASH: BD440CF3784FB451F1A6498ACCA760EA6060587D56F7DCB7671F8D125F2FADA4

from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from django.contrib.sites.models import Site
from .models import SiteSettings, VerificationMetaTag, VerificationFile, TenantSiteSettings


def clear_site_settings_cache():
    """
    Invalidate all site settings caches.

    - Per-site caches use 'site_settings_<site_id>'.
    - Called whenever SiteSettings, TenantSiteSettings, or related verification
      resources are saved or deleted.
    """
    try:
        for site_id in Site.objects.values_list("id", flat=True):
            cache.delete(f"site_settings_{site_id}")
    except Exception:
        # During migrations or initial setup, Site table may not exist yet.
        pass


@receiver(post_save, sender=SiteSettings)
@receiver(post_delete, sender=SiteSettings)
@receiver(post_save, sender=VerificationMetaTag)
@receiver(post_delete, sender=VerificationMetaTag)
@receiver(post_save, sender=VerificationFile)
@receiver(post_delete, sender=VerificationFile)
@receiver(post_save, sender=TenantSiteSettings)
@receiver(post_delete, sender=TenantSiteSettings)
def invalidate_site_settings_cache(sender, **kwargs):
    """
    Signal handler to clear cached site settings whenever relevant models change.
    """
    clear_site_settings_cache()

--------------------------------------------
### FILE: apps\site_settings\tests.py
### SIZE: 63 bytes
### HASH: DAE0DA7EFDCDB3A7FB572D5E914B60631099122D4A4727AC6434C016161C5FE1

from django.test import TestCase

# Create your tests here.


--------------------------------------------
### FILE: apps\site_settings\urls.py
### SIZE: 1939 bytes
### HASH: 6C3E7C8FAD3ABB7ACABB17161D524690BD727D4B4DC10192ECCF804F17459E15

"""
apps.site_settings.urls
========================
Unified routing for GSMInfinity Site Settings module.

✓ Django 5.2+ Ready
✓ Namespaced under `site_settings`
✓ Safe, cache-friendly routing
✓ Aligned with actual available view functions
✓ No duplication, no dead routes
"""

from django.urls import path
from . import views


app_name = "site_settings"


urlpatterns = [
    # ---------------------------------------------------------------------
    # 🌐 Public Diagnostic / Admin-facing HTML View
    # ---------------------------------------------------------------------
    path(
        "",
        views.site_settings_view,
        name="site_settings",
    ),  # Admin diagnostic readable settings page

    # ---------------------------------------------------------------------
    # 🔧 JSON API for Frontend Bootstrapping
    # ---------------------------------------------------------------------
    path(
        "info/",
        views.settings_info,
        name="settings_info",
    ),

    # ---------------------------------------------------------------------
    # 🔐 Domain Verification Files (Google / Apple / Facebook)
    # ---------------------------------------------------------------------
    path(
        "verification/<str:filename>/",
        views.verification_file,
        name="verification_file",
    ),

    # ---------------------------------------------------------------------
    # 📜 Public Policy & Legal Pages (GDPR Compliant)
    # ---------------------------------------------------------------------
    path(
        "privacy/",
        views.privacy_policy,
        name="privacy_policy",
    ),

    path(
        "terms/",
        views.terms_of_service,
        name="terms_of_service",
    ),

    path(
        "cookies/",
        views.cookies_policy,
        name="cookies_policy",
    ),
]


--------------------------------------------
### FILE: apps\site_settings\views.py
### SIZE: 10982 bytes
### HASH: 90260E94FE497D355C47609E53355572B8845F2A9A885B646093771D58A6C14A

"""
apps.site_settings.views
========================
Enterprise-grade Views for GSMInfinity Site & Tenant Settings.

✓ Django 5.2+ / Python 3.12+
✓ Zero deprecated APIs
✓ Stable, import-safe, drop-in replacement
✓ Tenant-aware settings resolution
✓ Safe verification file serving
✓ JSON bootstrap for frontend
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, Dict, Optional

from django.shortcuts import render, redirect
from django.http import JsonResponse, Http404, HttpRequest, HttpResponse
from django.contrib.sites.shortcuts import get_current_site
from django.core.cache import cache
from django.views.decorators.cache import cache_page
from django.views.decorators.http import require_GET
from django.views.decorators.vary import vary_on_headers
from django.utils.functional import SimpleLazyObject

from .models import SiteSettings, TenantSiteSettings

log = logging.getLogger(__name__)


# =====================================================================================
# INTERNAL: SETTINGS SNAPSHOT SERIALIZER (stable & safe)
# =====================================================================================

def _settings_snapshot(obj: Any) -> Dict[str, Any]:
    """
    Convert a SiteSettings or TenantSiteSettings instance into a pure dict.
    Completely defensive → never throws exceptions.
    """
    try:
        payload = {
            "site_name": getattr(obj, "site_name", "GSMInfinity"),
            "site_header": getattr(obj, "site_header", ""),
            "site_description": getattr(obj, "site_description", ""),
            "enable_signup": bool(getattr(obj, "enable_signup", True)),
            "enable_password_reset": bool(getattr(obj, "enable_password_reset", True)),
            "recaptcha_enabled": bool(getattr(obj, "recaptcha_enabled", False)),
            "require_mfa": bool(getattr(obj, "require_mfa", False)),
            "max_login_attempts": int(getattr(obj, "max_login_attempts", 5)),
            "rate_limit_window_seconds": int(
                getattr(obj, "rate_limit_window_seconds", 300)
            ),
            "meta_tags": [],
            "verification_files": [],
        }

        # -------------------------
        # META TAGS
        # -------------------------
        meta = getattr(obj, "meta_tags", None)
        if meta:
            try:
                if hasattr(meta, "values"):
                    payload["meta_tags"] = list(meta.values("name", "content"))
                else:
                    payload["meta_tags"] = [
                        {"name": getattr(m, "name", ""), "content": getattr(m, "content", "")}
                        for m in meta
                    ]
            except Exception:
                log.debug("Meta tag serialization failed", exc_info=True)

        # -------------------------
        # VERIFICATION FILES
        # -------------------------
        vfiles = getattr(obj, "verification_files", None)
        if vfiles:
            try:
                if hasattr(vfiles, "values"):
                    payload["verification_files"] = list(vfiles.values("id", "file"))
                else:
                    out = []
                    for vf in vfiles:
                        f = getattr(vf, "file", None)
                        out.append(
                            {
                                "id": getattr(vf, "id", None),
                                "file": getattr(f, "name", None),
                                "url": getattr(f, "url", None),
                            }
                        )
                    payload["verification_files"] = out
            except Exception:
                log.debug("Verification file serialization failed", exc_info=True)

        return payload

    except Exception as exc:
        log.exception("settings_snapshot fallback triggered: %s", exc)
        return {
            "site_name": "GSMInfinity",
            "site_header": "",
            "site_description": "",
            "enable_signup": True,
            "enable_password_reset": True,
            "recaptcha_enabled": False,
            "require_mfa": False,
            "max_login_attempts": 5,
            "rate_limit_window_seconds": 300,
            "meta_tags": [],
            "verification_files": [],
        }


# =====================================================================================
# INTERNAL: TENANT-AWARE SETTINGS RESOLVER (stable)
# =====================================================================================

def _get_settings(request: Optional[HttpRequest] = None) -> Dict[str, Any]:
    """
    Return final effective settings (tenant → global).
    Fully defensive: never raises, always returns stable dict.
    """

    try:
        if request:
            try:
                domain = get_current_site(request).domain
            except Exception:
                domain = request.get_host()
        else:
            domain = "global"

        cache_key = f"active_site_settings::{domain}"
        cached = cache.get(cache_key)
        if cached:
            return cached

        obj = None

        # Tenant overrides (if available)
        if request:
            try:
                site = get_current_site(request)
                obj = (
                    TenantSiteSettings.objects.select_related("site")
                    .prefetch_related("meta_tags", "verification_files")
                    .filter(site=site)
                    .first()
                )
            except Exception:
                obj = None

        # Global fallback
        if obj is None:
            try:
                obj = SiteSettings.get_solo()
            except Exception:
                obj = None

        snapshot = _settings_snapshot(obj)
        cache.set(cache_key, snapshot, timeout=300)
        return snapshot

    except Exception as exc:
        log.exception("_get_settings FAIL: %s", exc)
        fallback = _settings_snapshot(object())
        cache.set("active_site_settings::fallback", fallback, timeout=60)
        return fallback


# =====================================================================================
# PUBLIC JSON API
# =====================================================================================

@require_GET
@vary_on_headers("Host")
@cache_page(60)
def settings_info(request: HttpRequest) -> JsonResponse:
    """Return JSON bootstrap settings for frontend."""
    s = _get_settings(request)

    try:
        domain = get_current_site(request).domain
    except Exception:
        domain = request.get_host()

    return JsonResponse(
        {
            "site_name": s.get("site_name", "GSMInfinity"),
            "site_header": s.get("site_header", ""),
            "site_description": s.get("site_description", ""),
            "site_domain": domain,
            "enable_signup": s.get("enable_signup", True),
            "enable_password_reset": s.get("enable_password_reset", True),
            "recaptcha_enabled": s.get("recaptcha_enabled", False),
            "require_mfa": s.get("require_mfa", False),
            "max_login_attempts": s.get("max_login_attempts", 5),
            "rate_limit_window_seconds": s.get("rate_limit_window_seconds", 300),
        },
        json_dumps_params={"indent": 2},
    )

# ⭐⭐⭐ CRITICAL: URL COMPATIBILITY ALIAS ⭐⭐⭐
# Your project references views.info → so we alias it.
info = settings_info


# =====================================================================================
# ADMIN DIAGNOSTIC VIEW
# =====================================================================================

@require_GET
@vary_on_headers("Host")
@cache_page(300)
def site_settings_view(request: HttpRequest) -> HttpResponse:
    """Visible to staff/admin only — shows full active settings."""
    s = SimpleLazyObject(lambda: _get_settings(request))
    return render(
        request,
        "site_settings/detail.html",
        {
            "site_settings": s,
            "meta_tags": s.get("meta_tags", []),
            "verification_files": s.get("verification_files", []),
        },
    )


# =====================================================================================
# PUBLIC — POLICY PAGES
# =====================================================================================

@require_GET
@vary_on_headers("Host")
@cache_page(600)
def privacy_policy(request: HttpRequest) -> HttpResponse:
    return render(
        request,
        "site_settings/privacy.html",
        {"site_settings": _get_settings(request)},
    )


@require_GET
@vary_on_headers("Host")
@cache_page(600)
def terms_of_service(request: HttpRequest) -> HttpResponse:
    return render(
        request,
        "site_settings/terms.html",
        {"site_settings": _get_settings(request)},
    )


@require_GET
@vary_on_headers("Host")
@cache_page(600)
def cookies_policy(request: HttpRequest) -> HttpResponse:
    """Cookies policy view — commonly used from consent app."""
    return render(
        request,
        "site_settings/cookies.html",
        {"site_settings": _get_settings(request)},
    )


# =====================================================================================
# PUBLIC — VERIFICATION FILE SERVING
# =====================================================================================

@require_GET
def verification_file(request: HttpRequest, filename: str) -> HttpResponse:
    """
    Serve Google/Facebook/Apple domain verification files safely.

    Ensures:
    - no directory traversal
    - only .txt / .html allowed
    - tenant overrides supported
    - secure redirect to storage URL
    """

    safe = Path(filename).name  # prevent traversal
    allowed_ext = {".html", ".txt"}

    s = _get_settings(request)
    vfiles = s.get("verification_files", [])

    match = None

    for entry in vfiles:
        try:
            if isinstance(entry, dict):
                name = (entry.get("file") or "").lower()
                url = entry.get("url")
            else:
                name = str(entry).lower()
                url = None

            if name.endswith(safe.lower()):
                match = {"name": name, "url": url}
                break

        except Exception:
            continue

    if not match:
        raise Http404("Verification file not found")

    if not any(match["name"].endswith(ext) for ext in allowed_ext):
        raise Http404("Invalid verification file type")

    if match.get("url"):
        return redirect(match["url"])

    raise Http404("Verification file has no storage URL")


--------------------------------------------
### FILE: apps\users\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\users\adapters.py
### SIZE: 10149 bytes
### HASH: 64E20358D521EC382EF56D25E55BFD487FB7E1329B65059BB9AD26E9B28D34C5

"""
Enterprise-grade Account & Social Adapters for GSMInfinity
----------------------------------------------------------

✓ Django 5.2 • Python 3.12
✓ django-allauth ≥ 0.65
✓ Strong password rules (non-duplicating)
✓ All verification & redirect flows hardened
✓ Zero silent failures — all exceptions logged
✓ Fully resilient to missing DB / migrations
✓ Fully safe URL reversing and provider linking
"""

from __future__ import annotations

import logging
from typing import Optional, Any

from django.core.exceptions import ValidationError, MultipleObjectsReturned
from django.urls import reverse, NoReverseMatch
from django.contrib.auth import get_user_model
from django.contrib import messages
from django.http import HttpRequest
from django.utils.translation import gettext_lazy as _

from allauth.account.adapter import DefaultAccountAdapter
from allauth.socialaccount.adapter import DefaultSocialAccountAdapter

# Lazy optional import (MUST NOT break adapters on cold start)
try:
    from apps.site_settings.models import SiteSettings  # type: ignore
except Exception:
    SiteSettings = None  # graceful fallback for pending migrations / missing table

logger = logging.getLogger(__name__)


# ======================================================================
# SAFE URL REVERSER — never throws
# ======================================================================
def _safe_reverse(name: str, default: str = "/") -> str:
    """
    Reverse URLs safely.
    If route missing → return fallback → never break login/signup flows.
    """
    try:
        return reverse(name)
    except NoReverseMatch:
        logger.warning("reverse(%s) failed — fallback=%s", name, default)
        return default
    except Exception as exc:
        logger.exception("reverse(%s) unexpected error: %s", name, exc)
        return default


# ======================================================================
# ACCOUNT ADAPTER
# ======================================================================
class CustomAccountAdapter(DefaultAccountAdapter):
    """
    Hardened Account Adapter:
    - SiteSettings.enable_signup logic
    - Strong lightweight password validation
    - Verified email redirect workflow
    - Fail-open defaults to avoid auth-blocking
    """

    # --------------------------------------------------------------
    # SIGNUP PERMISSION: SiteSettings.enable_signup
    # --------------------------------------------------------------
    def is_open_for_signup(self, request: Optional[HttpRequest]) -> bool:
        try:
            if SiteSettings and hasattr(SiteSettings, "get_solo"):
                settings_obj = SiteSettings.get_solo()
                allowed = bool(getattr(settings_obj, "enable_signup", True))
                logger.debug("Signup allowed? %s", allowed)
                return allowed
        except Exception as exc:
            logger.warning(
                "Signup availability check failed (SiteSettings unavailable): %s", exc
            )

        return True  # Safe default (never lock out users)

    # --------------------------------------------------------------
    # PASSWORD VALIDATION — minimal enterprise standard
    # --------------------------------------------------------------
    def clean_password(self, password: str, user: Optional[Any] = None) -> str:
        if not isinstance(password, str):
            raise ValidationError(_("Invalid password format."))

        if len(password) < 8:
            raise ValidationError(_("Password must be at least 8 characters long."))

        if password.isdigit():
            raise ValidationError(_("Password cannot be entirely numeric."))

        return super().clean_password(password, user)

    # --------------------------------------------------------------
    # LOGIN REDIRECT — requires email verification
    # --------------------------------------------------------------
    def get_login_redirect_url(self, request: HttpRequest) -> str:
        try:
            user = getattr(request, "user", None)

            # CustomUser has email_verified_at datetime
            if user and getattr(user, "email_verified_at", None) is None:
                try:
                    messages.info(request, _("Please verify your email to continue."))
                except Exception:
                    pass

                return _safe_reverse("users:verify_email", default="/")
        except Exception as exc:
            logger.exception("Login redirect evaluation failed: %s", exc)

        return _safe_reverse("users:dashboard", default="/")

    # --------------------------------------------------------------
    # SIGNUP REDIRECT — onboarding
    # --------------------------------------------------------------
    def get_signup_redirect_url(self, request: HttpRequest) -> str:
        return _safe_reverse("users:profile", default="/")


# ======================================================================
# SOCIAL ACCOUNT ADAPTER
# ======================================================================
class CustomSocialAccountAdapter(DefaultSocialAccountAdapter):
    """
    Hardened social adapter:
    - Intelligent safe email auto-linking
    - Never overwrites existing social connections
    - Flow NEVER breaks — errors logged but silent to user
    - Everything runs in strict defensive patterns
    """

    # --------------------------------------------------------------
    # SOCIAL CONNECT REDIRECT
    # --------------------------------------------------------------
    def get_connect_redirect_url(self, request: HttpRequest, socialaccount) -> str:
        logger.debug(
            "Social connect redirect (provider=%s)",
            getattr(socialaccount, "provider", None),
        )
        return _safe_reverse("users:profile", default="/")

    # --------------------------------------------------------------
    # SOCIAL SIGNUP REDIRECT
    # --------------------------------------------------------------
    def get_signup_redirect_url(self, request: HttpRequest) -> str:
        logger.debug("Social signup redirect → users:profile")
        return _safe_reverse("users:profile", default="/")

    # --------------------------------------------------------------
    # PRE-SOCIAL-LOGIN — AUTO-LINKING
    # --------------------------------------------------------------
    def pre_social_login(self, request: HttpRequest, sociallogin) -> None:
        """
        Automatic email-based user linking.

        Guarantees:
        - never raises errors to user
        - never interrupts login/signup flow
        - never overwrites existing links
        - logs all events for security visibility
        """
        try:
            # ------------------------------------------------------
            # Extract email robustly
            # ------------------------------------------------------
            email = None
            sl_user = getattr(sociallogin, "user", None)

            if sl_user and getattr(sl_user, "email", None):
                email = sl_user.email
            else:
                # Some providers put email in varied keys
                extra = getattr(getattr(sociallogin, "account", None), "extra_data", {}) or {}
                email = (
                    extra.get("email")
                    or extra.get("email_address")
                    or extra.get("emailAddress")
                )

            if not email:
                logger.debug("pre_social_login: No email found in social payload.")
                return

            email_norm = email.strip().lower()
            User = get_user_model()

            # ------------------------------------------------------
            # Query by email (safe)
            # ------------------------------------------------------
            try:
                existing_user = User.objects.filter(email__iexact=email_norm).first()
            except MultipleObjectsReturned:
                logger.warning(
                    "pre_social_login: Multiple users share email=%s — cannot auto-link.",
                    email_norm,
                )
                return
            except Exception as exc:
                logger.exception(
                    "pre_social_login: Error querying email=%s: %s",
                    email_norm,
                    exc,
                )
                return

            if not existing_user:
                logger.debug("pre_social_login: Email=%s not associated with any user.", email_norm)
                return

            # ------------------------------------------------------
            # Do not override existing social link
            # ------------------------------------------------------
            if getattr(sociallogin, "is_existing", False):
                logger.debug(
                    "pre_social_login: Existing social link detected for email=%s — skip.",
                    email_norm,
                )
                return

            # ------------------------------------------------------
            # Perform auto-link
            # ------------------------------------------------------
            try:
                sociallogin.connect(request, existing_user)
                logger.info(
                    "Successfully auto-linked email=%s to user_id=%s",
                    email_norm,
                    existing_user.pk,
                )
            except Exception as exc:
                logger.exception(
                    "pre_social_login: Failed to auto-link email=%s: %s",
                    email_norm,
                    exc,
                )
                return

        except Exception as exc:
            # Absolute safety guarantee — flow NEVER breaks
            logger.exception("pre_social_login fatal error: %s", exc)
            return


--------------------------------------------
### FILE: apps\users\admin.py
### SIZE: 11531 bytes
### HASH: FB1E69F54D3D7D7E3CAAC05944E6F9D5E9B98BAB4DEF5187FA7EDF4C8575A174

# apps/users/admin.py
"""
apps.users.admin
================
Enterprise admin interfaces for user-related models in GSMInfinity.

Features:
- Robust CustomUser admin
- Inline DeviceFingerprint management (read-only)
- Notification + Announcement dashboards
- Bulk admin actions
- Export support (import_export) when installed
- Does NOT break when import_export is absent
- ZERO silent errors
- Django 5.x compatible

IMPORTANT FIX:
--------------
ExportMixin **does not subclass ModelAdmin**, so we must ALWAYS
wrap it inside a ModelAdmin subclass to avoid:

    ValueError: Wrapped class must subclass ModelAdmin.

This file includes a safe BaseAdminClass that prevents the crash
while preserving your export features.
"""

from __future__ import annotations

import logging
from typing import Optional, Iterable

from django.contrib import admin, messages
from django.http import HttpRequest
from django.utils.translation import gettext_lazy as _
from django.db.models import QuerySet

logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------
# Optional import_export integration — fixed so it never breaks admin
# --------------------------------------------------------------------------
try:
    from import_export.admin import ExportMixin  # type: ignore
    _HAS_IMPORT_EXPORT = True
except Exception:
    ExportMixin = None
    _HAS_IMPORT_EXPORT = False


# --------------------------------------------------------------------------
# MODELS (exactly as present in your models.py)
# --------------------------------------------------------------------------
from .models import (
    CustomUser,
    DeviceFingerprint,
    Notification,
    Announcement,
)


# ==========================================================================
# FIXED BASE ADMIN CLASS
# ==========================================================================
"""
Your earlier file used `BaseAdminClass = ExportMixin`, which FAILS because
ExportMixin does NOT inherit from admin.ModelAdmin.

THE FIX:
    If import_export is available:
        class BaseAdminClass(ExportMixin, admin.ModelAdmin)
    else:
        class BaseAdminClass(admin.ModelAdmin)

This guarantees that @admin.register(...) always receives a ModelAdmin subclass.
"""

if _HAS_IMPORT_EXPORT and ExportMixin:
    class BaseAdminClass(ExportMixin, admin.ModelAdmin):
        """Safe hybrid admin class."""
        pass
else:
    class BaseAdminClass(admin.ModelAdmin):
        """Fallback admin when import_export is not installed."""
        pass


# ==========================================================================
# DeviceFingerprint Inline (read-only)
# ==========================================================================
class DeviceFingerprintInline(admin.TabularInline):
    """Read-only inline for a user's registered device fingerprints."""

    model = DeviceFingerprint
    extra = 0
    can_delete = False
    show_change_link = True
    ordering = ("-last_used_at",)

    readonly_fields = (
        "fingerprint_hash",
        "os_info",
        "browser_info",
        "motherboard_id",
        "registered_at",
        "last_used_at",
        "is_active",
    )
    fields = readonly_fields

    verbose_name = _("Registered Device")
    verbose_name_plural = _("Registered Devices")

    def has_add_permission(self, request: HttpRequest, obj=None) -> bool:
        return False


# ==========================================================================
# CustomUser Admin
# ==========================================================================
@admin.register(CustomUser)
class CustomUserAdmin(BaseAdminClass):
    """Enterprise-grade admin for CustomUser."""

    list_display = (
        "email",
        "username",
        "full_name",
        "is_active",
        "is_staff",
        "is_superuser",
        "credits",
        "signup_method",
        "date_joined",
    )

    search_fields = (
        "email",
        "username",
        "full_name",
        "phone",
        "referral_code",
    )

    list_filter = (
        "is_active",
        "is_staff",
        "is_superuser",
        "signup_method",
    )

    readonly_fields = (
        "referral_code",
        "date_joined",
        "email_verified_at",
        "last_unlock",
    )

    ordering = ("-date_joined",)
    inlines = [DeviceFingerprintInline]
    save_on_top = True

    list_select_related = ()

    fieldsets = (
        (_("Authentication"), {"fields": ("email", "username", "password")}),
        (_("Personal Info"), {"fields": ("full_name", "phone", "referral_code")}),
        (_("Permissions"), {
            "fields": (
                "is_active",
                "is_staff",
                "is_superuser",
                "groups",
                "user_permissions",
            )
        }),
        (_("Additional Info"), {
            "fields": (
                "credits",
                "signup_method",
                "email_verified_at",
                "last_unlock",
                "date_joined",
            )
        }),
    )

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        qs = super().get_queryset(request)
        try:
            return qs.prefetch_related("groups")
        except Exception:
            logger.debug("CustomUserAdmin.get_queryset prefetch failed", exc_info=True)
            return qs


# ==========================================================================
# DeviceFingerprint Admin
# ==========================================================================
@admin.register(DeviceFingerprint)
class DeviceFingerprintAdmin(BaseAdminClass):
    """Admin interface for device fingerprints."""

    list_display = (
        "user_display",
        "fingerprint_hash_short",
        "os_info",
        "browser_info",
        "last_used_at",
        "is_active",
    )

    list_filter = ("is_active", "os_info", "browser_info")

    search_fields = (
        "fingerprint_hash",
        "user__email",
        "user__username",
        "browser_info",
    )

    readonly_fields = ("registered_at", "last_used_at")
    ordering = ("-last_used_at",)
    list_select_related = ("user",)

    save_on_top = True

    @admin.display(description=_("User"))
    def user_display(self, obj: DeviceFingerprint) -> str:
        return getattr(obj.user, "email", None) or getattr(obj.user, "username", None) or f"User #{obj.user_id}"

    @admin.display(description=_("Fingerprint"))
    def fingerprint_hash_short(self, obj: DeviceFingerprint) -> str:
        if not obj.fingerprint_hash:
            return "—"
        return f"{obj.fingerprint_hash[:16]}…"


# ==========================================================================
# Notification Admin
# ==========================================================================
@admin.register(Notification)
class NotificationAdmin(BaseAdminClass):
    """Admin interface for Notifications."""

    list_display = (
        "recipient_display",
        "title",
        "priority",
        "channel",
        "is_read",
        "created_at",
        "read_at",
    )

    list_filter = ("priority", "channel", "is_read", "created_at")
    search_fields = ("title", "message", "recipient__email", "recipient__username")
    ordering = ("-created_at",)
    readonly_fields = ("created_at", "read_at")
    list_select_related = ("recipient",)
    save_on_top = True

    actions = ["mark_selected_read"]

    if _HAS_IMPORT_EXPORT:
        actions.append("export_selected_as_csv")

    @admin.display(description=_("Recipient"))
    def recipient_display(self, obj: Notification) -> str:
        return getattr(obj.recipient, "email", None) or getattr(obj.recipient, "username", None) or "Anonymous"

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        qs = super().get_queryset(request)
        try:
            return qs.select_related("recipient")
        except Exception:
            logger.debug("NotificationAdmin.get_queryset failed", exc_info=True)
            return qs

    def mark_selected_read(self, request: HttpRequest, queryset: QuerySet):
        try:
            updated = queryset.filter(is_read=False).update(is_read=True)
            self.message_user(request, _("%d notifications marked as read.") % updated)
        except Exception as exc:
            logger.exception("Failed to mark notifications read: %s", exc)
            self.message_user(request, _("Failed to mark notifications as read."), level=messages.ERROR)

    def export_selected_as_csv(self, request: HttpRequest, queryset: QuerySet):
        self.message_user(request, _("Use the Export button above to export notifications."))


# ==========================================================================
# Announcement Admin
# ==========================================================================
@admin.register(Announcement)
class AnnouncementAdmin(BaseAdminClass):
    """Admin for announcements."""

    list_display = (
        "title",
        "audience",
        "is_global",
        "created_by_display",
        "start_at",
        "expires_at",
        "is_active_display",
    )

    search_fields = ("title", "message")
    list_filter = ("audience", "is_global", "expires_at")
    readonly_fields = ("created_by",)
    ordering = ("-start_at",)
    save_on_top = True
    actions = ["publish_selected", "unpublish_selected"]

    def save_model(self, request, obj, form, change):
        if not change and not obj.created_by:
            obj.created_by = request.user
        super().save_model(request, obj, form, change)

    @admin.display(description=_("Created By"))
    def created_by_display(self, obj: Announcement):
        return getattr(obj.created_by, "email", None) or getattr(obj.created_by, "username", None) or "—"

    @admin.display(description=_("Active?"))
    def is_active_display(self, obj: Announcement):
        try:
            return "✅" if obj.is_active else "❌"
        except Exception:
            return "—"

    def publish_selected(self, request, queryset):
        try:
            count = queryset.update(is_active=True)
            self.message_user(request, _("%d announcements published.") % count)
        except Exception:
            logger.exception("Failed to publish announcements")
            self.message_user(request, _("Failed to publish announcements."), level=messages.ERROR)

    def unpublish_selected(self, request, queryset):
        try:
            count = queryset.update(is_active=False)
            self.message_user(request, _("%d announcements unpublished.") % count)
        except Exception:
            logger.exception("Failed to unpublish announcements")
            self.message_user(request, _("Failed to unpublish announcements."), level=messages.ERROR)


# ==========================================================================
# Admin Branding
# ==========================================================================
admin.site.site_header = _("GSMInfinity Administration")
admin.site.index_title = _("Enterprise Control Panel")
admin.site.site_title = _("GSMInfinity Admin Portal")


--------------------------------------------
### FILE: apps\users\apps.py
### SIZE: 3122 bytes
### HASH: 1EE63071565F4BCAD56C082B4CF8BBD9813F5C0FBF1DD7DAB0707498715B1AEA

"""
apps.users.apps
================
Application configuration for GSMInfinity's Users module.

✅ Responsibilities:
- Auto-register user signals (login, signup, profile creation)
- Integrate cleanly with django-allauth adapters/forms
- Async-safe startup; ORM import-guarded
- Autodiscover any "signals" submodules across installed apps
- Zero deprecations for Django 5.2 LTS + allauth 0.65.13
"""

from __future__ import annotations

import logging
from django.apps import AppConfig
from django.utils.module_loading import autodiscover_modules


class UsersConfig(AppConfig):
    """
    Enterprise-grade AppConfig for user management.

    Loads signals and cross-app hooks exactly once per process.
    Safe during migrations, tests, shell, or async contexts.
    """
    default_auto_field = "django.db.models.BigAutoField"
    name = "apps.users"
    label = "users"
    verbose_name = "User Management"

    def ready(self) -> None:
        """
        Initialization hook executed when Django finishes app loading.

        Tasks performed:
        1️⃣  Import this app's local signals safely.
        2️⃣  Autodiscover any `signals.py` modules across installed apps.
        3️⃣  Provide extension hook for future warm-ups or audits.
        """
        logger = logging.getLogger(__name__)

        # ---------------------------------------------------------------
        # 1️⃣ Import local signal handlers (safe guarded)
        # ---------------------------------------------------------------
        try:
            import apps.users.signals  # noqa: F401
            logger.debug("UsersConfig → signals imported successfully.")
        except ImportError as exc:
            # Signal import errors should never break app startup.
            logger.warning("UsersConfig: unable to import signals (%s)", exc)
        except Exception as exc:
            logger.exception("UsersConfig: unexpected error loading signals → %s", exc)

        # ---------------------------------------------------------------
        # 2️⃣ Autodiscover cross-app signal modules (optional)
        # ---------------------------------------------------------------
        try:
            autodiscover_modules("signals")
            logger.debug("UsersConfig → autodiscovered 'signals' modules across apps.")
        except Exception as exc:
            # Do not fail on autodiscovery — some apps may not have signals.
            logger.debug("UsersConfig: autodiscover_modules('signals') failed → %s", exc)

        # ---------------------------------------------------------------
        # 3️⃣ Future-proof extension hook (keep light)
        # ---------------------------------------------------------------
        # Example future tasks:
        #   - Warm up cache for active devices
        #   - Schedule initial audit tasks
        #   - Load feature-flag toggles
        #
        # Must remain non-blocking and ORM-safe.
        logger.debug("UsersConfig.ready() completed successfully.")
        return


--------------------------------------------
### FILE: apps\users\auth_backends.py
### SIZE: 4876 bytes
### HASH: 00FCD1265DE98652EDD2276E386678929C168C8D13CDC1B2A06DBDA3F37D2CCF

# apps/users/auth_backends.py
"""
Enterprise-grade multi-identifier authentication backend for GSMInfinity.

✅ Login via email, username, or phone (case-insensitive)
✅ Compatible with django-allauth and Django admin
✅ Safe against enumeration and timing leaks
✅ RFC 7613 Unicode normalization (casefold)
✅ Structured logging and exception safety
✅ Lazy model resolution to avoid import-time circulars
"""

from __future__ import annotations

import logging
from typing import Optional, Any, Sequence

from django.contrib.auth.backends import ModelBackend
from django.contrib.auth import get_user_model
from django.db.models import Q
from django.core.exceptions import MultipleObjectsReturned

logger = logging.getLogger(__name__)


class MultiFieldAuthBackend(ModelBackend):
    """
    Authenticate users by email, username, or phone number.

    Compatible with Django admin, django-allauth, and session auth.
    """

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    @staticmethod
    def _normalize_identifier(identifier: str) -> str:
        """
        Normalize user identifier to lowercase and strip whitespace.

        Uses str.casefold() for Unicode-safe comparisons (RFC 7613).
        """
        return str(identifier or "").strip().casefold()

    # ------------------------------------------------------------------
    # Authentication
    # ------------------------------------------------------------------
    def authenticate(
        self,
        request=None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs,
    ) -> Optional[Any]:
        """
        Authenticate using email, username, or phone.
        Returns user instance or None.
        """
        if not username or password is None:
            logger.debug("Authentication attempt missing credentials.")
            return None

        identifier = self._normalize_identifier(username)
        UserModel = get_user_model()
        user = None

        try:
            # Filter by any accepted identifier (case-insensitive)
            qs = (
                UserModel.objects.filter(
                    Q(email__iexact=identifier)
                    | Q(username__iexact=identifier)
                    | Q(phone__iexact=identifier)
                )
                .distinct()
            )

            # Load at most two rows to detect duplicates cheaply
            candidates: Sequence[UserModel] = list(qs[:2])

            if not candidates:
                # Perform dummy hash work to equalize timing and mitigate enumeration
                try:
                    dummy = UserModel()
                    dummy.set_password(password)
                    dummy.check_password(password)
                except Exception:
                    # best-effort only; never raise
                    pass
                logger.debug("No user found for identifier=%s", identifier)
                return None

            if len(candidates) > 1:
                logger.warning("Multiple accounts share identifier=%s", identifier)

            user = candidates[0]

        except MultipleObjectsReturned:
            logger.warning("Duplicate users detected for identifier=%s", identifier)
            return None
        except Exception as exc:
            logger.exception("User lookup failed for identifier=%s → %s", identifier, exc)
            return None

        # Verify password in timing-safe manner
        try:
            if user and user.check_password(password) and self.user_can_authenticate(user):
                logger.info("User %s authenticated successfully", getattr(user, "email", user.pk))
                return user
            else:
                logger.debug("Invalid credentials or inactive account for %s", identifier)
        except Exception as exc:
            logger.exception("Password verification failed for %s → %s", identifier, exc)

        return None

    # ------------------------------------------------------------------
    # User Retrieval
    # ------------------------------------------------------------------
    def get_user(self, user_id: Any) -> Optional[Any]:
        """
        Retrieve user safely for session authentication.
        """
        UserModel = get_user_model()
        try:
            return UserModel.objects.get(pk=user_id)
        except UserModel.DoesNotExist:
            logger.debug("get_user: User not found id=%s", user_id)
            return None
        except Exception as exc:
            logger.exception("get_user failed for id=%s → %s", user_id, exc)
            return None


--------------------------------------------
### FILE: apps\users\backends.py
### SIZE: 467 bytes
### HASH: 8FFB2E8F635DAFF8ACA1C21C25329C3CF5E3C411A7AB228D67689062FB43FD07

"""
apps.users.backends
-------------------
Import shim for backward and settings compatibility.
Delegates to apps.users.auth_backends.MultiFieldAuthBackend.
"""

from __future__ import annotations
from importlib import import_module
import sys

module = import_module("apps.users.auth_backends")

# expose all public names (safe passthrough)
globals().update(module.__dict__)

# ensure dotted-path import consistency
sys.modules[__name__] = module


--------------------------------------------
### FILE: apps\users\context_processors.py
### SIZE: 184 bytes
### HASH: 74D3624DBB821AE2E326D679A5BB9578E4842F10D93969C0792B4517A3985F16

# Keep users-specific processors minimal; site settings are injected via site_settings app.
def user_context(request):
    return {"is_authenticated":request.user.is_authenticated}


--------------------------------------------
### FILE: apps\users\forms.py
### SIZE: 6285 bytes
### HASH: 9AD7AA6990E72A3BE6C98B4A53E9B1A94C0BD2CF695ED6FE645AE26E5F9C3F0C

"""
GSMInfinity – Custom Allauth Signup Form
----------------------------------------
✅ Compatible with django-allauth ≥ 0.65.13 and Django 5.2 LTS
✅ Prevents circular imports during startup
✅ Implements required `signup(self, request, user)` API
✅ Enforces enterprise-grade validation and password policy
"""

from __future__ import annotations

import logging
from typing import Any
from django import forms
from django.contrib.auth import get_user_model, password_validation
from django.core.exceptions import ValidationError
from django.utils.translation import gettext_lazy as _
from django.utils.module_loading import import_string

logger = logging.getLogger(__name__)
User = get_user_model()


class CustomSignupForm(forms.Form):
    """
    Enterprise-grade wrapper around django-allauth’s signup system.
    Lazy-loads allauth internals only when required to avoid circular imports.
    """

    # ------------------------------------------------------------------
    # Fields
    # ------------------------------------------------------------------
    email = forms.EmailField(
        max_length=255,
        label=_("Email address"),
        widget=forms.EmailInput(
            attrs={
                "autocomplete": "email",
                "placeholder": _("Email"),
                "class": "form-control",
            }
        ),
    )

    username = forms.CharField(
        max_length=150,
        label=_("Username"),
        widget=forms.TextInput(
            attrs={
                "autocomplete": "username",
                "placeholder": _("Username"),
                "class": "form-control",
            }
        ),
    )

    password1 = forms.CharField(
        label=_("Password"),
        strip=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Password"),
                "class": "form-control",
            }
        ),
    )

    password2 = forms.CharField(
        label=_("Confirm password"),
        strip=False,
        widget=forms.PasswordInput(
            attrs={
                "autocomplete": "new-password",
                "placeholder": _("Confirm password"),
                "class": "form-control",
            }
        ),
    )

    # ------------------------------------------------------------------
    # Lazy import of base allauth SignupForm
    # ------------------------------------------------------------------
    @property
    def base_form_class(self):
        """Load django-allauth’s internal SignupForm lazily."""
        return import_string("allauth.account.forms.SignupForm")

    # ------------------------------------------------------------------
    # Field-level validation
    # ------------------------------------------------------------------
    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip().casefold()
        if not email or "@" not in email:
            raise ValidationError(_("Enter a valid email address."))
        if User.objects.filter(email__iexact=email).exists():
            raise ValidationError(_("A user with this email already exists."))
        return email

    def clean_username(self) -> str:
        username = (self.cleaned_data.get("username") or "").strip()
        if len(username) < 3:
            raise ValidationError(_("Username must be at least 3 characters long."))
        if User.objects.filter(username__iexact=username).exists():
            raise ValidationError(_("This username is already taken."))
        return username

    def clean_password1(self) -> str:
        password = self.cleaned_data.get("password1") or ""
        if len(password) < 8:
            raise ValidationError(_("Password must be at least 8 characters long."))
        # Use Django’s configured password validators (settings.AUTH_PASSWORD_VALIDATORS)
        try:
            password_validation.validate_password(password)
        except ValidationError as e:
            raise ValidationError(e.messages)
        return password

    def clean(self) -> dict[str, Any]:
        cleaned = super().clean()
        pwd1, pwd2 = cleaned.get("password1"), cleaned.get("password2")
        if pwd1 and pwd2 and pwd1 != pwd2:
            raise ValidationError(_("Passwords do not match."))
        return cleaned

    # ------------------------------------------------------------------
    # Required by django-allauth ≥ 0.65
    # ------------------------------------------------------------------
    def signup(self, request, user):
        """
        Called automatically by allauth after successful form validation.
        Populates and saves the user instance using GSMInfinity logic.
        """
        user.username = self.cleaned_data.get("username")
        user.email = self.cleaned_data.get("email")

        # Generate a verification code if supported
        if hasattr(user, "generate_verification_code"):
            try:
                user.verification_code = user.generate_verification_code()
                logger.debug("Generated verification code for %s", user.email)
            except Exception as exc:
                logger.warning("Verification code generation failed for %s: %s", user.email, exc)

        # Set password (hashing handled by Django)
        password = self.cleaned_data.get("password1")
        user.set_password(password)

        # Initial defaults
        if hasattr(user, "is_active") and user.is_active is False:
            user.is_active = True

        user.save()
        logger.info("New user created via signup: %s", user.email)
        return user

    # ------------------------------------------------------------------
    # Backward-compatible helper for legacy allauth versions
    # ------------------------------------------------------------------
    def save(self, request):
        """
        Mirrors allauth’s legacy `save()` signature for backward compatibility.
        Simply delegates to `signup()`.
        """
        user = User()
        return self.signup(request, user)


--------------------------------------------
### FILE: apps\users\mfa.py
### SIZE: 8163 bytes
### HASH: C1496A78EDFBAD07E5839BC9F9722EB5E94046581DE7978ED416258A0B6CBBA0

"""
apps.users.mfa
==============

Enterprise-grade Multi-Factor Authentication (MFA) utilities.

✔ Django 5.2 / Python 3.12 compliant
✔ RFC 6238 (TOTP) + RFC 4226 (HOTP) compliant
✔ Timing-attack resistant comparisons
✔ Stable issuer rules with no branding
✔ Hardened Base32 handling (no secret leakage)
✔ Drift-tolerant window verification
"""

from __future__ import annotations

import base64
import binascii
import hashlib
import hmac
import logging
import secrets
import time
from typing import Optional
from urllib.parse import quote_plus

from apps.site_settings.models import SiteSettings

logger = logging.getLogger(__name__)


# =====================================================================
# BASE32 HELPERS
# =====================================================================
def _base32_pad(secret: str) -> str:
    """
    Normalize & pad Base32 secret for decoding.
    - Removes spaces
    - Uppercases
    - Pads to a multiple of 8 chars
    """
    s = secret.strip().replace(" ", "").upper()
    if not s:
        raise ValueError("Empty Base32 secret.")
    pad = (-len(s)) % 8
    return s + ("=" * pad)


def _base32_decode(secret: str) -> bytes:
    """
    Decode Base32 secret with strict safety.
    Logs errors without leaking the secret.
    Raises ValueError on failure.
    """
    try:
        padded = _base32_pad(secret)
        return base64.b32decode(padded, casefold=True)
    except (binascii.Error, ValueError, TypeError) as exc:
        logger.exception("Invalid Base32 secret (decode failure).")
        raise ValueError("Invalid Base32 secret") from exc


# =====================================================================
# TOTP (RFC-6238)
# =====================================================================
class TOTPService:
    """
    RFC 6238 TOTP implementation.
    Generates TOTP codes compatible with:
        - Google Authenticator
        - Authy
        - Microsoft Authenticator

    Public methods:
        generate_secret()
        generate_current_code()
        verify()
    """

    @staticmethod
    def generate_secret(num_bytes: int = 20) -> str:
        """
        Generate a secure Base32 secret.
        Returned secret contains no '=' padding.
        """
        raw = secrets.token_bytes(num_bytes)
        enc = base64.b32encode(raw).decode("ascii")
        return enc.rstrip("=")

    @staticmethod
    def _hotp_from_bytes(key: bytes, counter: int, digits: int = 6) -> str:
        """
        RFC-4226 HOTP implementation using HMAC-SHA1.
        """
        msg = counter.to_bytes(8, "big")
        digest = hmac.new(key, msg, hashlib.sha1).digest()
        offset = digest[-1] & 0x0F
        part = digest[offset: offset + 4]
        binary = int.from_bytes(part, "big") & 0x7FFFFFFF
        return str(binary % (10 ** digits)).zfill(digits)

    @staticmethod
    def generate_current_code(
        secret: str,
        period: int = 30,
        digits: int = 6,
        at_time: Optional[int] = None,
    ) -> str:
        """
        Generate TOTP code for current time or custom timestamp.
        """
        ts = int(at_time if at_time is not None else time.time())
        counter = ts // period
        key = _base32_decode(secret)
        return TOTPService._hotp_from_bytes(key, counter, digits)

    @staticmethod
    def verify(
        secret: str,
        code: str,
        tolerance: int = 1,
        period: int = 30,
        digits: int = 6,
    ) -> bool:
        """
        Verify TOTP with ±tolerance window.

        Returns:
            True  — valid token
            False — invalid or malformed

        Never raises; logs safe diagnostic info only.
        """
        try:
            code_str = str(code).strip().zfill(digits)
            key = _base32_decode(secret)
            counter = int(time.time()) // period

            for offset in range(-tolerance, tolerance + 1):
                expected = TOTPService._hotp_from_bytes(key, counter + offset, digits)
                if hmac.compare_digest(expected, code_str):
                    return True

            return False

        except Exception:
            logger.exception("TOTP verification error (invalid secret or input).")
            return False


# =====================================================================
# MFA POLICY (from SiteSettings)
# =====================================================================
class MFAEnforcer:
    """
    Read-only MFA policy provider.

    Reads from SiteSettings:
        require_mfa
        mfa_totp_issuer
        site_name

    Never raises — always returns safe values.
    """

    @staticmethod
    def required() -> bool:
        """Return True if MFA is globally required."""
        try:
            settings_obj = SiteSettings.get_solo()
            return bool(getattr(settings_obj, "require_mfa", False))
        except Exception:
            logger.warning("Failed to read require_mfa; defaulting to False.")
            return False

    @staticmethod
    def issuer() -> str:
        """
        Return MFA issuer string with safe fallbacks:
            1) mfa_totp_issuer
            2) site_name
            3) "Site"
        """
        try:
            s = SiteSettings.get_solo()
            return (
                getattr(s, "mfa_totp_issuer", None)
                or getattr(s, "site_name", None)
                or "Site"
            )
        except Exception:
            logger.warning("Failed to read MFA issuer; using 'Site'.")
            return "Site"

    @staticmethod
    def provisioning_uri(
        secret: str,
        user_email: str,
        label: Optional[str] = None,
        digits: int = 6,
        period: int = 30,
        issuer: Optional[str] = None,
    ) -> str:
        """
        Build otpauth:// URI for QR provisioning.

        Example:
            otpauth://totp/Issuer:email?secret=ABC123&issuer=Issuer&digits=6&period=30
        """
        try:
            actual_issuer = issuer or MFAEnforcer.issuer()

            if label:
                full_label = f"{actual_issuer}:{label}"
            else:
                full_label = f"{actual_issuer}:{user_email}"

            label_encoded = quote_plus(full_label)
            issuer_encoded = quote_plus(actual_issuer)
            secret_str = _base32_pad(secret).replace("=", "")

            params = (
                f"secret={secret_str}"
                f"&issuer={issuer_encoded}"
                f"&algorithm=SHA1"
                f"&digits={digits}"
                f"&period={period}"
            )

            return f"otpauth://totp/{label_encoded}?{params}"

        except Exception:
            logger.exception("Failed to build provisioning URI.")
            raise


# =====================================================================
# OPTIONAL SECRET STORAGE HELPERS
# =====================================================================
def hmac_store_secret(secret: str, pepper: str) -> str:
    """
    Hash a secret using server-side pepper. Store the resulting digest in DB.
    """
    if not pepper:
        raise ValueError("pepper is required.")
    return hmac.new(pepper.encode(), secret.encode(), hashlib.sha256).hexdigest()


def compare_hmac_secret(stored_hmac: str, candidate_secret: str, pepper: str) -> bool:
    """
    Validate candidate secret against stored HMAC using constant-time comparison.
    """
    if not pepper:
        logger.warning("compare_hmac_secret() called without pepper.")
        return False
    try:
        candidate = hmac.new(pepper.encode(), candidate_secret.encode(), hashlib.sha256).hexdigest()
        return hmac.compare_digest(stored_hmac, candidate)
    except Exception:
        logger.exception("compare_hmac_secret() error.")
        return False


__all__ = ["TOTPService", "MFAEnforcer", "hmac_store_secret", "compare_hmac_secret"]


--------------------------------------------
### FILE: apps\users\middleware\profile_completion.py
### SIZE: 4045 bytes
### HASH: 16D55868CB345E38C676DD297F0AB9501AB5184788B8E1E5E70F46795632372E

from __future__ import annotations

from typing import Iterable
from django.shortcuts import redirect
from django.urls import reverse, resolve


class EnforceProfileCompletionMiddleware:
    """
    Enterprise-grade enforcement that ensures authenticated users complete their profile
    before accessing the rest of the platform.

    Features:
    - Zero redirect loops
    - Excludes auth, admin, logout, static, consent, and health endpoints
    - Ultra-fast: uses path startswith + resolver_match fallback
    - Compatible with Django 5.2+ and Allauth 0.65+
    - No accidental blocking of AJAX/HTMX/XHR/API endpoints
    - Compatible with non-HTML API requests (returns response unchanged)
    """

    # ----------------------------------------------------------------------
    # Pre-resolved URL names avoid repeated reverse() calls (micro-optimizing)
    # ----------------------------------------------------------------------
    PROFILE_URL_NAME = "users:tell_us_about_you"

    # URLs that must never be intercepted
    SAFE_URL_NAMES: Iterable[str] = {
        PROFILE_URL_NAME,
        "account_login",
        "account_logout",
        "account_signup",
        "account_reset_password",
        "account_reset_password_done",
        "account_reset_password_from_key",
        "account_reset_password_from_key_done",
    }

    # PATH prefixes to ignore entirely
    SAFE_PATH_PREFIXES: Iterable[str] = (
        "/admin",
        "/static",
        "/media",
        "/api",
        "/health",
        "/consent",    # prevent blocking when consent banner loads
    )

    def __init__(self, get_response):
        self.get_response = get_response
        # compute once
        self.profile_url = reverse(self.PROFILE_URL_NAME)

    # ------------------------------------------------------------------
    # Main middleware
    # ------------------------------------------------------------------
    def __call__(self, request):

        user = getattr(request, "user", None)

        # --- Fast exit for anonymous users ----------------------------------
        if not (user and user.is_authenticated):
            return self.get_response(request)

        # --- Do not run for admin/staff access to Django admin -------------
        if user.is_staff and request.path.startswith("/admin"):
            return self.get_response(request)

        # --- Already completed ---------------------------------------------
        if getattr(user, "profile_completed", True):
            return self.get_response(request)

        path = request.path

        # --- Safe paths (static, media, admin, consent, api...) ------------
        for prefix in self.SAFE_PATH_PREFIXES:
            if path.startswith(prefix):
                return self.get_response(request)

        # --- Prevent redirect loops ----------------------------------------
        if path == self.profile_url:
            return self.get_response(request)

        # --- Safe named routes (auth/login/signup etc.) --------------------
        try:
            # resolver_match is cached inside request by Django 5+
            match = request.resolver_match or resolve(path)
            if match and match.view_name in self.SAFE_URL_NAMES:
                return self.get_response(request)
        except Exception:
            # Resolving failure → allow request to proceed
            return self.get_response(request)

        # --- Prevent blocking of AJAX/HTMX/API --------------------------------
        if request.headers.get("X-Requested-With") == "XMLHttpRequest":
            return self.get_response(request)
        if request.headers.get("HX-Request") == "true":
            return self.get_response(request)
        if request.content_type == "application/json":
            return self.get_response(request)

        # --- Finally: enforce redirect -------------------------------------
        return redirect(self.PROFILE_URL_NAME)


--------------------------------------------
### FILE: apps\users\migrations\__init__.py
### SIZE: 0 bytes
### HASH: E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855


--------------------------------------------
### FILE: apps\users\migrations\0001_initial.py
### SIZE: 8403 bytes
### HASH: 260965EECB205354007F872B51672AA3856ABCE925E028DB071C48AB610BC9A1

# Generated by Django 5.2.8 on 2025-11-18 21:26

import apps.users.models
import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('email', models.EmailField(db_index=True, max_length=254, unique=True)),
                ('username', models.CharField(blank=True, db_index=True, max_length=150, null=True, unique=True)),
                ('full_name', models.CharField(blank=True, default='', max_length=150)),
                ('country', models.CharField(blank=True, max_length=100)),
                ('phone', models.CharField(blank=True, max_length=20, null=True, unique=True)),
                ('currency', models.CharField(blank=True, max_length=10, null=True)),
                ('role', models.CharField(blank=True, max_length=50, null=True)),
                ('is_active', models.BooleanField(default=True)),
                ('is_staff', models.BooleanField(default=False)),
                ('credits', models.PositiveIntegerField(default=0)),
                ('referral_code', models.CharField(blank=True, db_index=True, max_length=12, unique=True)),
                ('unlock_count', models.PositiveIntegerField(default=0)),
                ('last_unlock', models.DateTimeField(blank=True, null=True)),
                ('email_verified_at', models.DateTimeField(blank=True, null=True)),
                ('verification_code', models.CharField(blank=True, max_length=24)),
                ('signup_method', models.CharField(choices=[('manual', 'Manual'), ('social', 'Social')], default='manual', max_length=20)),
                ('profile_completed', models.BooleanField(default=False, help_text='Indicates whether the user has completed their onboarding/profile setup.')),
                ('date_joined', models.DateTimeField(auto_now_add=True)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('referred_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='referrals', to=settings.AUTH_USER_MODEL)),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
                'ordering': ['-date_joined'],
            },
            managers=[
                ('objects', apps.users.models.CustomUserManager()),
            ],
        ),
        migrations.CreateModel(
            name='Announcement',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('message', models.TextField()),
                ('audience', models.CharField(choices=[('all', 'All'), ('user', 'Users'), ('staff', 'Staff')], default='all', max_length=20)),
                ('is_global', models.BooleanField(default=False)),
                ('start_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField(blank=True, null=True)),
                ('created_by', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='created_announcements', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Announcement',
                'verbose_name_plural': 'Announcements',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='DeviceFingerprint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fingerprint_hash', models.CharField(max_length=128)),
                ('os_info', models.CharField(blank=True, max_length=100)),
                ('motherboard_id', models.CharField(blank=True, max_length=100)),
                ('browser_info', models.CharField(blank=True, max_length=255)),
                ('registered_at', models.DateTimeField(auto_now_add=True)),
                ('last_used_at', models.DateTimeField(auto_now=True)),
                ('is_active', models.BooleanField(default=True)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='device_fingerprints', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Device Fingerprint',
                'verbose_name_plural': 'Device Fingerprints',
                'ordering': ['-last_used_at'],
            },
        ),
        migrations.CreateModel(
            name='Notification',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=255)),
                ('message', models.TextField()),
                ('priority', models.CharField(choices=[('info', 'Info'), ('warning', 'Warning'), ('critical', 'Critical')], default='info', max_length=20)),
                ('channel', models.CharField(choices=[('web', 'Web'), ('email', 'Email'), ('sms', 'SMS'), ('push', 'Push')], default='web', max_length=20)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('is_read', models.BooleanField(default=False)),
                ('read_at', models.DateTimeField(blank=True, null=True)),
                ('recipient', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='notifications', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Notification',
                'verbose_name_plural': 'Notifications',
                'ordering': ['-created_at'],
            },
        ),
        migrations.AddIndex(
            model_name='customuser',
            index=models.Index(fields=['email'], name='user_email_idx'),
        ),
        migrations.AddIndex(
            model_name='customuser',
            index=models.Index(fields=['username'], name='user_username_idx'),
        ),
        migrations.AddIndex(
            model_name='customuser',
            index=models.Index(fields=['referral_code'], name='user_referral_idx'),
        ),
        migrations.AddIndex(
            model_name='announcement',
            index=models.Index(fields=['is_global', 'start_at'], name='announce_global_start_idx'),
        ),
        migrations.AddIndex(
            model_name='devicefingerprint',
            index=models.Index(fields=['user', 'is_active'], name='device_user_active_idx'),
        ),
        migrations.AddConstraint(
            model_name='devicefingerprint',
            constraint=models.UniqueConstraint(fields=('user', 'fingerprint_hash'), name='unique_user_fingerprint'),
        ),
        migrations.AddIndex(
            model_name='notification',
            index=models.Index(fields=['recipient', 'is_read'], name='notif_recipient_read_idx'),
        ),
    ]


--------------------------------------------
### FILE: apps\users\models.py
### SIZE: 19708 bytes
### HASH: 61352E5F52BF8F0F190DC47F888BF6E7514707A24198AF15205354CB81037913

# apps/users/models.py
"""
apps/users/models.py

GSMInfinity — authoritative, enterprise-grade user models.

Design:
- CustomUser (email primary) with atomic referral generation
- DeviceFingerprint for MFA / trusted devices
- Notification & Announcement models
- Defensive DB operations and logging
- Compatible with Django 5.2+ / Python 3.12
"""

from __future__ import annotations

import logging
import secrets
import string
import uuid
import re
from typing import Optional, Any, Dict

from django.conf import settings
from django.core.cache import cache
from django.db import models, transaction, IntegrityError
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.utils import timezone
from django.utils.text import slugify

logger = logging.getLogger(__name__)

_PHONE_NORMALIZE_RE = re.compile(r"[^\d+]")  # keep digits and leading +


# --------------------------------------------------------------------------
# User manager
# --------------------------------------------------------------------------
class CustomUserManager(BaseUserManager):
    """Custom manager with unified user/superuser creation."""
    use_in_migrations = True

    def _create_user(
        self,
        email: str,
        username: Optional[str],
        password: Optional[str],
        **extra_fields: Any,
    ) -> "CustomUser":
        if not email:
            raise ValueError("An email address is required.")
        email = self.normalize_email(email).strip().lower()
        username = (username or email.split("@")[0]).strip()[:150]

        with transaction.atomic():
            user = self.model(email=email, username=username, **extra_fields)
            if password:
                user.set_password(password)
            else:
                user.set_unusable_password()
            user.save(using=self._db)
        return user

    def create_user(
        self,
        email: str,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **extra_fields: Any,
    ) -> "CustomUser":
        extra_fields.setdefault("is_staff", False)
        extra_fields.setdefault("is_superuser", False)
        extra_fields.setdefault("is_active", True)
        return self._create_user(email, username, password, **extra_fields)

    def create_superuser(
        self,
        email: str,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **extra_fields: Any,
    ) -> "CustomUser":
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        extra_fields.setdefault("is_active", True)

        if not (extra_fields.get("is_staff") and extra_fields.get("is_superuser")):
            raise ValueError("Superuser must have is_staff=True and is_superuser=True.")
        return self._create_user(email, username, password, **extra_fields)


# --------------------------------------------------------------------------
# CustomUser
# --------------------------------------------------------------------------
class CustomUser(AbstractBaseUser, PermissionsMixin):
    """
    Core authentication model with referrals, verification & tracking.
    Email is the primary unique identifier.
    """

    # Identity
    email = models.EmailField(unique=True, db_index=True)
    username = models.CharField(max_length=150, unique=True, null=True, blank=True, db_index=True)
    full_name = models.CharField(max_length=150, blank=True, default="")

    # Profile
    country = models.CharField(max_length=100, blank=True)
    phone = models.CharField(max_length=20, unique=True, null=True, blank=True)
    currency = models.CharField(max_length=10, null=True, blank=True)
    role = models.CharField(max_length=50, null=True, blank=True)

    # Permissions
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    # Credits & referrals
    credits = models.PositiveIntegerField(default=0)
    referral_code = models.CharField(max_length=12, unique=True, blank=True, db_index=True)
    referred_by = models.ForeignKey(
        "self", null=True, blank=True, on_delete=models.SET_NULL, related_name="referrals"
    )

    # Security & verification
    unlock_count = models.PositiveIntegerField(default=0)
    last_unlock = models.DateTimeField(null=True, blank=True)
    email_verified_at = models.DateTimeField(null=True, blank=True)
    verification_code = models.CharField(max_length=24, blank=True)

    # Signup metadata
    signup_method = models.CharField(
        max_length=20,
        choices=[("manual", "Manual"), ("social", "Social")],
        default="manual",
    )
    profile_completed = models.BooleanField(
        default=False,
        help_text="Indicates whether the user has completed their onboarding/profile setup."
    )
    date_joined = models.DateTimeField(auto_now_add=True)

    # Manager / ID
    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = []  # keep empty to simplify superuser creation prompts
    objects = CustomUserManager()

    class Meta:
        ordering = ["-date_joined"]
        verbose_name = "User"
        verbose_name_plural = "Users"
        indexes = [
            models.Index(fields=["email"], name="user_email_idx"),
            models.Index(fields=["username"], name="user_username_idx"),
            models.Index(fields=["referral_code"], name="user_referral_idx"),
        ]

    def __str__(self) -> str:
        return self.email or (self.username or f"user-{self.pk}")

    # ============================================================
    # Minimal model clean / normalization
    # ============================================================
    def clean(self) -> None:
        # Normalize email and phone before validations
        if self.email:
            self.email = str(self.email).strip().lower()
        if self.phone:
            # strip separators but keep leading plus if present
            normalized = _PHONE_NORMALIZE_RE.sub("", str(self.phone))
            self.phone = normalized

    # ============================================================
    # Referral system (atomic and bounded)
    # ============================================================
    @staticmethod
    def _generate_referral_candidate() -> str:
        """
        Generate a referral candidate of length 12 using secure randomness.
        """
        base = uuid.uuid4().hex[:8].upper()
        suffix_chars = string.ascii_uppercase + string.digits
        suffix = "".join(secrets.choice(suffix_chars) for _ in range(4))
        return f"{base}{suffix}"[:12]

    def _attempt_assign_referral(self, candidate: str) -> bool:
        """
        Try atomic assignment of referral code on the DB record for this user.
        Returns True if assignment succeeded; False otherwise.
        """
        try:
            with transaction.atomic():
                obj = CustomUser.objects.select_for_update().get(pk=self.pk)
                if obj.referral_code:
                    self.referral_code = obj.referral_code
                    return True
                if CustomUser.objects.filter(referral_code=candidate).exists():
                    return False
                obj.referral_code = candidate
                obj.save(update_fields=["referral_code"])
                self.referral_code = candidate
                return True
        except IntegrityError:
            logger.debug("Referral collision for candidate=%s", candidate)
            return False
        except Exception as exc:
            logger.exception("Referral assignment failed for %s → %s", candidate, exc)
            return False

    def save(self, *args, **kwargs) -> None:
        """
        Auto-generate referral_code atomically if missing.
        Ensures at least one save occurs to obtain PK before assignment attempts.
        """
        # Basic normalization + username generation for new objects
        try:
            self.clean()
        except Exception:
            # never block save because of normalization issues
            logger.debug("cleanup failed in save(); proceeding with save")

        # If new instance without PK, create a minimal row to obtain PK
        if not self.pk:
            if not self.username and self.email:
                base = self.email.split("@")[0][:120]
                slug = slugify(base) or f"user{secrets.token_hex(3)}"
                # avoid trivial slug collisions (best-effort)
                if CustomUser.objects.filter(username=slug).exists():
                    slug = f"{slug[:10]}{secrets.token_hex(2)}"
                self.username = slug
            super().save(*args, **kwargs)

        # If referral_code still missing, attempt assignment
        if not self.referral_code:
            max_attempts = 8
            assigned_candidate: Optional[str] = None
            for _ in range(max_attempts):
                cand = self._generate_referral_candidate()
                reserve_key = f"refcode:{cand}"
                reserved = False
                try:
                    reserved = cache.add(reserve_key, True, timeout=5)
                except Exception:
                    reserved = False

                if not reserved:
                    continue

                try:
                    if self._attempt_assign_referral(cand):
                        assigned_candidate = cand
                        break
                finally:
                    if not assigned_candidate:
                        try:
                            cache.delete(reserve_key)
                        except Exception:
                            logger.debug("Failed to delete referral reservation key %s", reserve_key)

            if not assigned_candidate:
                # fallback deterministic but unique-ish default
                stamp = int(timezone.now().timestamp()) % 100000
                suffix = secrets.randbelow(90000) + 10000
                fallback = f"REF{stamp}{suffix}"[:12].upper()
                try:
                    with transaction.atomic():
                        obj = CustomUser.objects.select_for_update().get(pk=self.pk)
                        if not obj.referral_code:
                            obj.referral_code = fallback
                            obj.save(update_fields=["referral_code"])
                            self.referral_code = fallback
                        else:
                            self.referral_code = obj.referral_code
                except Exception as exc:
                    logger.exception("Failed to persist fallback referral code for user %s → %s", getattr(self, "pk", None), exc)
                    self.referral_code = fallback

        # Final save to persist any other unsaved changes
        try:
            super().save(*args, **kwargs)
        except Exception as exc:
            logger.exception("Failed to save user %s → %s", getattr(self, "email", None), exc)
            raise

    # ============================================================
    # Utilities
    # ============================================================
    @property
    def is_verified(self) -> bool:
        return bool(self.email_verified_at)

    def mark_email_verified(self) -> None:
        if not self.email_verified_at:
            self.email_verified_at = timezone.now()
            try:
                self.save(update_fields=["email_verified_at"])
            except Exception as exc:
                logger.exception("Email verification update failed: %s", exc)

    def generate_verification_code(
        self, length: int = 6, code_type: str = "alphanumeric"
    ) -> str:
        alphabet = string.digits if code_type == "numeric" else (string.ascii_uppercase + string.digits)
        length = max(1, min(length, 24))
        code = "".join(secrets.choice(alphabet) for _ in range(length))
        self.verification_code = code
        try:
            self.save(update_fields=["verification_code"])
        except Exception as exc:
            logger.exception("Verification code save failed for %s → %s", self.email, exc)
        return code

    def increment_unlock(self) -> None:
        try:
            self.unlock_count = (self.unlock_count or 0) + 1
            self.last_unlock = timezone.now()
            self.save(update_fields=["unlock_count", "last_unlock"])
        except Exception as exc:
            logger.exception("Unlock counter update failed: %s", exc)

    def add_credits(self, amount: int) -> None:
        if amount > 0:
            try:
                self.credits = (self.credits or 0) + int(amount)
                self.save(update_fields=["credits"])
            except Exception as exc:
                logger.exception("Credit update failed: %s", exc)


# --------------------------------------------------------------------------
# DeviceFingerprint
# --------------------------------------------------------------------------
class DeviceFingerprint(models.Model):
    """Tracks device/browser identifiers for MFA and session trust."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="device_fingerprints",
    )
    fingerprint_hash = models.CharField(max_length=128)
    os_info = models.CharField(max_length=100, blank=True)
    motherboard_id = models.CharField(max_length=100, blank=True)
    browser_info = models.CharField(max_length=255, blank=True)
    registered_at = models.DateTimeField(auto_now_add=True)
    last_used_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["user", "fingerprint_hash"], name="unique_user_fingerprint"
            )
        ]
        ordering = ["-last_used_at"]
        verbose_name = "Device Fingerprint"
        verbose_name_plural = "Device Fingerprints"
        indexes = [models.Index(fields=["user", "is_active"], name="device_user_active_idx")]

    def __str__(self) -> str:
        return f"{getattr(self.user, 'email', 'unknown')} · {self.fingerprint_hash[:8]}"

    def fingerprint_hash_short(self) -> str:
        return (self.fingerprint_hash or "")[:16]


# --------------------------------------------------------------------------
# Notification
# --------------------------------------------------------------------------
class Notification(models.Model):
    """Multi-channel user notifications with audit timestamps."""

    PRIORITY_CHOICES = [
        ("info", "Info"),
        ("warning", "Warning"),
        ("critical", "Critical"),
    ]
    CHANNEL_CHOICES = [
        ("web", "Web"),
        ("email", "Email"),
        ("sms", "SMS"),
        ("push", "Push"),
    ]

    recipient = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="notifications",
    )
    title = models.CharField(max_length=255)
    message = models.TextField()
    priority = models.CharField(max_length=20, choices=PRIORITY_CHOICES, default="info")
    channel = models.CharField(max_length=20, choices=CHANNEL_CHOICES, default="web")
    created_at = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)
    read_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Notification"
        verbose_name_plural = "Notifications"
        indexes = [
            models.Index(fields=["recipient", "is_read"], name="notif_recipient_read_idx")
        ]

    def __str__(self) -> str:
        return f"{self.title} → {getattr(self.recipient, 'email', 'unknown')}"

    def mark_as_read(self) -> None:
        if not self.is_read:
            self.is_read = True
            self.read_at = timezone.now()
            try:
                self.save(update_fields=["is_read", "read_at"])
            except Exception as exc:
                logger.exception("Failed to mark notification read: %s", exc)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.pk,
            "title": self.title,
            "message": self.message,
            "priority": self.priority,
            "channel": self.channel,
            "is_read": bool(self.is_read),
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "read_at": self.read_at.isoformat() if self.read_at else None,
        }

    def to_json(self) -> Dict[str, Any]:
        return self.to_dict()


# --------------------------------------------------------------------------
# Announcement
# --------------------------------------------------------------------------
class Announcement(models.Model):
    """Global or segmented announcements for users or staff."""

    AUDIENCE_CHOICES = [
        ("all", "All"),
        ("user", "Users"),
        ("staff", "Staff"),
    ]

    title = models.CharField(max_length=255)
    message = models.TextField()
    audience = models.CharField(max_length=20, choices=AUDIENCE_CHOICES, default="all")
    is_global = models.BooleanField(default=False)
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        on_delete=models.SET_NULL,
        related_name="created_announcements",
    )
    start_at = models.DateTimeField(default=timezone.now)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]
        verbose_name = "Announcement"
        verbose_name_plural = "Announcements"
        indexes = [
            models.Index(fields=["is_global", "start_at"], name="announce_global_start_idx")
        ]

    def __str__(self) -> str:
        return self.title

    def active_now(self) -> bool:
        now = timezone.now()
        if self.start_at and self.start_at > now:
            return False
        if self.expires_at and self.expires_at <= now:
            return False
        return bool(self.is_global or self.audience)

    def deactivate_if_expired(self) -> None:
        if self.expires_at and self.expires_at < timezone.now() and self.is_global:
            self.is_global = False
            try:
                self.save(update_fields=["is_global"])
            except Exception as exc:
                logger.exception("Failed to deactivate expired announcement: %s", exc)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.pk,
            "title": self.title,
            "message": self.message,
            "audience": self.audience,
            "is_global": bool(self.is_global),
            "start_at": self.start_at.isoformat() if self.start_at else None,
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "created_by": getattr(self.created_by, "email", None) or getattr(self.created_by, "username", None) or None,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }

    def to_json(self) -> Dict[str, Any]:
        return self.to_dict()


--------------------------------------------
### FILE: apps\users\notifications_urls.py
### SIZE: 710 bytes
### HASH: 14AD6D7978954F7C3A02990D63BDCD41CC257A465EAE476DE76BDFF734001A43

from __future__ import annotations

from django.urls import path
from .views_notifications import (
    notification_list,
    notification_detail,
    notification_unread_count,
    notification_mark_read,
    notification_mark_all_read,
)

app_name = "users_notifications"

urlpatterns = [
    # HTML
    path("", notification_list, name="list"),
    path("<int:pk>/", notification_detail, name="detail"),   # ✔ matches view PK type (INT)

    # JSON
    path("count/unread/", notification_unread_count, name="unread_count"),

    # Mutations
    path("mark/<int:pk>/", notification_mark_read, name="mark_read"),
    path("mark-all/", notification_mark_all_read, name="mark_all"),
]

--------------------------------------------
### FILE: apps\users\services\notifications.py
### SIZE: 1584 bytes
### HASH: 0565B508C75A164A0378C874435EFC209B78C9F3A9D87EAECA24D072C250F299

from __future__ import annotations

import logging
from typing import Optional
from django.db import transaction
from django.utils import timezone

from apps.users.models import Notification
from django.contrib.auth import get_user_model

logger = logging.getLogger(__name__)
User = get_user_model()


def send_notification(
    recipient: User,
    title: str,
    message: str,
    level: str = "info",       # mapped to model.priority
    url: Optional[str] = None,
    actor: Optional[User] = None,
    channel: Optional[str] = None,   # NEW: support channel field
) -> Optional[Notification]:
    """
    Safely create a notification for a user.
    Returns the Notification instance or None on error.
    """

    try:
        with transaction.atomic():
            n = Notification.objects.create(
                recipient=recipient,
                title=title[:255],
                message=message,
                priority=level,          # FIXED: your model uses 'priority'
                url=url or "",
                actor=actor,
                channel=channel,         # NEW: support channel usage
                # created_at auto_set by model default (best practice)
            )

            # Optional: trigger websockets / signals / push
            # publish_notification(n)

            return n

    except Exception as exc:
        logger.exception(
            "Failed to create notification for user %s: %s",
            getattr(recipient, "pk", None),
            exc,
        )
        return None


--------------------------------------------
### FILE: apps\users\services\rate_limit.py
### SIZE: 4008 bytes
### HASH: 27AB9ED1516E349AA37EA719966EC1A2D92DB8D871836173890D88B6E74C846E

"""
apps.users.services.rate_limit
------------------------------
Lightweight, cache-based rate limiter for authentication and signup actions.

✅ Features:
- Atomic per-key rate limiting
- Sliding window expiration
- Cache backend–agnostic (Redis, Memcached, LocMem)
- Zero external dependencies
- Self-healing against corrupted cache entries
- Minimal latency footprint (<1ms Redis)
"""

import logging
import time
from typing import List
from django.core.cache import cache

logger = logging.getLogger(__name__)


# ============================================================
#  RATE LIMIT CORE LOGIC
# ============================================================
def allow_action(
    key: str,
    max_attempts: int = 5,
    window_seconds: int = 300,
) -> bool:
    """
    Determines whether a given action (e.g., login attempt) is allowed
    under a sliding-window rate limit.

    Args:
        key (str): Unique cache key, e.g. `"login:ip:1.2.3.4"` or `"signup:user:123"`.
        max_attempts (int): Max number of allowed actions per window.
        window_seconds (int): Sliding time window in seconds.

    Returns:
        bool: True if action is allowed, False if rate limit exceeded.

    Behavior:
        ✅ Uses timestamp bucket stored in Django cache.
        ✅ Removes stale timestamps (outside sliding window).
        ✅ Handles cache corruption gracefully.
        ✅ Works across Redis, Memcached, or LocMem.
        ✅ Fails open on cache backend errors.
    """
    if not key:
        logger.warning("allow_action called with empty key.")
        return False

    now = time.time()

    try:
        bucket: List[float] = cache.get(key, [])
        if not isinstance(bucket, list):
            logger.warning("Corrupted rate-limit bucket detected for %s; resetting.", key)
            bucket = []

        # Keep only timestamps within window
        bucket = [t for t in bucket if now - t <= window_seconds]

        # Exceeded?
        if len(bucket) >= max_attempts:
            logger.info(
                "Rate limit exceeded: key=%s, attempts=%d/%d, window=%ds",
                key,
                len(bucket),
                max_attempts,
                window_seconds,
            )
            return False

        # Add current attempt and persist
        bucket.append(now)

        # Set cache with sliding expiration
        cache.set(key, bucket, timeout=window_seconds)

        logger.debug(
            "Rate limit OK: key=%s, attempts=%d/%d, window=%ds",
            key,
            len(bucket),
            max_attempts,
            window_seconds,
        )
        return True

    except Exception as exc:
        # Fail-open to prevent blocking on cache outage
        logger.exception("Rate limiter backend failure for %s: %s", key, exc)
        return True


# ============================================================
#  RESET & UTILITY HELPERS
# ============================================================
def reset_rate_limit(key: str) -> None:
    """
    Clears the rate limiter for a given key.
    Useful for testing or manual unblocking after successful login.
    """
    try:
        cache.delete(key)
        logger.debug("Rate limit reset for key=%s", key)
    except Exception as exc:
        logger.warning("Failed to reset rate limit for %s: %s", key, exc)


def get_attempt_count(key: str, window_seconds: int = 300) -> int:
    """
    Returns the current number of attempts within the window for a key.
    Safe against corrupted cache values.
    """
    try:
        now = time.time()
        bucket: List[float] = cache.get(key, [])
        if not isinstance(bucket, list):
            return 0
        return len([t for t in bucket if now - t <= window_seconds])
    except Exception as exc:
        logger.warning("Failed to read attempt count for %s: %s", key, exc)
        return 0


--------------------------------------------
### FILE: apps\users\services\recaptcha.py
### SIZE: 8262 bytes
### HASH: F8975AD1DF42451EAC1B37ADF9C7121312814FB9D4673052100D34A4EDDCA38F

"""
apps.users.services.recaptcha
=============================

Enterprise-Grade Google reCAPTCHA Verification Service

✅ Supports v2 + v3 with hostname verification
✅ Configurable thresholds via SiteSettings
✅ Token-level atomic caching (short-lived, cryptographic digest)
✅ Graceful degradation when disabled or unreachable
✅ Hardened against malformed tokens & network errors
✅ Fully typed, Django 5.2 / Python 3.12 compliant
✅ Zero silent failures, no unsafe hash() use
"""

from __future__ import annotations

import hashlib
import json
import logging
from decimal import Decimal
from typing import Any, Dict, Optional

import requests
from requests import Response
from requests.exceptions import (
    Timeout,
    ConnectionError as RequestsConnectionError,
    RequestException,
)

from django.conf import settings as django_settings
from django.core.cache import cache

from apps.site_settings.models import SiteSettings

logger = logging.getLogger(__name__)

API_URL = "https://www.google.com/recaptcha/api/siteverify"
CACHE_TTL_SECONDS = 15


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _token_digest(token: str) -> str:
    """
    Return a stable SHA-256 digest for the given token.
    Avoids Python's built-in hash(), which is process-randomized.
    """
    return hashlib.sha256(token.encode("utf-8")).hexdigest()


def _safe_decimal(value: Any, default: Decimal = Decimal("0")) -> Decimal:
    """Safely convert a value to Decimal; return default on failure."""
    try:
        return Decimal(str(value))
    except Exception:
        return default


# ---------------------------------------------------------------------------
# Main Verification Function
# ---------------------------------------------------------------------------

def verify_recaptcha(
    token: str,
    remote_ip: Optional[str] = None,
    action: str = "login",
) -> Dict[str, Any]:
    """
    Verify a Google reCAPTCHA token using configuration from SiteSettings.

    Returns:
        {
            "ok": bool,
            "score": float | None,
            "errors": list[str],
            "error": str | None,  # internal issue, if any
        }
    """
    # ----------------------------------------------------------
    # Step 1. Load configuration
    # ----------------------------------------------------------
    try:
        settings_obj = SiteSettings.get_solo()
    except Exception as exc:
        logger.warning("reCAPTCHA: unable to load SiteSettings → %s", exc)
        return {"ok": False, "error": "settings_unavailable", "errors": []}

    recaptcha_enabled: bool = bool(getattr(settings_obj, "recaptcha_enabled", False))
    recaptcha_mode: str = str(getattr(settings_obj, "recaptcha_mode", "off")).lower()
    private_key: Optional[str] = getattr(settings_obj, "recaptcha_private_key", None)

    # ----------------------------------------------------------
    # Step 2. Skip if disabled
    # ----------------------------------------------------------
    if not recaptcha_enabled or recaptcha_mode == "off":
        logger.debug("reCAPTCHA: bypassed (disabled/off)")
        return {"ok": True, "score": None, "errors": []}

    # ----------------------------------------------------------
    # Step 3. Validate token input
    # ----------------------------------------------------------
    if not token or not isinstance(token, str) or len(token) > 10_000:
        logger.debug("reCAPTCHA: invalid token format")
        return {"ok": False, "error": "invalid_token_format", "errors": []}

    if not private_key:
        logger.error("reCAPTCHA: missing private key in SiteSettings")
        return {"ok": False, "error": "missing_credentials", "errors": []}

    # ----------------------------------------------------------
    # Step 4. Short-term cache check (digest-based)
    # ----------------------------------------------------------
    cache_key = f"recaptcha:{action}:{_token_digest(token)}"
    try:
        cached: Optional[Dict[str, Any]] = cache.get(cache_key)
        if cached is not None:
            logger.debug("reCAPTCHA: using cached result for %s", action)
            return cached
    except Exception as exc:
        logger.debug("reCAPTCHA: cache.get failed → %s", exc)

    # ----------------------------------------------------------
    # Step 5. Build request payload
    # ----------------------------------------------------------
    payload: Dict[str, str] = {"secret": private_key, "response": token}
    if remote_ip:
        payload["remoteip"] = remote_ip

    timeout_s: float = max(
        float(getattr(settings_obj, "recaptcha_timeout_ms", 3000)) / 1000.0, 1.0
    )

    # ----------------------------------------------------------
    # Step 6. Perform network verification
    # ----------------------------------------------------------
    try:
        resp: Response = requests.post(API_URL, data=payload, timeout=timeout_s)
        resp.raise_for_status()
        data = resp.json()
    except Timeout:
        logger.warning("reCAPTCHA: timeout verifying token (%s)", action)
        return {"ok": False, "error": "timeout", "errors": []}
    except RequestsConnectionError as exc:
        logger.error("reCAPTCHA: connection error → %s", exc)
        return {"ok": False, "error": "connection_error", "errors": []}
    except RequestException as exc:
        logger.error("reCAPTCHA: network failure → %s", exc)
        return {"ok": False, "error": "network_error", "errors": []}
    except json.JSONDecodeError:
        logger.error("reCAPTCHA: invalid JSON response")
        return {"ok": False, "error": "invalid_response", "errors": []}
    except Exception as exc:
        logger.exception("reCAPTCHA: unexpected exception → %s", exc)
        return {"ok": False, "error": "recaptcha_unreachable", "errors": []}

    # ----------------------------------------------------------
    # Step 7. Validate response integrity
    # ----------------------------------------------------------
    success: bool = bool(data.get("success", False))
    hostname: Optional[str] = data.get("hostname")
    error_codes: list[str] = list(data.get("error-codes", []) or [])

    expected_host: Optional[str] = getattr(django_settings, "RECAPTCHA_EXPECTED_HOSTNAME", None)
    if expected_host and hostname and hostname != expected_host:
        logger.warning("reCAPTCHA: hostname mismatch (%s ≠ %s)", hostname, expected_host)
        success = False
        error_codes.append("hostname_mismatch")

    # ----------------------------------------------------------
    # Step 8. Mode-specific evaluation
    # ----------------------------------------------------------
    if recaptcha_mode == "v3":
        score = _safe_decimal(data.get("score", 0))
        threshold = _safe_decimal(getattr(settings_obj, "recaptcha_score_threshold", 0.5))
        valid = success and score >= threshold

        result: Dict[str, Any] = {
            "ok": bool(valid),
            "score": float(score),
            "errors": error_codes,
            "error": None,
        }

        if not valid:
            logger.info(
                "reCAPTCHA v3 failed: score=%.2f threshold=%.2f host=%s",
                float(score),
                float(threshold),
                hostname,
            )
    else:  # v2
        result = {
            "ok": bool(success),
            "score": None,
            "errors": error_codes,
            "error": None,
        }

    # ----------------------------------------------------------
    # Step 9. Cache result briefly
    # ----------------------------------------------------------
    try:
        cache.set(cache_key, result, timeout=CACHE_TTL_SECONDS)
        logger.debug("reCAPTCHA: cached result key=%s TTL=%ss", cache_key, CACHE_TTL_SECONDS)
    except Exception as exc:
        logger.debug("reCAPTCHA: cache.set failed for %s → %s", cache_key, exc)

    return result


--------------------------------------------
### FILE: apps\users\signals.py
### SIZE: 4475 bytes
### HASH: 180FED47D13CAC9E293277DBDF89F189BCA90C1A238B946BA4FEB5B68847282A

"""
apps.users.signals
==================
Centralized user-related signal handlers for GSMInfinity.

✅ Handles:
    - user_logged_in → Register device fingerprint, enforce device limits.
    - user_signed_up → Flag user for onboarding after signup.

✅ Fully compatible with:
    Django ≥ 5.0, allauth ≥ 0.65, and GSMInfinity enterprise utils.

This module is designed to be import-safe (idempotent registration)
and non-blocking for async runtimes.
"""

from __future__ import annotations

import logging
from django.dispatch import receiver
from django.contrib.auth.signals import user_logged_in
from allauth.account.signals import user_signed_up

from apps.users.utils.device import register_fingerprint, enforce_device_limit

logger = logging.getLogger(__name__)


# ============================================================
#  USER LOGGED IN  →  REGISTER DEVICE FINGERPRINT
# ============================================================

@receiver(user_logged_in)
def handle_user_logged_in(sender, request, user, **kwargs):
    """
    Triggered whenever a user logs in successfully (including social logins).

    Responsibilities:
      • Capture device fingerprint metadata from request headers or cookies.
      • Enforce per-user device limits (defined in SiteSettings).
      • Gracefully skip fingerprint creation when over limit (strict mode).
      • Never raise — logs exceptions but never disrupts login flow.
    """
    if not user or not request:
        logger.debug("handle_user_logged_in: missing user or request context.")
        return

    try:
        # --- Derive fingerprint fields (normalized length for DB safety)
        fp_hash = (
            request.META.get("DEVICE_FP")
            or request.COOKIES.get("device_fp")
            or request.META.get("HTTP_USER_AGENT", "unknown")
        )[:255]

        fingerprint_data = {
            "fingerprint_hash": fp_hash,
            "os_info": (request.META.get("OS_INFO") or "").strip()[:100],
            "browser_info": (request.META.get("HTTP_USER_AGENT") or "").strip()[:255],
            "motherboard_id": (request.META.get("MOTHERBOARD_ID") or "").strip()[:100],
        }

        # --- Enforce per-user device limits
        if not enforce_device_limit(user):
            logger.warning(
                "Device registration blocked — user %s exceeded device limit.",
                getattr(user, "email", user.pk),
            )
            return

        # --- Register or update device record atomically
        register_fingerprint(user=user, **fingerprint_data)
        logger.info(
            "Device fingerprint updated for user %s [%s]",
            getattr(user, "email", user.pk),
            fingerprint_data["fingerprint_hash"][:16],
        )

    except Exception as exc:
        logger.exception(
            "Error registering fingerprint for user %s: %s",
            getattr(user, "email", user.pk),
            exc,
        )


# ============================================================
#  USER SIGNED UP  →  PROFILE COMPLETION FLAG
# ============================================================

@receiver(user_signed_up)
def handle_user_signed_up(request, user, **kwargs):
    """
    Triggered immediately after a new user account is created
    (via email, social, or SSO signup).

    Responsibilities:
      • Flag user for onboarding / profile completion.
      • Maintain compatibility with custom user models (graceful skip).
    """
    if not user:
        logger.debug("handle_user_signed_up: missing user instance.")
        return

    try:
        if hasattr(user, "needs_profile_completion"):
            if not getattr(user, "needs_profile_completion", False):
                user.needs_profile_completion = True
                user.save(update_fields=["needs_profile_completion"])
                logger.debug(
                    "User %s flagged for onboarding.",
                    getattr(user, "email", user.pk),
                )
        else:
            logger.debug(
                "User model has no `needs_profile_completion` field; skipping onboarding flag."
            )

    except Exception as exc:
        logger.exception(
            "Error flagging signup completion for user %s: %s",
            getattr(user, "email", user.pk),
            exc,
        )


--------------------------------------------
### FILE: apps\users\tests.py
### SIZE: 63 bytes
### HASH: DAE0DA7EFDCDB3A7FB572D5E914B60631099122D4A4727AC6434C016161C5FE1

from django.test import TestCase

# Create your tests here.


--------------------------------------------
### FILE: apps\users\tokens.py
### SIZE: 2403 bytes
### HASH: 63EBB162645C7922C533BE99504853BE1F85A7C1B1C7AB626721349043D36F5B

"""
apps.users.tokens
=================
Enterprise-safe token utilities for GSMInfinity.

✅ Highlights
-------------
• Cryptographically secure random tokens
• URL-safe output (for email links or QR codes)
• Timezone-aware expiry calculation
• Configurable length & lifetime
• No deprecated or unsafe modules
"""

from __future__ import annotations

import secrets
from datetime import timedelta
from django.utils import timezone


# ============================================================
#  TOKEN GENERATION
# ============================================================

def generate_token(length: int = 32) -> str:
    """
    Generate a cryptographically secure, URL-safe token.

    Args:
        length (int): Desired token length (default 32).
                      Must be ≥ 8 and ≤ 128 for best entropy/performance.

    Returns:
        str: Secure random token trimmed to desired length.
    """
    if not isinstance(length, int) or length < 8 or length > 128:
        length = 32
    token = secrets.token_urlsafe(length * 2)  # overshoot for trimming
    return token[:length]


# ============================================================
#  TOKEN EXPIRY UTILITIES
# ============================================================

def token_expiry(hours: int = 24) -> timezone.datetime:
    """
    Compute an expiry datetime for a token using Django's timezone utilities.

    Args:
        hours (int): Lifetime in hours (default 24).

    Returns:
        datetime: Timezone-aware expiry timestamp.
    """
    safe_hours = hours if isinstance(hours, (int, float)) and hours > 0 else 24
    return timezone.now() + timedelta(hours=safe_hours)


# ============================================================
#  TOKEN VALIDATION (Optional Utility)
# ============================================================

def is_token_expired(created_at: timezone.datetime, hours: int = 24) -> bool:
    """
    Determine whether a token has expired.

    Args:
        created_at (datetime): Original token creation timestamp.
        hours (int): Valid lifetime in hours (default 24).

    Returns:
        bool: True if expired, False otherwise.
    """
    if not created_at:
        return True
    expiry_time = created_at + timedelta(hours=hours)
    return timezone.now() >= expiry_time


--------------------------------------------
### FILE: apps\users\urls.py
### SIZE: 2274 bytes
### HASH: 5099DA2DC4EA02FFABD3FD4064AEB310B71984177B7A39014D6044E560DFD36C

"""
apps.users.urls
================
Enterprise-grade URL configuration for GSMInfinity Users module.

✅ Features:
- Unified authentication hub (login / signup / social)
- EnterpriseLoginView & EnterpriseSignupView integration
- Logout via allauth
- Verified dashboard + profile routes
- Explicit namespacing for template reverse() safety
- Email verification flow

Fully compatible with Django 5.x / django-allauth ≥ 0.65.
"""

from django.urls import path
from allauth.account.views import LogoutView

from .views import (
    auth_hub_view,
    dashboard_view,
    profile_view,
    verify_email_view,
    EnterpriseLoginView,
    EnterpriseSignupView,
)

app_name = "users"

urlpatterns = [
    # ------------------------------------------------------------------
    # 🔐 Unified Authentication Hub
    # ------------------------------------------------------------------
    path("auth/", auth_hub_view, name="auth_hub"),

    # ------------------------------------------------------------------
    # 🧭 Authentication (Allauth-based)
    # ------------------------------------------------------------------
    path("login/", EnterpriseLoginView.as_view(), name="account_login"),
    path("signup/", EnterpriseSignupView.as_view(), name="account_signup"),
    path("logout/", LogoutView.as_view(), name="account_logout"),

    # ------------------------------------------------------------------
    # 👤 User Dashboard & Profile
    # ------------------------------------------------------------------
    path("dashboard/", dashboard_view, name="dashboard"),
    path("profile/", profile_view, name="profile"),

    # ------------------------------------------------------------------
    # ✉️  Email Verification
    # ------------------------------------------------------------------
    path("verify-email/", verify_email_view, name="verify_email"),
]

# ----------------------------------------------------------------------
# Notes:
# - All view classes / functions live in apps.users.views
# - All URLs are namespaced ("users:...") for reverse resolution
# - Safe to include under project-level /users/ route
# ----------------------------------------------------------------------


--------------------------------------------
### FILE: apps\users\utils\device.py
### SIZE: 11448 bytes
### HASH: 52C2D78F9DBEC2825DA1AF3043CB711A3DAEF6825C1063EE8FE12B8A265BD349

"""
apps.users.utils.device
-----------------------

Enterprise-grade device fingerprint and limit enforcement utilities for GSMInfinity.

Features:
- Registers or updates DeviceFingerprint on each login.
- Enforces per-user device limits (strict / lenient) with ADMIN BYPASS.
- Thread-safe atomic updates, ORM-optimized (Django 5.x).
- Compatible with async-safe authentication and signals.
- Includes periodic admin cleanup utilities.
"""

from __future__ import annotations

import logging
from typing import Optional, Dict, Any, List
from datetime import timedelta

from django.utils import timezone
from django.db import transaction
from django.core.exceptions import ValidationError

from apps.users.models import DeviceFingerprint, CustomUser
from apps.site_settings.models import SiteSettings

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------
# Device registration / update (atomic, locked)
# ---------------------------------------------------------------------
def register_fingerprint(
    user: CustomUser,
    fingerprint_hash: str,
    os_info: str = "",
    motherboard_id: str = "",
    browser_info: str = "",
) -> Optional[DeviceFingerprint]:
    """
    Create or update a DeviceFingerprint record for the given user.

    Admin users: fingerprint registered but device limits are not enforced.

    Returns:
        DeviceFingerprint | None
    """
    if not user or not fingerprint_hash:
        logger.warning("register_fingerprint: missing user or fingerprint_hash")
        return None

    # Truncate inputs to sane lengths to avoid DB bloat
    os_info = (os_info or "")[:100]
    motherboard_id = (motherboard_id or "")[:100]
    browser_info = (browser_info or "")[:255]

    try:
        with transaction.atomic():
            # Try to lock an existing fingerprint row for update
            qs = DeviceFingerprint.objects.select_for_update().filter(
                user=user, fingerprint_hash=fingerprint_hash
            )
            device = qs.first()
            created = False

            now = timezone.now()

            if device is None:
                # Create new device row
                device = DeviceFingerprint.objects.create(
                    user=user,
                    fingerprint_hash=fingerprint_hash,
                    os_info=os_info,
                    motherboard_id=motherboard_id,
                    browser_info=browser_info,
                    registered_at=now,
                    last_used_at=now,
                    is_active=True,
                )
                created = True
                update_fields: List[str] = []  # nothing to update after create
            else:
                # Update last_used_at and any changed metadata
                update_fields = ["last_used_at"]
                device.last_used_at = now

                if os_info and device.os_info != os_info:
                    device.os_info = os_info
                    update_fields.append("os_info")
                if motherboard_id and device.motherboard_id != motherboard_id:
                    device.motherboard_id = motherboard_id
                    update_fields.append("motherboard_id")
                if browser_info and device.browser_info != browser_info:
                    device.browser_info = browser_info
                    update_fields.append("browser_info")
                if not device.is_active:
                    device.is_active = True
                    update_fields.append("is_active")

                if update_fields:
                    device.save(update_fields=update_fields)

        logger.debug(
            "DeviceFingerprint[%s] %s for %s (admin=%s) — fields: %s",
            device.pk,
            "created" if created else "updated",
            getattr(user, "email", user.pk),
            getattr(user, "is_staff", False),
            ",".join(update_fields) if update_fields else "(none)",
        )
        return device

    except Exception as exc:
        logger.exception(
            "register_fingerprint failed for user=%s -> %s",
            getattr(user, "pk", None),
            exc,
        )
        return None


# ---------------------------------------------------------------------
# Device limit enforcement (atomic, admin bypass)
# ---------------------------------------------------------------------
def enforce_device_limit(user: CustomUser) -> bool:
    """
    Enforce per-user device limits from SiteSettings.

    ADMIN BYPASS: Staff/superusers have unlimited devices.
    REGULAR USERS: Subject to device limit and eviction mode.

    Modes:
        - strict  -> block new device registration if limit reached.
        - lenient -> deactivate oldest fingerprints to make room.

    Returns:
        True if registration/usage allowed, False if blocked.
    """
    if not user:
        return True

    # Admin bypass
    if getattr(user, "is_staff", False) or getattr(user, "is_superuser", False):
        logger.debug("Device limit bypassed for admin user: %s", getattr(user, "email", user.pk))
        return True

    try:
        settings_obj = SiteSettings.get_solo()
        limit = int(getattr(settings_obj, "max_devices_per_user", 3))
        mode = str(getattr(settings_obj, "fingerprint_mode", "strict")).lower()
    except Exception as exc:
        logger.warning("SiteSettings unavailable; using defaults for device limits: %s", exc)
        limit, mode = 3, "strict"

    # Lock the active device rows for this user to avoid races
    with transaction.atomic():
        active_qs = (
            DeviceFingerprint.objects.select_for_update()
            .filter(user=user, is_active=True)
            .only("id", "last_used_at")
            .order_by("last_used_at")
        )
        count = active_qs.count()

        if count < limit:
            logger.debug("User %s within device limit (%d/%d)", getattr(user, "email", user.pk), count, limit)
            return True

        if mode == "lenient":
            # Evict the oldest devices (bulk update)
            to_remove = count - limit + 1
            oldest_devices = list(active_qs[:to_remove])  # evaluated within transaction
            if not oldest_devices:
                # Unexpected, but fail-safe allow
                logger.warning("No devices found to evict for user %s despite count exceeded", getattr(user, "email", user.pk))
                return False
            try:
                for d in oldest_devices:
                    d.is_active = False
                DeviceFingerprint.objects.bulk_update(oldest_devices, ["is_active"])
                logger.info(
                    "Evicted %d oldest device(s) for user %s (lenient mode)",
                    len(oldest_devices),
                    getattr(user, "email", user.pk),
                )
                return True
            except Exception as exc:
                logger.exception("Device eviction failed for %s: %s", getattr(user, "email", user.pk), exc)
                return False

        # Strict mode: block
        logger.warning(
            "Device registration BLOCKED for %s — device limit reached (%d/%d, strict mode)",
            getattr(user, "email", user.pk),
            count,
            limit,
        )
        return False


# ---------------------------------------------------------------------
# Combined safe helper (record + enforce)
# ---------------------------------------------------------------------
def record_device_fingerprint(
    request,
    user: CustomUser,
    fingerprint_data: Optional[Dict[str, Any]] = None,
) -> Optional[DeviceFingerprint]:
    """
    Unified helper for recording device fingerprints during login.

    Raises:
        ValidationError -> missing fingerprint hash
        PermissionError -> strict mode violation for regular users
    """
    fingerprint_data = fingerprint_data or {}

    fingerprint_hash = (
        fingerprint_data.get("fingerprint_hash")
        or (getattr(request, "POST", {}).get("device_fp") if hasattr(request, "POST") else None)
        or (getattr(request, "COOKIES", {}).get("device_fp") if hasattr(request, "COOKIES") else None)
        or (getattr(request, "META", {}).get("HTTP_USER_AGENT") if getattr(request, "META", None) else None)
    )

    if not fingerprint_hash:
        raise ValidationError("record_device_fingerprint: missing fingerprint_hash")

    os_info = fingerprint_data.get("os_info") or (getattr(request, "META", {}).get("HTTP_USER_AGENT", "")[:100] if getattr(request, "META", None) else "")
    motherboard_id = fingerprint_data.get("motherboard_id") or ""
    browser_info = fingerprint_data.get("browser_info") or (getattr(request, "META", {}).get("HTTP_USER_AGENT", "")[:255] if getattr(request, "META", None) else "")

    # Enforce device limit (admin bypass included)
    allowed = enforce_device_limit(user)
    if not allowed:
        raise PermissionError("Device registration blocked (strict mode limit reached)")

    device = register_fingerprint(
        user=user,
        fingerprint_hash=fingerprint_hash,
        os_info=os_info,
        motherboard_id=motherboard_id,
        browser_info=browser_info,
    )

    user_type = "admin" if (getattr(user, "is_staff", False) or getattr(user, "is_superuser", False)) else "user"
    logger.debug("record_device_fingerprint: device recorded for %s (%s)", getattr(user, "email", user.pk), user_type)
    return device


# ---------------------------------------------------------------------
# Admin-specific utilities
# ---------------------------------------------------------------------
def get_admin_device_stats() -> Dict[str, Dict[str, Any]]:
    """
    Returns device statistics for admin users.
    Useful for dashboards or audits.
    """
    stats: Dict[str, Dict[str, Any]] = {}
    admins = CustomUser.objects.filter(is_staff=True).only("id", "email")
    for user in admins:
        devices_qs = DeviceFingerprint.objects.filter(user=user, is_active=True).only("fingerprint_hash", "last_used_at", "os_info", "browser_info")
        stats_key = user.email or f"User#{user.pk}"
        stats[stats_key] = {
            "total_devices": devices_qs.count(),
            "devices": list(devices_qs.values("fingerprint_hash", "last_used_at", "os_info", "browser_info")),
        }
    return stats


def cleanup_old_admin_devices(days_old: int = 30) -> int:
    """
    Clean up old admin device fingerprints older than `days_old`.
    Returns total number of deleted objects.
    """
    cutoff_date = timezone.now() - timedelta(days=days_old)
    deleted_total = 0

    admins = CustomUser.objects.filter(is_staff=True).only("id", "email")
    for user in admins:
        old_devices_qs = DeviceFingerprint.objects.filter(user=user, last_used_at__lt=cutoff_date)
        count = old_devices_qs.count()
        if count:
            old_devices_qs.delete()
            deleted_total += count
            logger.info("Cleaned %d old devices for admin %s", count, user.email or f"User#{user.pk}")

    logger.info("Total admin devices cleaned: %d", deleted_total)
    return deleted_total


--------------------------------------------
### FILE: apps\users\utils\utils.py
### SIZE: 312 bytes
### HASH: 5146B79F60E124D7BD618B8D73FF57D2AED90ACC0807F40ABF5B66653C864F9F

import hashlib
def get_device_fingerprint(request):
    ua=request.META.get("HTTP_USER_AGENT","")
    ip=request.META.get("HTTP_X_FORWARDED_FOR",request.META.get("REMOTE_ADDR",""))
    session_key=request.session.session_key or ""
    return hashlib.sha256(f"{ua}|{ip}|{session_key}".encode()).hexdigest()


--------------------------------------------
### FILE: apps\users\views.py
### SIZE: 14132 bytes
### HASH: 18C3088CAC1B2B1654E831449E51C9D6F93C70EBC32A3C612A06B9398C795DBA

"""
apps.users.views
================
Enterprise-grade user management and authentication views for GSMInfinity.

✅ Highlights
-------------
• Tenant-aware SiteSettings resolver (uses site_settings.views._get_settings when available)
• Integrated rate limiting + reCAPTCHA verification
• Device fingerprint capture and per-user limit enforcement
• MFA / Email verification enforcement
• Optimized dashboard queries (deferred, select_related)
• Atomic safety and hardened UX
• Fully compatible with Django 5.x and allauth ≥ 0.65
"""

from __future__ import annotations

import logging
from typing import Any, Optional

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.sites.shortcuts import get_current_site
from django.db.models import Q
from django.shortcuts import render, redirect
from django.urls import reverse
from django.utils import timezone
from django.http import HttpRequest, HttpResponse

from allauth.account.views import LoginView, SignupView
from allauth.account.forms import LoginForm, SignupForm

from apps.users.models import Notification, Announcement
from apps.users.utils.utils import get_device_fingerprint
from apps.users.utils.device import record_device_fingerprint, enforce_device_limit
from apps.users.services.recaptcha import verify_recaptcha
from apps.users.services.rate_limit import allow_action

logger = logging.getLogger(__name__)


@login_required
def profile(request: HttpRequest) -> HttpResponse:
    """
    Display the authenticated user's profile.
    """
    context: dict[str, Any] = {
        "user": request.user,
        "notifications": Notification.objects.filter(user=request.user).order_by("-created_at")[:10],
        "announcements": Announcement.objects.filter(is_active=True).order_by("-created_at")[:5],
    }
    return render(request, "profile.html", context)


def login_view(request: HttpRequest) -> HttpResponse:
    """
    Render the login page. Delegates authentication to django-allauth.
    """
    if request.user.is_authenticated:
        return redirect("core:home")

    context: dict[str, Any] = {
        "form": LoginForm(),
        "site": get_current_site(request),
    }
    return render(request, "login.html", context)

# ============================================================
# Settings resolver (lazy import to avoid circular deps)
# ============================================================
def _get_settings(request=None) -> Dict[str, object]:
    """
    Return primitive settings snapshot (dict). Try to use the canonical resolver
    from apps.site_settings.views (which already returns dict snapshots). If
    unavailable, fall back to safe defaults.
    """
    try:
        # Lazy import to avoid circular imports
        from apps.site_settings.views import _get_settings as _ss_get_settings  # type: ignore

        result = _ss_get_settings(request)
        # Ensure it's a dict (backwards tolerant)
        if isinstance(result, dict):
            return result
        # If old-style model instance returned, convert to dict
        return {
            "site_name": getattr(result, "site_name", "GSMInfinity"),
            "enable_signup": getattr(result, "enable_signup", True),
            "max_login_attempts": int(getattr(result, "max_login_attempts", 5) or 5),
            "rate_limit_window_seconds": int(getattr(result, "rate_limit_window_seconds", 300) or 300),
            "recaptcha_enabled": bool(getattr(result, "recaptcha_enabled", False)),
            "enforce_unique_device": bool(getattr(result, "enforce_unique_device", False)),
            "max_devices_per_user": int(getattr(result, "max_devices_per_user", 3) or 3),
            "require_mfa": bool(getattr(result, "require_mfa", False)),
            "enable_payments": bool(getattr(result, "enable_payments", True)),
        }
    except Exception:
        # Fallback defaults (primitive types only)
        logger.debug("site settings resolver lazy import failed; using fallback defaults", exc_info=True)
        return {
            "site_name": "GSMInfinity",
            "enable_signup": True,
            "max_login_attempts": 5,
            "rate_limit_window_seconds": 300,
            "recaptcha_enabled": False,
            "enforce_unique_device": False,
            "max_devices_per_user": 3,
            "require_mfa": False,
            "enable_payments": True,
            "site_header": "GSM Admin",
            "site_description": "Default configuration",
            "meta_tags": [],
            "verification_files": [],
        }


# ============================================================
# Enterprise Login View
# ============================================================
class EnterpriseLoginView(LoginView):
    """
    Enterprise login with:
    - IP-based rate limiting
    - reCAPTCHA verification
    - Device fingerprint & limit enforcement
    - Optional MFA redirect
    """
    form_class = LoginForm
    template_name = "account/login.html"

    def form_valid(self, form):
        settings_obj = _get_settings(self.request)
        ip = (
            self.request.META.get("HTTP_X_FORWARDED_FOR")
            or self.request.META.get("REMOTE_ADDR")
            or "unknown"
        ).split(",")[0].strip()

        # --- Rate Limiting ---
        try:
            if not allow_action(
                f"login:{ip}",
                int(settings_obj.get("max_login_attempts", 5)),
                int(settings_obj.get("rate_limit_window_seconds", 300)),
            ):
                form.add_error(None, "Too many login attempts. Please try again later.")
                logger.warning("Rate limit exceeded for IP=%s", ip)
                return self.form_invalid(form)
        except Exception:
            # Fail-open: allow login if rate limiter has issues, but log
            logger.exception("Rate limiter failure (fail-open)")

        # --- reCAPTCHA ---
        token = self.request.POST.get("g-recaptcha-response") or self.request.POST.get("recaptcha_token")
        if settings_obj.get("recaptcha_enabled", False) and token:
            try:
                rc_result = verify_recaptcha(token, ip, action="login")
                if not rc_result.get("ok"):
                    form.add_error(None, "reCAPTCHA verification failed. Please try again.")
                    logger.info("reCAPTCHA failed for %s → %s", ip, rc_result)
                    return self.form_invalid(form)
            except Exception:
                logger.exception("reCAPTCHA error (fail-open): %s", exc_info=True)
                form.add_error(None, "reCAPTCHA service error. Try again later.")
                return self.form_invalid(form)

        # Authenticate & create session
        response = super().form_valid(form)

        # --- Session fixation protection ---
        try:
            if hasattr(self.request, "session"):
                # Rotate session key on login
                self.request.session.cycle_key()
                # Set a sane default expiry (2 weeks). Rely on remember-me elsewhere if present.
                self.request.session.set_expiry(1209600)
        except Exception:
            logger.exception("Failed to rotate session after login")

        user = self.request.user

        # --- Device limit enforcement (admin bypass inside helper) ---
        try:
            if settings_obj.get("enforce_unique_device", False):
                allowed = enforce_device_limit(user)
                if not allowed:
                    form.add_error(None, "Device limit exceeded. Contact support.")
                    logger.warning("Device limit exceeded for user=%s", getattr(user, "email", user.pk))
                    return self.form_invalid(form)
        except Exception:
            logger.exception("Device enforcement error (fail-open)")

        # --- Fingerprint Recording (best-effort) ---
        try:
            fp = get_device_fingerprint(self.request)
            if fp:
                try:
                    record_device_fingerprint(self.request, user, {"fingerprint_hash": fp})
                except PermissionError:
                    # Device rejected under strict mode
                    form.add_error(None, "This device cannot be registered. Contact support.")
                    logger.warning("Device blocked for user=%s", getattr(user, "email", user.pk))
                    return self.form_invalid(form)
                except Exception:
                    logger.exception("Failed to record device fingerprint")
        except Exception:
            logger.debug("Fingerprint capture failed (non-fatal)")

        # --- MFA Enforcement (redirect to verification if required) ---
        try:
            if settings_obj.get("require_mfa", False) and not getattr(user, "email_verified_at", None):
                logger.info("Redirecting %s to MFA/email verification", getattr(user, "email", user.pk))
                return redirect("users:verify_email")
        except Exception:
            logger.exception("MFA check failed (non-fatal)")

        return response


# ============================================================
# Enterprise Signup View
# ============================================================
class EnterpriseSignupView(SignupView):
    """Tenant-aware signup with optional reCAPTCHA verification."""
    form_class = SignupForm
    template_name = "account/signup.html"

    def form_valid(self, form):
        s = _get_settings(self.request)

        if not s.get("enable_signup", True):
            form.add_error(None, "Signup is currently disabled.")
            logger.info("Signup attempt blocked by settings.")
            return self.form_invalid(form)

        token = self.request.POST.get("g-recaptcha-response") or self.request.POST.get("recaptcha_token")
        if s.get("recaptcha_enabled", False) and token:
            try:
                client_ip = (
                    self.request.META.get("HTTP_X_FORWARDED_FOR")
                    or self.request.META.get("REMOTE_ADDR")
                    or "unknown"
                ).split(",")[0].strip()
                rc = verify_recaptcha(token, client_ip, action="signup")
                if not rc.get("ok"):
                    form.add_error(None, "reCAPTCHA failed. Please retry.")
                    logger.info("reCAPTCHA failed during signup → %s", rc)
                    return self.form_invalid(form)
            except Exception:
                logger.exception("reCAPTCHA error during signup")
                form.add_error(None, "reCAPTCHA error. Please try again.")
                return self.form_invalid(form)

        return super().form_valid(form)


# ============================================================
# Manual email verification (MFA / email)
# ============================================================
@login_required
def verify_email_view(request):
    """Manual verification for MFA / email confirmation."""
    user = request.user
    if request.method == "POST":
        code = request.POST.get("code", "").strip()
        if not code:
            messages.error(request, "Verification code required.")
            return render(request, "users/verify_email.html")

        if code == getattr(user, "verification_code", ""):
            user.email_verified_at = timezone.now()
            user.verification_code = ""
            user.save(update_fields=["email_verified_at", "verification_code"])
            messages.success(request, "Email verified successfully.")
            return redirect("users:dashboard")

        messages.error(request, "Invalid verification code.")
        logger.warning("Invalid verification attempt for user=%s", user.pk)

    return render(request, "users/verify_email.html")


# ============================================================
# Dashboard view
# ============================================================
@login_required
def dashboard_view(request):
    """Render user dashboard with recent announcements and notifications."""
    s = _get_settings(request)
    now = timezone.now()

    # Announcements: use 'message' (model uses message field)
    announcements = (
        Announcement.objects.filter(start_at__lte=now)
        .filter(Q(expires_at__isnull=True) | Q(expires_at__gt=now))
        .only("title", "message", "start_at", "expires_at")
        .order_by("-start_at")
    )

    notifications = (
        Notification.objects.filter(recipient=request.user)
        .select_related("recipient")
        .only("title", "message", "created_at")
        .order_by("-created_at")[:5]
    )

    context = {
        "site_settings": s,
        "announcements": announcements,
        "notifications": notifications,
        "credits": getattr(request.user, "credits", 0),
        "can_watch_ad": bool(s.get("recaptcha_enabled", False)),
        "can_pay": bool(s.get("enable_payments", True)),
    }
    return render(request, "users/dashboard.html", context)


# ============================================================
# Profile view
# ============================================================
@login_required
def profile_view(request):
    """Render the user profile overview page."""
    s = _get_settings(request)
    return render(
        request,
        "users/profile.html",
        {
            "user": request.user,
            "credits": getattr(request.user, "credits", 0),
            "site_settings": s,
        },
    )


# ============================================================
# Auth hub
# ============================================================
def auth_hub_view(request):
    """Landing page for login/signup/social auth selection."""
    return render(request, "account/hub.html")


--------------------------------------------
### FILE: apps\users\views_notifications.py
### SIZE: 3525 bytes
### HASH: 066791C37E5960A55F3D42C13584FBEF9F728B8705ACC9F40CEBE034C27A4596

from __future__ import annotations

import logging
from typing import Any, Dict

from django.contrib.auth.decorators import login_required
from django.http import (
    JsonResponse,
    HttpRequest,
    HttpResponse,
)
from django.shortcuts import get_object_or_404, render
from django.utils import timezone
from django.views.decorators.http import require_GET, require_POST

from .models import Announcement, Notification

logger = logging.getLogger(__name__)


# ============================================================================
# Serializers (JSON Safe)
# ============================================================================
def _serialize_notification(n: Notification) -> Dict[str, Any]:
    return {
        "id": n.id,
        "title": getattr(n, "title", ""),
        "message": getattr(n, "message", ""),
        "priority": getattr(n, "priority", None),
        "channel": getattr(n, "channel", None),
        "is_read": bool(n.is_read),
        "created_at": n.created_at.isoformat() if n.created_at else None,
        "read_at": n.read_at.isoformat() if n.read_at else None,
    }


# ============================================================================
# HTML Detail Page
# ============================================================================
@login_required
@require_GET
def notification_detail(request: HttpRequest, pk: int) -> HttpResponse:
    """
    HTML detail page for a single notification.
    Name fixed to match notifications_urls.py import.
    """
    notif = get_object_or_404(Notification, pk=pk, recipient=request.user)

    # Auto-mark as read
    if not notif.is_read:
        notif.is_read = True
        notif.read_at = timezone.now()
        notif.save(update_fields=["is_read", "read_at"])

    return render(
        request,
        "users/notifications/detail.html",
        {"notification": notif},
    )


# ============================================================================
# HTML List Page
# ============================================================================
@login_required
@require_GET
def notification_list(request: HttpRequest) -> HttpResponse:
    qs = Notification.objects.filter(recipient=request.user).order_by("-created_at")
    return render(
        request,
        "users/notifications/list.html",
        {"notifications": qs},
    )


# ============================================================================
# JSON Endpoints
# ============================================================================
@login_required
@require_GET
def notification_unread_count(request: HttpRequest) -> JsonResponse:
    count = Notification.objects.filter(recipient=request.user, is_read=False).count()
    return JsonResponse({"ok": True, "unread_count": count})


@login_required
@require_POST
def notification_mark_read(request: HttpRequest, pk: int) -> JsonResponse:
    notif = get_object_or_404(Notification, pk=pk, recipient=request.user)

    if not notif.is_read:
        notif.is_read = True
        notif.read_at = timezone.now()
        notif.save(update_fields=["is_read", "read_at"])

    return JsonResponse({"ok": True})


@login_required
@require_POST
def notification_mark_all_read(request: HttpRequest) -> JsonResponse:
    Notification.objects.filter(recipient=request.user, is_read=False).update(
        is_read=True,
        read_at=timezone.now(),
    )
    return JsonResponse({"ok": True})

--------------------------------------------
### FILE: gsminfinity\__init__.py
### SIZE: 1469 bytes
### HASH: A32DB2702A3F3796D7250E182FE602A39844ACAB2DB8D3FEC1CC139640A0451F

"""
Generic Django Project Package
------------------------------

This file MUST remain minimal, deterministic, and completely side-effect free.

Purposes:
    • Marks this directory as a Python package.
    • Exposes stable, lightweight project metadata (__version__, __author__, __description__).
    • Guarantees import-safety for manage.py, ASGI, and WSGI boot processes.
    • Prevents ANY automatic code execution, framework initialization, or heavy imports.
    • Protects against accidental inclusion of non-Python content.

Rules:
    • DO NOT import Django or project modules here.
    • DO NOT perform I/O, logging, settings access, or dynamic logic.
    • DO NOT use try/except — this file must never hide initialization issues.
    • Content must always remain pure constants + metadata only.

This structure is hardened for enterprise deployments where stability,
repeatability, and deterministic imports are essential.
"""

__all__ = ["__version__", "__author__", "__description__"]

# ---------------------------------------------------------------------
# PROJECT METADATA (STATIC — SAFE — NO SIDE EFFECTS)
# ---------------------------------------------------------------------

# Semantic Version (bump per release/tag)
__version__ = "1.0.0"

# Generic, reusable project metadata
__author__ = "Application System"
__description__ = "Core initializer for the Django application package."


--------------------------------------------
### FILE: gsminfinity\development.py
### SIZE: 3125 bytes
### HASH: D7B876121C9B240A605CF9E7CB1403590052B0B305EBA08E154D8EE30B74AB30

"""
GSMInfinity Development Settings
--------------------------------
Overrides production settings for local development.

✅ Always HTTP — never enforces HTTPS
✅ DEBUG = True
✅ Console email backend
✅ Safe cache, session & CSRF defaults
✅ Supports local runserver (no SSL certs required)
"""

from .settings import *  # import all production defaults
import os
from pathlib import Path

# -------------------------
# Core environment
# -------------------------
DEBUG = True
ENV = "development"

# Disable any accidental HTTPS enforcement (middleware or admin toggle)
FORCE_HTTPS_DEV_OVERRIDE = 0

ALLOWED_HOSTS = ["127.0.0.1", "localhost", "0.0.0.0"]

# -------------------------
# Security overrides (safe HTTP)
# -------------------------
SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
SESSION_COOKIE_HTTPONLY = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_BROWSER_XSS_FILTER = False
SECURE_CONTENT_TYPE_NOSNIFF = False
SESSION_COOKIE_SAMESITE = "Lax"

CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:8000",
    "http://localhost:8000",
    "http://0.0.0.0:8000",
]

# -------------------------
# Local SSL certificate paths (optional, not used by default)
# -------------------------
CERT_DIR = Path(BASE_DIR) / "certs"
SSL_CERT_FILE = CERT_DIR / "localhost.pem"
SSL_KEY_FILE = CERT_DIR / "localhost-key.pem"

# Optional developer feedback — nothing enforces SSL
if SSL_CERT_FILE.exists():
    print(f"🔒 Optional local certificate found: {SSL_CERT_FILE}")
else:
    print("🌐 Development mode running strictly over HTTP (no HTTPS enforced).")

# -------------------------
# Logging (verbose for development)
# -------------------------
LOGGING["root"]["level"] = "DEBUG"
for logger_name in ("apps.users", "apps.core", "apps.consent", "apps.site_settings"):
    LOGGING.setdefault("loggers", {}).setdefault(
        logger_name,
        {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    )

# -------------------------
# Email (console backend)
# -------------------------
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"

# -------------------------
# Cache (local memory)
# -------------------------
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "TIMEOUT": 300,
    }
}

# -------------------------
# Faster password hashing for quick test logins
# -------------------------
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.MD5PasswordHasher",
]

# -------------------------
# Optional development-only toolbar or extensions (future toggle)
# -------------------------
if DEBUG and "django_extensions" not in INSTALLED_APPS:
    INSTALLED_APPS += ["django_extensions"]

# -------------------------
# Runtime banner
# -------------------------
print("⚙️  GSMInfinity Development Settings Loaded (HTTP only, DEBUG=True)")


--------------------------------------------
### FILE: gsminfinity\settings.py
### SIZE: 13039 bytes
### HASH: FB3C024F8E0CD3979732ED7E56F0155F1831F922A5E81D409DE68B27605DB11C

# gsminfinity/settings.py
"""
Enterprise Django Settings
Django 5.2+ • Python 3.12+
Airtight • Modern • CSP-Safe • Zero Silent Failures • Hardened Imports
"""

from __future__ import annotations

import os
import logging
from pathlib import Path
from typing import Any
from django.core.exceptions import ImproperlyConfigured

# Optional .env loader (non-fatal)
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass

logger = logging.getLogger("gsminfinity")


# ---------------------------
# Helper utilities
# ---------------------------
def env_str(value: Any, default: str = "") -> str:
    return str(value) if value is not None else default


def env_bool(value: Any, default: bool = False) -> bool:
    if value is None:
        return default
    try:
        return str(value).strip().lower() in ("1", "true", "yes", "on")
    except Exception:
        return default


def env_list(value: Any, default: list | None = None) -> list:
    if value is None:
        return default or []
    try:
        return [v.strip() for v in str(value).split(",") if v.strip()]
    except Exception:
        return default or []


# ---------------------------
# Paths & core
# ---------------------------
BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = env_str(
    os.getenv("DJANGO_SECRET_KEY"),
    "django-insecure-development-secret",
)

DEBUG = env_bool(os.getenv("DJANGO_DEBUG", None), False)
ENV = "development" if DEBUG else "production"


# ---------------------------
# Allowed hosts
# ---------------------------
ALLOWED_HOSTS = env_list(os.getenv("DJANGO_ALLOWED_HOSTS"), ["127.0.0.1", "localhost"])
ALLOWED_HOSTS = [h for h in ALLOWED_HOSTS if h and h.strip()]

if not DEBUG and not ALLOWED_HOSTS:
    raise ImproperlyConfigured("ALLOWED_HOSTS cannot be empty when DEBUG=False.")


# ---------------------------
# Sites framework
# ---------------------------
try:
    SITE_ID = int(env_str(os.getenv("SITE_ID"), "1"))
except Exception:
    SITE_ID = 1


# ---------------------------
# Installed apps
# ---------------------------
DJANGO_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
]

THIRD_PARTY_APPS = [
    "import_export",
    "solo",
    "django_countries",
    "crispy_forms",
    "crispy_bootstrap5",
    "allauth",
    "allauth.account",
    "allauth.socialaccount",
    "django_extensions",
]

SOCIAL_PROVIDERS = [
    "allauth.socialaccount.providers.google",
    "allauth.socialaccount.providers.facebook",
    "allauth.socialaccount.providers.microsoft",
    "allauth.socialaccount.providers.github",
]

LOCAL_APPS = [
    "apps.core",
    "apps.users",
    "apps.site_settings",
    "apps.consent",
]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + SOCIAL_PROVIDERS + LOCAL_APPS


# ---------------------------
# Middleware
# ---------------------------
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "apps.core.middleware.security_headers.SecurityHeadersMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "apps.core.middleware.ssl_toggle.SslToggleMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "apps.core.middleware.request_meta.RequestMetaMiddleware",
    "django.middleware.locale.LocaleMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "allauth.account.middleware.AccountMiddleware",
    "apps.consent.middleware.ConsentMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]


# ---------------------------
# Routing / ASGI / WSGI
# ---------------------------
ROOT_URLCONF = "gsminfinity.urls"
WSGI_APPLICATION = "gsminfinity.wsgi.application"
ASGI_APPLICATION = "gsminfinity.asgi.application"


# ---------------------------
# Database
# ---------------------------
_db_name = env_str(os.getenv("DB_NAME"))
if not _db_name:
    _db_name = str(BASE_DIR / "db.sqlite3")

DATABASES = {
    "default": {
        "ENGINE": env_str(os.getenv("DB_ENGINE"), "django.db.backends.sqlite3"),
        "NAME": _db_name,
        "USER": env_str(os.getenv("DB_USER")),
        "PASSWORD": env_str(os.getenv("DB_PASSWORD")),
        "HOST": env_str(os.getenv("DB_HOST")),
        "PORT": env_str(os.getenv("DB_PORT")),

        # IMPORTANT:
        # async views (lazy_loader) cannot run with ATOMIC_REQUESTS=True
        # this caused your RuntimeError
        "ATOMIC_REQUESTS": False,

        "CONN_MAX_AGE": 60 if not DEBUG else 0,
    }
}


# ---------------------------
# Authentication
# ---------------------------
AUTH_USER_MODEL = "users.CustomUser"

AUTHENTICATION_BACKENDS = [
    "apps.users.auth_backends.MultiFieldAuthBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
    "django.contrib.auth.backends.ModelBackend",
]

AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator", "OPTIONS": {"min_length": 8}},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]


# ---------------------------
# i18n / timezone
# ---------------------------
LANGUAGE_CODE = env_str(os.getenv("DJANGO_LANGUAGE"), "en-us")
TIME_ZONE = env_str(os.getenv("DJANGO_TIME_ZONE"), "Asia/Riyadh")

USE_I18N = True
USE_TZ = True


# ---------------------------
# Static / Media
# ---------------------------
STATIC_URL = "/static/"
STATICFILES_DIRS = [BASE_DIR / "static"]
STATIC_ROOT = BASE_DIR / "staticfiles"

STATICFILES_STORAGE = (
    "django.contrib.staticfiles.storage.StaticFilesStorage"
    if DEBUG else
    "whitenoise.storage.CompressedManifestStaticFilesStorage"
)

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# ---------------------------
# Templates
# ---------------------------
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": DEBUG,
        "OPTIONS": {
            "debug": DEBUG,
            "string_if_invalid": "" if not DEBUG else "⚠ Missing: %s ⚠",
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "apps.site_settings.context_processors.site_settings",
                "apps.consent.context_processors.consent_context",
                "apps.core.context_processors.location_based_providers",
            ],
        },
    },
]

if not DEBUG:
    TEMPLATES[0]["APP_DIRS"] = False
    TEMPLATES[0]["OPTIONS"]["loaders"] = [
        (
            "django.template.loaders.cached.Loader",
            [
                "django.template.loaders.filesystem.Loader",
                "django.template.loaders.app_directories.Loader",
            ],
        )
    ]


# ---------------------------
# Login flows
# ---------------------------
LOGIN_URL = "account_login"
LOGIN_REDIRECT_URL = "/users/dashboard/"
LOGOUT_REDIRECT_URL = "/"
ACCOUNT_LOGOUT_ON_GET = True


# ---------------------------
# Caching
# ---------------------------
USE_REDIS = env_bool(os.getenv("USE_REDIS_CACHE"), False)

if USE_REDIS:
    REDIS_URL = env_str(os.getenv("REDIS_URL"), "redis://127.0.0.1:6379/1")
    CACHES = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": REDIS_URL,
            "OPTIONS": {
                "CLIENT_CLASS": "django_redis.client.DefaultClient",
                "IGNORE_EXCEPTIONS": not DEBUG,
            },
        }
    }
else:
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
            "TIMEOUT": 300,
        }
    }


# ---------------------------
# Logging
# ---------------------------
LOG_LEVEL = env_str(os.getenv("LOG_LEVEL"), "INFO")

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {"format": "{levelname} {asctime} {module} {message}", "style": "{"},
        "simple": {"format": "{levelname} {message}", "style": "{"},
    },
    "handlers": {"console": {"class": "logging.StreamHandler", "formatter": "simple"}},
    "root": {"handlers": ["console"], "level": LOG_LEVEL},
    "loggers": {
        "django": {"handlers": ["console"], "level": LOG_LEVEL, "propagate": False},
        "apps": {"handlers": ["console"], "level": LOG_LEVEL, "propagate": False},
    },
}


# ---------------------------
# Allauth
# ---------------------------
ACCOUNT_ADAPTER = "apps.users.adapters.CustomAccountAdapter"
SOCIALACCOUNT_ADAPTER = "apps.users.adapters.CustomSocialAccountAdapter"

ACCOUNT_FORMS = {"signup": "apps.users.forms.CustomSignupForm"}

ACCOUNT_LOGIN_METHODS = {"username", "email"}
ACCOUNT_UNIQUE_EMAIL = True
ACCOUNT_SIGNUP_FIELDS = ["email*", "username*", "password1*", "password2*"]
ACCOUNT_EMAIL_VERIFICATION = env_str(os.getenv("ACCOUNT_EMAIL_VERIFICATION"), "optional")
ACCOUNT_EMAIL_CONFIRMATION_EXPIRE_DAYS = 3
ACCOUNT_PREVENT_ENUMERATION = True
ACCOUNT_SESSION_REMEMBER = True
ACCOUNT_LOGOUT_ON_PASSWORD_CHANGE = True
ACCOUNT_PASSWORD_MIN_LENGTH = 8
ACCOUNT_USERNAME_BLACKLIST = ["admin", "root", "administrator", "system"]
ACCOUNT_RATE_LIMITS = {"login_failed": "5/300s", "signup": "10/3600s"}
ACCOUNT_DEFAULT_HTTP_PROTOCOL = "https" if not DEBUG else "http"
ACCOUNT_EMAIL_SUBJECT_PREFIX = "[Notification] "
ACCOUNT_PRESERVE_USERNAME_CASING = False


# ---------------------------
# Security
# ---------------------------
SECURE_SSL_REDIRECT = env_bool(os.getenv("SECURE_SSL_REDIRECT"), False)

SESSION_COOKIE_SECURE = env_bool(os.getenv("SESSION_COOKIE_SECURE"), False)
CSRF_COOKIE_SECURE = env_bool(os.getenv("CSRF_COOKIE_SECURE"), False)

SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = env_str(os.getenv("SESSION_COOKIE_SAMESITE"), "Lax")

SECURE_HSTS_SECONDS = int(env_str(os.getenv("SECURE_HSTS_SECONDS"), "0"))
SECURE_HSTS_INCLUDE_SUBDOMAINS = env_bool(os.getenv("SECURE_HSTS_INCLUDE_SUBDOMAINS"), False)
SECURE_HSTS_PRELOAD = env_bool(os.getenv("SECURE_HSTS_PRELOAD"), False)

SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True

X_FRAME_OPTIONS = env_str(os.getenv("X_FRAME_OPTIONS"), "DENY")
SECURE_REFERRER_POLICY = env_str(os.getenv("SECURE_REFERRER_POLICY"), "strict-origin-when-cross-origin")


# Trusted CSRF origins
_csrf_hosts = [h.strip() for h in ALLOWED_HOSTS if h and not h.startswith("*")]
CSRF_TRUSTED_ORIGINS = []
for host in _csrf_hosts:
    CSRF_TRUSTED_ORIGINS.append(f"https://{host}")
    CSRF_TRUSTED_ORIGINS.append(f"http://{host}")


# ---------------------------
# Email
# ---------------------------
EMAIL_BACKEND = env_str(
    os.getenv("EMAIL_BACKEND"),
    "django.core.mail.backends.console.EmailBackend" if DEBUG else "django.core.mail.backends.smtp.EmailBackend",
)
DEFAULT_FROM_EMAIL = env_str(os.getenv("DEFAULT_FROM_EMAIL"), "no-reply@local")
EMAIL_USE_TLS = env_bool(os.getenv("EMAIL_USE_TLS"), True)


# ---------------------------
# Celery / DRF
# ---------------------------
CELERY_BROKER_URL = env_str(os.getenv("CELERY_BROKER_URL"), "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = env_str(os.getenv("CELERY_RESULT_BACKEND"), CELERY_BROKER_URL)

CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": ["rest_framework.renderers.JSONRenderer"],
    "DEFAULT_PARSER_CLASSES": ["rest_framework.parsers.JSONParser"],
    "DEFAULT_AUTHENTICATION_CLASSES": ["rest_framework.authentication.SessionAuthentication"],
    "DEFAULT_PERMISSION_CLASSES": ["rest_framework.permissions.IsAuthenticated"],
    "EXCEPTION_HANDLER": "apps.core.exceptions.EnterpriseExceptionHandler.handle_api_exception",
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
}


# ---------------------------
# Startup banner
# ---------------------------
logger.info("⚙️ Settings Loaded (DEBUG=%s)", DEBUG)


--------------------------------------------
### FILE: gsminfinity\settings_dev.py
### SIZE: 3738 bytes
### HASH: 9DF115AF3F3278394718FF25FE45DF4E0030D62B0ACBFF1263DF813451088F20

"""
GSMInfinity Development Settings
================================
Overrides production `settings.py` for safe local development.

✅ DEBUG mode enabled
✅ HTTPS redirection fully disabled
✅ No HSTS / CSRF secure cookie enforcement
✅ Console email backend
✅ Local-only allowed hosts
✅ Fast logging and hashing
"""

from __future__ import annotations
from .settings import *  # import production defaults
from pathlib import Path

# ============================================================
# Environment / Debug
# ============================================================
DEBUG = True
ENV = "development"

ALLOWED_HOSTS = ["127.0.0.1", "localhost"]
SITE_ID = 1


# ============================================================
# Security Overrides (force HTTP)
# ============================================================
# Completely disable all HTTPS-related enforcement for dev
SECURE_SSL_REDIRECT = False
SECURE_HSTS_SECONDS = 0
SECURE_HSTS_INCLUDE_SUBDOMAINS = False
SECURE_HSTS_PRELOAD = False
SECURE_BROWSER_XSS_FILTER = False
SECURE_CONTENT_TYPE_NOSNIFF = False

SESSION_COOKIE_SECURE = False
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Lax"

CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False

# Ensure SslToggleMiddleware never forces HTTPS in dev
os.environ["FORCE_HTTPS_DEV_OVERRIDE"] = "0"


# ============================================================
# CSRF & Trusted Origins
# ============================================================
CSRF_TRUSTED_ORIGINS = [
    "http://127.0.0.1:8000",
    "http://localhost:8000",
]


# ============================================================
# Local SSL Certificate (optional)
# ============================================================
# Only used if you intentionally run dev server with TLS
CERT_DIR = Path("C:/certs")
SSL_CERT_FILE = CERT_DIR / "localhost.pem"
SSL_KEY_FILE = CERT_DIR / "localhost-key.pem"

if SSL_CERT_FILE.exists() and SSL_KEY_FILE.exists():
    print(f"🔒 Local HTTPS certs available: {SSL_CERT_FILE.name}")
else:
    print("⚠️  No local certs found — running HTTP-only")


# ============================================================
# Logging Configuration
# ============================================================
LOGGING["root"]["level"] = "DEBUG"
LOGGING["loggers"]["django"]["level"] = "DEBUG"

for logger_name in ("apps.users", "apps.core", "apps.consent", "apps.site_settings"):
    LOGGING["loggers"].setdefault(
        logger_name,
        {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    )


# ============================================================
# Email Backend (safe console)
# ============================================================
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
DEFAULT_FROM_EMAIL = "dev@gsm-infinity.local"


# ============================================================
# Caching (local memory)
# ============================================================
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "TIMEOUT": 300,
    }
}


# ============================================================
# Password Hashers (fast)
# ============================================================
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.MD5PasswordHasher",
]


# ============================================================
# Final notice
# ============================================================
print("⚙️  GSMInfinity Development Settings Loaded (HTTP-only, DEBUG=True)")


--------------------------------------------
### FILE: gsminfinity\urls.py
### SIZE: 4650 bytes
### HASH: 4B5F4B84DAB20CF8A930D7AD7F0B7D8D8104FA257E1D94D796842E87CD4E2A41

"""
Unified Enterprise URL Configuration for the project.

Production-ready for:
  • Django 5.2+
  • Python 3.12+
  • django-allauth 0.65+

Features:
  - Async-safe lazy loader
  - Modular routing (users, notifications under users, consent, site_settings, core)
  - Static & media (dev only)
  - Health endpoint
  - Hardened admin identity (non-branded)
"""

from __future__ import annotations

import inspect
import logging
from typing import Callable, Any

from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import include, path, re_path
from django.utils.module_loading import import_string
from django.views.generic import RedirectView

logger = logging.getLogger(__name__)


# =====================================================================
# Async-safe lazy view importer
# =====================================================================
def lazy_view(dotted_path: str) -> Callable[..., Any]:
    """
    Import view lazily at call time.
    Supports sync, async, and class-based views.
    """
    async def _wrapper(request, *args, **kwargs):
        view_obj = import_string(dotted_path)

        # Class-based view support
        if inspect.isclass(view_obj) and hasattr(view_obj, "as_view"):
            view_callable = view_obj.as_view()
        else:
            view_callable = view_obj

        result = view_callable(request, *args, **kwargs)

        # Async view support
        if inspect.isawaitable(result):
            return await result
        return result

    return _wrapper


# =====================================================================
# Admin Branding (non-branded; project rule)
# =====================================================================
admin.site.site_header = "Administration"
admin.site.site_title = "Admin Portal"
admin.site.index_title = "System Management Console"


# =====================================================================
# URL Patterns
# =====================================================================
urlpatterns = [

    # Admin
    path("admin/", admin.site.urls),

    # Authentication (allauth)
    path("accounts/", include("allauth.urls")),

    # Users module
    path("users/", include(("apps.users.urls", "users"), namespace="users")),

    # Notifications (implemented inside users app)
    # NOTE: module apps.users.notifications_urls defines app_name="users_notifications",
    # so we include it with the same internal app_name and namespace to avoid conflicts.
    path(
        "notifications/",
        include(("apps.users.notifications_urls", "users_notifications"), namespace="users_notifications"),
    ),

    # Consent subsystem
    path("consent/", include(("apps.consent.urls", "consent"), namespace="consent")),

    # Site settings
    path("site_settings/", include(("apps.site_settings.urls", "site_settings"), namespace="site_settings")),

    # Core module
    path("core/", include(("apps.core.urls", "core"), namespace="core")),

    # Public root pages
    path("", lazy_view("apps.core.views.home"), name="home"),
    path("tenants/", lazy_view("apps.core.views.tenants"), name="tenants"),

    # Health check (well-known)
    path(".well-known/health", lazy_view("apps.core.views.health_check"), name="health_check"),

    # Legacy redirect
    path("index/", RedirectView.as_view(pattern_name="home", permanent=True)),

    # Favicon
    re_path(r"^favicon\.ico$", RedirectView.as_view(url="/static/favicon.ico", permanent=True)),
]


# =====================================================================
# Static & Media (DEV only)
# =====================================================================
if settings.DEBUG:
    # media files
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

    try:
        from django.contrib.staticfiles.urls import staticfiles_urlpatterns
        urlpatterns += staticfiles_urlpatterns()
    except Exception as exc:
        logger.warning("staticfiles_urlpatterns() unavailable: %s", exc)
        urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)


# =====================================================================
# Error handlers
# =====================================================================
handler400 = "apps.core.views.error_400_view"
handler403 = "apps.core.views.error_403_view"
handler404 = "apps.core.views.error_404_view"
handler500 = "apps.core.views.error_500_view"


--------------------------------------------
### FILE: static\js\package.json
### SIZE: 584 bytes
### HASH: 1E4A58FD5A1DDF4028394E2DDEEE8A9831FB92D649FDCE8913E04257B2F46A54

{
  "name": "gsminfinity-enterprise-static",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build:css": "tailwindcss -i ./static/src_css/main.css -o ./static/css/main.css --minify",
    "watch:css": "tailwindcss -i ./static/src_css/main.css -o ./static/css/main.css --watch",
    "bundle:js": "esbuild static/js/ --bundle --minify --outdir=static/js/",
    "build": "npm run build:css && npm run bundle:js"
  },
  "devDependencies": {
    "tailwindcss": "^3.4.0",
    "postcss": "^8.4.30",
    "autoprefixer": "^10.4.15",
    "esbuild": "^0.21.0"
  }
}


